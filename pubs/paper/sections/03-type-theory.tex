\documentclass[../paper.tex]{subfiles}
\begin{document}

\section{Type Theory}
\label{sec:type-theory}

Type theory is a formalism for the foundation of mathematics. It has
become a key instrument to study logic and proof theory, and follows
the same basis of constructive mathematics where the witnesses of a
statement, the proofs, have a fundamental role as same as their
statement.

Following the Curry-Howard correspondence (see, for
example,~\cite{Wadler-2015}), a formula corresponds to a \emph{type},
and one proof of that formula is a \emph{term} of the correspondent
type. Therefore, inhabited types are such formulas with proofs, they
are theorems.

Type theory is a formal system with a syntax and a set of derivation
rules. These rules enables us to derive conclusions called
\emph{judgments} which can be seen as derivation
trees~\cite{Bezem2002}.  Each term has associated a derivation and we
refer to these derivations as \emph{proof-terms}.

\begin{notation}

  We write the typing judgments as $a : \type{A}$ to denote that the
  term~$a$ is of type~$\type{A}$.

\end{notation}

Type theory can be seen as typed $λ$-calculus with
dependent function types, evaluation of $λ$-terms also called
\emph{normalization} of the proof-terms, is a process of reductions
with the system inference rules. Therefore, the proof verification
task becomes in type theory as verifying that the proof-term has the
correspondent type of the theorem. We refer to this process as
\emph{type-checking}.

This feature of type theory allow us to verify a proof generated by an
\ATP by reconstructing its proof-term to type-check the proof. For
such a purpose, we use a proof-assistant based on type theory, \Agda,
to delegate this task as in~\cite{Bezem2002}. Some limitations
of the type theory point-of-view for proof-reconstruction is described
in Section~\ref{ssec:structural-recursion} and
Section~\ref{ssec:intuitionistic-logic}.

% ...................................................................

% section section_name (end)
\subsection{Terminating functions}
\label{ssec:structural-recursion}

To reconstruct \Metis inference rules in type theory, we observed that
some rules or their inner functions are implemented by \emph{general
recursive} functions (see the definition of these functions
in~\cite{Bove2002}).

Functions defined by a general recursion can not be directly
translated in type theory since it is not guaranteed that they terminate.
For that reason, we follow the technique described
in~\cite{Bertot2004} to avoid termination problems by modifying the
recursive functions to be \emph{structurally recursive}.

A recursive function is structurally recursive if it calls itself with
only structurally smaller arguments~\cite{Abel2002}. General recursive
functions can sometimes be rewritten into structurally recursive
functions by  using for instance, the \emph{bounded recursion}
technique or other methods as in \cite{Coquand1992,Abel2002,Bove2005}.

The bounded recursion technique defines a new structural recursive function
based on the general recursive function by adding an argument. The
new argument is the \emph{bound}, a natural number given by the
function complexity.
In other words, the added argument will represent the number of times
the function needs to call itself to get the expected outcome.

\begin{notation}

We define \Prop for the type of propositions. A proposition is an
expression of indivisible propositional variables (\eg, symbols $φ₀,
φ₁, \dots$), and the logic constants: $⊥$, $⊤$, the binary connectives
($∧, ∨, ⇒)$, and the negation $(\neg)$. We use the inductive
definition for propositions presented in~\cite{VanDalen1994}. The
syntactical equality between two propositions φ and ψ is written using
the symbol (≡) as $φ ≡ ψ$. This equality between propositions is
precisely the Identity type $\mathsf{Id}_{\Prop}(φ, ψ)$ in Martin-Löf
type theory. Therefore, it holds the reflexivity, symmetry and
transitivity property for equality. The type of natural numbers is
called \Nat, and it is defined as usual, \ie, $\zero$ and $\suc$ are
its data constructors. We use names and symbols for the arithmetic
operations as usual (\eg, $+$, $-$, $*$). We use syntax sugar for
$\zero$, $\suc$, $\suc~\zero$, $\dots$, with the decimal
representation~$0$, $1$, $2$, $\dots$ as well. 

\end{notation}

Hence, one approach to define a structural recursive function based on
a general recursive function $f₀ : \type{A} \to \type{B}$ is to
formulate a new function $f₁ : \type{A} \to \Nat \to \type{B}$ where
all of its recursive calls are done with \emph{smaller} values on its
second argument~\cite{Abel2002}.

\begin{notation}
In the latter definitions and theorems, we  use a common notation in
type theory, pattern-matching~\cite{Coquand1992} to define functions by
cases on the inductive definition for the type of the arguments.
\end{notation}

\begin{myexamplenum}
\label{ex:structural-recursion}

Let us consider the following example to show the bounded recursion
technique for defining the \fuh function. This function is used for
reconstructing a \Metis inference rule in
Section~\ref{sssec:strip-a-goal}.

\begin{empheq}[box=\fcolorbox{bocolor}{bgcolor}]{equation}
  \label{eq:uh-definition}
  \begin{aligned}
  &\hspace{.495mm}\fuh_{0} : \Prop → \Prop\\
  &\begin{array}{lll}
  \fuh_{0} &(φ₁ ⇒ (φ₂ ⇒ φ₃)) &= \fuh_{0}~((φ₁ ∧ φ₂) ⇒ φ₃)\\
  \fuh_{0} &(φ₁ ⇒ (φ₂ ∧ φ₃)) &= \fuh_{0}~(φ₁ ⇒ φ₂) ∧ \fuh_{0}~(φ₁ ⇒ φ₃)\\
  \fuh_{0} &φ                &= φ.
\end{array}
  \end{aligned}
  \end{empheq}

In~\eqref{eq:uh-definition}, the first two equations in the $\fuh_{0}$
function definition are not structurally recursive. As a consequence,
we could not use this function in \Agda which would report a
non-terminating error. This happens because the formula used in the
recursive calls are not subformulas of the input formula in the
function argument. Therefore, one way to define $\fuh_{0}$ in type
theory is to define a new function using a bounded recursion.

\begin{empheq}[box=\fcolorbox{bocolor}{bgcolor}]{equation*}
\label{eq:uh-structured}
    \begin{aligned}
    &\hspace{.495mm} \fuh_{1} : \Prop → \Nat → \Prop\\
    &\begin{array}{llll}
    \fuh_{1} &(φ₁ ⇒ (φ₂ ⇒ φ₃)) &(\suc~n) &= \fuh_{1}~((φ₁ ∧ φ₂) ⇒ φ₃)~n\\
    \fuh_{1} &(φ₁ ⇒ (φ₂ ∧ φ₃)) &(\suc~n) &= \fuh_{1}~(φ₁ ⇒ φ₂)~n ∧ \fuh_{1}~(φ₁ ⇒ φ₃)~n\\
    \fuh_{1} &φ &n &= φ.
    \end{array}
  \end{aligned}
\end{empheq}

We bounded the recursion calls of the $\fuh_{0}$ function using its
\emph{complexity measure}. We refer to the complexity measure of a
function as the number of steps the function takes to finish. Since
the $\fuh_{0}$ function is recursive, we can define its complexity
measure by defining a recursive function instead of a closed formula
for such a number. However, this function must to be structurally
recursive as well, and it can be defined by following the
pattern-matching cases of its definition. Thus,  the complexity
measure of the $\fuh_{0}$ function can be defined as follows.

% In this particular case,
% as we can see by the definition of the $\fuh_{0}$ function, the pattern-matching cases depend on the formula structure for implications. For example, when φ ≡ in the consequent when the input formula is an implication. For example, when the input formula
% is an implication like φ₁ ⇒ (φ₂ ∧ φ₃) then, the recursive calls
% are using only the consequent φ₂ ∧ φ₃, otherwise, if φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃) based on the cases of the function definition, we only need
% to take care of φ₃.


% We have used the complexity measure definition for a formula defined
% in~\cite{Agudelo-Agudelo2017} to define other complexity measures in
% this paper.

\begin{empheq}[box=\fcolorbox{bocolor}{bgcolor}]{equation*}
  \label{eq:uh-complexity}
  \begin{aligned}
    &\hspace{.495mm}\fuh_{cm} : \Prop → \Nat\\
    &\begin{array}{llll}
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ⇒ φ₃)) &= \fuh_{cm}~φ₃ + 2\\
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ∧ φ₃)) &= \fmax~(\fuh_{cm}~φ₂)~(\fuh_{cm}~φ₃) + 1\\
    \fuh_{cm}~φ                &= 0.
    \end{array}
  \end{aligned}
\end{empheq}


Finally, we are able to define the $\fuh$ function which is the
structural recursive definition of the function~$\fuh_{0}$ also
suitable to use in \Agda.

\begin{empheq}[box=\fcolorbox{bocolor}{bgcolor}]{equation*}
 \begin{aligned}
  \label{eq:uh}
  \begin{split}
  &\hspace{.495mm}\fuh_{cm} : \Prop → \Prop\\
  &\fuh~φ~ = \fuh_{1}~φ~(\fuh_{cm}~φ).
  \end{split}
\end{aligned}
\end{empheq}

\end{myexamplenum}

\subsection{Intuitionistic logic}
\label{ssec:intuitionistic-logic}

Type theory is foundation for constructive mathematics, and its
internal language is the intuitionistic logic. Proving propositions in
this theory demands a witness construction for the proof.
Traditionally, for example in classical logic, a witness is not always
needed as we can prove arguments by contraction, named \emph{reductio
ad absurdum}.

To reconstruct proofs generated by \Metis, we have formalized in type
theory the classical propositional logic in~\cite{AgdaProp}.  A
briefly description of it is presented in \cite{VanDalen1994}. In this
formalization, we have to assume the principle of excluded middle
(henceforth \abbre{PEM}) as an axiom since \Metis is a prover for
classical logic. Assuming \abbre{PEM}, we can justify refutation
proofs by deriving from it the \emph{reductio ad absurdum} rule
(henceforth \abbre{RAA}). The \abbrev{RAA} rule is the formulation of
the principle of proof by contradiction, that is, a derivation of a
contradiction,~$⊥$, from the hypothesis~$¬ φ$, is a derivation of~$φ$.

\begin{notation}
  The $\abbre{List}$ type is the usual inductive and parametric type
  for lists.
\end{notation}

We formalize the syntactical consequence relation of \CPL by an
inductive family \verb!_⊢_! with two indexes, a set of propositions
(the premises) and a proposition (the conclusion), that is, $Γ ⊢ φ$
represents that there is derivation with conclusion $φ : \Prop$ from
the set of premises $Γ : \List~\Prop$. We implemented
in~\cite{AgdaProp} the syntactical consequence relation in a similar
way as it was presented in~\cite{Altenkirch2015}. For that reason, we
have included in Fig.~\ref{fig:CPL-inference-rules} the valid
inference rules: structural rules like \emph{weaken}, formation and
elimination rules of the logical connectives and to reason
classically, we add the \abbre{PEM} axiom.

\begin{figure}
\begin{equation*}
  \begin{bprooftree}
    \AxiomC{\,}
    \RightLabel{assume}
    \UnaryInfC{$Γ , φ ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{weaken}
    \UnaryInfC{$Γ , ψ ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{\,}
    \RightLabel{$⊤$-intro}
    \UnaryInfC{$Γ ⊢ ⊤$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ⊥$}
    \RightLabel{$⊥$-elim}
    \UnaryInfC{$Γ ⊢ φ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ ⊥$}
    \RightLabel{$¬$-intro}
    \UnaryInfC{$Γ ⊢ ¬ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ¬ φ$}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{$¬$-elim}
    \BinaryInfC{$Γ ⊢ ⊥$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \AxiomC{$Γ ⊢ ψ$}
    \RightLabel{$\wedge$-intro}
    \BinaryInfC{$Γ ⊢ φ \wedge ψ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ \wedge ψ$}
    \RightLabel{$\wedge$-proj$_1$}
    \UnaryInfC{$Γ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ \wedge ψ$}
    \RightLabel{$\wedge$-proj$_2$}
    \UnaryInfC{$Γ⊢ ψ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{$\vee$-intro$_1$}
    \UnaryInfC{$Γ ⊢ φ \vee ψ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ψ$}
    \RightLabel{$\vee$-intro$_2$}
    \UnaryInfC{$Γ ⊢ φ \vee ψ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ γ $}
    \AxiomC{$Γ , ψ  ⊢ γ$}
    \RightLabel{$\vee$-elim}
    \BinaryInfC{$Γ , φ \vee ψ ⊢ γ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ ψ$}
    \RightLabel{$⇒$-intro}
    \UnaryInfC{$Γ ⊢ φ ⇒ ψ$}
  \end{bprooftree}
\end{equation*}

\[
%\scalebox{0.9}{
\begin{bprooftree}
\AxiomC{$Γ ⊢ φ ⇒ ψ$}
\AxiomC{$Γ ⊢ φ$}
\RightLabel{$⇒$-elim}
\BinaryInfC{$Γ ⊢ ψ$}
\end{bprooftree}\qquad
\begin{bprooftree}
\AxiomC{\,}
\RightLabel{PEM}
\UnaryInfC{$Γ ⊢ φ ∨ ¬ φ$}
\end{bprooftree}
\]

% \[
% \qquad
% \begin{bprooftree}
% \AxiomC{$Γ, ¬ φ ⊢ ⊥$}
% \RightLabel{RAA}
% \UnaryInfC{$Γ ⊢ φ$}
% \end{bprooftree}
% \]


\caption{Inference rules for classical propositional logic.}
\label{fig:CPL-inference-rules}
\end{figure}


\end{document}
