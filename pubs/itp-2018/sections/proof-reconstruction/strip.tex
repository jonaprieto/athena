\documentclass[../../main.tex]{subfiles}
\begin{document}

\subsubsection{Strip.}
\label{sssec:strip-a-goal}

To prove a goal, \Metis splits the goal into disjoint cases. This
process produces a list of new subgoals, the conjunction of these
subgoals implies the goal. Then, a proof of the goal becomes into a
set of smaller proofs, one refutation for each subgoal.

\begin{myexamplenum}

The subgoals associated to a goal are introduced
in the \TSTP derivation with the \strip inference rule.

\begin{verbatim}
  fof(goal, conjecture, (p ∧ r) ∧ q)).
  fof(s₁, p, inf(strip, goal)).
  fof(s₂, p ⇒ r, inf(strip, goal)).
  fof(s₃, (p ∧ r) ⇒ q, inf(strip, goal)).
\end{verbatim}

In this example, the conjecture $(p ∧ r) ∧ q$ is stripped into
tree subgoals: $p$, $p ⇒ r$ and $(p ∧ r) ⇒ q$.

\begin{equation}
\label{eq:strip-example}
(p ∧ (p ⇒ r) ∧ ((p ∧ r) ⇒ q)) ⇒ ((p ∧ r) ∧ q).
\end{equation}

\Metis proves each subgoal in the same order above from left to right
in~\eqref{eq:strip-example}.
So far, very little attention has been paid to the role of the \strip rule
in \TSTP derivations since \Metis does not make explicit the way
it uses the subgoals to prove the conjecture.
\end{myexamplenum}

We prove the correctness of the \strip inference rule in
Theorem~\ref{thm:strip}. To show that theorem, we need to prove
Lemma~\ref{lem:inv-uh-lem} and Lemma~\ref{lem:lem-inv-strip}.

\begin{mainlemma}
  \label{lem:inv-uh-lem}
Let $\text{n} : \Nat$ be the complexity measure of the $\fuh_0$ function
in~\eqref{eq:uh-definition}.
If $Γ ⊢ \fuh₁~φ~n$ then $Γ ⊢ φ$ where $\fuh₁$ is the function defined
in~\eqref{eq:uh-structured}.
\end{mainlemma}

The $\fstrip₀$ function defined in~\eqref{eq:strip-zero} yields the
conjunction of subgoals that implies the goal of the problem in the
\Metis \TSTP derivations. Nonetheless, this function is not a
structurally recursive function (see more details in
Appendix~\ref{app:strip-cm}).
Therefore, we present the $\fstrip₁$ function
in~\eqref{eq:strip-fixed} as the structurally recursive version
of the $\fstrip₀$ function by applying the
bounded technique described in
Section~\ref{ssec:structural-recursion}.
We define the $\fstrip₁$ function based on the reading of the \Metis source code.

\begin{equation}
\label{eq:strip-fixed}
\begin{aligned}
&\hspace{.495mm}\fstrip₁ : \Prop → \Nat → \Prop\\
&\begin{array}{llll}
\fstrip₁ &(φ₁ ∧ φ₂)     &(\suc~n) &= \fuh~(\fstrip₁~φ₁~n) ∧ \fuh~(φ₁ ⇒ \fstrip₁~φ₂~n)\\
\fstrip₁ &(φ₁ ∨ φ₂)     &(\suc~n) &= \fuh~((¬ φ₁) ⇒ \fstrip₁~φ₂~n)\\
\fstrip₁ &(φ₁ ⇒ φ₂)     &(\suc~n) &= \fuh~(φ₁ ⇒ \fstrip₁~φ₂~n)\\
\fstrip₁ &(¬ (φ₁ ∧ φ₂)) &(\suc~n) &= \fuh~(φ₁ ⇒ \fstrip₁~(¬ φ₂)~n)\\
\fstrip₁ &(¬ (φ₁ ∨ φ₂)) &(\suc~n) &= \fuh~(\fstrip₁~(¬ φ₁)~n) ∧ \fuh~((¬ φ₁) ⇒ \fstrip₁~(¬ φ₂)~n)\\
\fstrip₁ &(¬ (φ₁ ⇒ φ₂)) &(\suc~n) &= \fuh~(\fstrip₁~φ₁~n) ∧ \fuh~(φ₁ ⇒ \fstrip₁~(¬ φ₂)~n)\\
\fstrip₁ &(¬ (¬ φ₁))    &(\suc~n) &= \fuh~(\fstrip₁~φ₁~n)\\
\fstrip₁ &(¬ ⊥)         &(\suc~n) &= ⊤\\
\fstrip₁ &(¬ ⊤)         &(\suc~n) &= ⊥\\
\fstrip₁ &φ             &n        &= φ.
\end{array}
\end{aligned}
\end{equation}

In a similar way as we define $\fuh_{cm}$
in~\eqref{eq:uh-complexity}, we
define the $\fstrip_{cm}$ function in Appendix~\ref{app:strip-cm} as
the complexity measure for the $\fstrip₀$ function.
We define the \fstrip function as follows in~\ref{eq:strip}.

\begin{align}
  \label{eq:strip}
  \begin{split}
  &\fstrip : \Prop → \Prop\\
  &\fstrip~φ~ = \fstrip_{1}~φ~(\fstrip_{cm}~φ).
  \end{split}
\end{align}

\begin{mainlemma}
\label{lem:lem-inv-strip}
Let $\text{n} : \Nat$ be the complexity measure of the \fstrip function defined
in~\eqref{eq:strip-fixed}.
If $Γ~⊢~\fstrip₁~φ~n$ then $Γ~⊢~φ$.
\end{mainlemma}

The following theorem is convenient to substitute equals by equals in
a theorem. Recall the equality (≡) is symmetric and transitive as well.
We use these properties without any mention.

\begin{mainlemma}
  \label{lem:subst}
  Substitution theorem.
\begin{equation*}
  \label{eq:substitution-theorem}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ φ$}   \AxiomC{$ψ ≡ φ$}
  \RightLabel{\fsubst}
  \BinaryInfC{$Γ ⊢ ψ$}
  \end{bprooftree}
\end{equation*}
\end{mainlemma}

We can now formulate the result that justifies the stripping strategy
of \Metis to prove goals.
For the sake of brevity, we state the following theorem for the
\strip function when the goal has two subgoals. In other cases,
we extend the theorem in the natural way.

\begin{mainth}
\label{thm:strip}
Let $\text{n} : \Nat$ be the complexity measure of the strip function defined in Appendix~\ref{app:strip-cm}~\eqref{eq:strip-cm}.
Let $s₂$ and $s₃$ be the subgoals of the goal $φ$, that is,
$$\fstrip₁~φ~n~≡~s₂∧~s₃.$$
If $Γ ⊢ s₂$ and $Γ ⊢ s₃$ then $Γ ⊢ φ$.
\end{mainth}
% -------------------------------------------------------------------

Since \Metis proves a conjecture by refutation,
to prove each subgoal, \Metis assumes the negation of it
by using the \negate rule after the \strip inference application
that introduces such a subgoal.

\end{document}
