\documentclass[../../main.tex]{subfiles}
\begin{document}

\subsubsection{Strip.}
\label{sssec:strip-a-goal}

To prove a goal, \Metis splits the goal into disjoint cases. This
process produces a list of new subgoals, the conjunction of these
subgoals implies the goal. Then, a proof of the goal becomes into a
set of smaller proofs, one refutation for each subgoal.

\begin{myexamplenum}
In Fig.~\ref{complete-metis-example}, we can see how
the subgoals associated to a goal are introduced
in the \TSTP derivation line \ref{line3} with the \strip inference rule.
The conjecture in line \ref{line2}, $(p ∨ q) ⇒ (p ∧ q)$,
is stripped into two subgoals (line~\ref{line4} and \ref{line5}):
$(p ∨ q) ⇒ p$ and $((p ∨ q) ∧ p) ⇒ q$.
\Metis proves each subgoal separately following the same order as
they appeared in the \TSTP derivation.
\end{myexamplenum}

\begin{remark}
\Metis does not make explicit in the \TSTP derivation the way it uses the
subgoals to prove the goal. We show this approach in the correctness of the
\strip inference rule in Theorem~\ref{thm:strip}. To show this theorem, we prove
Lemma~\ref{lem:inv-uh-lem} and  Lemma~\ref{lem:lem-inv-strip}. In the former, we
introduce the auxiliary function $\fuh_1$ to define the $\fuh$ function used to
define the $\fstrip_1$ function in the latter.
\end{remark}

\begin{mainlemma}
  \label{lem:inv-uh-lem}
Let $\text{n} : \Nat$. If $Γ ⊢ \fuh₁~φ~n$ then $Γ ⊢ φ$ where

\begin{equation}
\label{eq:uh-structured}
\begin{aligned}
&\hspace{.495mm} \fuh_{1} : \Prop → \Nat → \Prop\\
&\begin{array}{llll}
\fuh_{1} &(φ₁ ⇒ (φ₂ ⇒ φ₃)) &(\suc~n) &= \fuh_{1}~((φ₁ ∧ φ₂) ⇒ φ₃)~n\\
\fuh_{1} &(φ₁ ⇒ (φ₂ ∧ φ₃)) &(\suc~n) &= \fuh_{1}~(φ₁ ⇒ φ₂)~n ∧ \fuh_{1}~(φ₁ ⇒ φ₃)~n\\
\fuh_{1} &φ &n &= φ.
\end{array}
\end{aligned}
\end{equation}
\end{mainlemma}

The second argument in the $\fuh_1$ function is a natural number that constrains
the number of recursive calls. To provide such a number given a formula
$\varphi$, we call the $\fuh_{cm}$ function defined in~\eqref{eq:uh-complexity}.
This function finds what we call the \emph{function complexity} of the function
$\fuh_1$. For the convenience in the following descriptions, we use the
function $\fuh : \Prop → \Prop$ for $\varphi \mapsto \fuh_{1}~φ~(\fuh_{cm}~φ)$.

\begin{equation}
  \label{eq:uh-complexity}
  \begin{aligned}
    &\hspace{.495mm}\fuh_{cm} : \Prop → \Nat\\
    &\begin{array}{llll}
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ⇒ φ₃)) &= \fuh_{cm}~φ₃ + 2\\
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ∧ φ₃)) &= \fmax~(\fuh_{cm}~φ₂)~(\fuh_{cm}~φ₃) + 1\\
    \fuh_{cm}~φ                &= 0.
    \end{array}
  \end{aligned}
\end{equation}


% \begin{align}
%   \label{eq:uh}
%   \begin{split}
%   &\fuh : \Prop → \Prop\\
%   &\fuh~φ~ = \fuh_{1}~φ~(\fuh_{cm}~φ).
%   \end{split}
% \end{align}

% == CONTINUAR DESDE AQUI

The $\fstrip₀$ function defined in~\eqref{eq:strip-zero} yields the
conjunction of subgoals that implies the goal of the problem in the
\Metis \TSTP derivations. Nonetheless, this function is not a
structurally recursive function (see more details in
Appendix~\ref{app:strip-cm}).
Therefore, we present the $\fstrip₁$ function
in~\eqref{eq:strip-fixed} as the structurally recursive version
of the $\fstrip₀$ function by applying the
bounded technique described in
Section~\ref{ssec:structural-recursion}.
We define the $\fstrip₁$ function based on the reading of the \Metis source code.

\begin{equation}
\label{eq:strip-fixed}
\begin{aligned}
&\hspace{.495mm}\fstrip₁ : \Prop → \Nat → \Prop\\
&\begin{array}{llll}
\fstrip₁ &(φ₁ ∧ φ₂)     &(\suc~n) &= \fuh~(\fstrip₁~φ₁~n) ∧ \fuh~(φ₁ ⇒ \fstrip₁~φ₂~n)\\
\fstrip₁ &(φ₁ ∨ φ₂)     &(\suc~n) &= \fuh~((¬ φ₁) ⇒ \fstrip₁~φ₂~n)\\
\fstrip₁ &(φ₁ ⇒ φ₂)     &(\suc~n) &= \fuh~(φ₁ ⇒ \fstrip₁~φ₂~n)\\
\fstrip₁ &(¬ (φ₁ ∧ φ₂)) &(\suc~n) &= \fuh~(φ₁ ⇒ \fstrip₁~(¬ φ₂)~n)\\
\fstrip₁ &(¬ (φ₁ ∨ φ₂)) &(\suc~n) &= \fuh~(\fstrip₁~(¬ φ₁)~n) ∧ \fuh~((¬ φ₁) ⇒ \fstrip₁~(¬ φ₂)~n)\\
\fstrip₁ &(¬ (φ₁ ⇒ φ₂)) &(\suc~n) &= \fuh~(\fstrip₁~φ₁~n) ∧ \fuh~(φ₁ ⇒ \fstrip₁~(¬ φ₂)~n)\\
\fstrip₁ &(¬ (¬ φ₁))    &(\suc~n) &= \fuh~(\fstrip₁~φ₁~n)\\
\fstrip₁ &(¬ ⊥)         &(\suc~n) &= ⊤\\
\fstrip₁ &(¬ ⊤)         &(\suc~n) &= ⊥\\
\fstrip₁ &φ             &n        &= φ.
\end{array}
\end{aligned}
\end{equation}

In a similar way as we define $\fuh_{cm}$
in~\eqref{eq:uh-complexity}, we
define the $\fstrip_{cm}$ function in Appendix~\ref{app:strip-cm} as
the complexity measure for the $\fstrip₀$ function.
We define the \fstrip function as follows in~\ref{eq:strip}.

\begin{align}
  \label{eq:strip}
  \begin{split}
  &\fstrip : \Prop → \Prop\\
  &\fstrip~φ~ = \fstrip_{1}~φ~(\fstrip_{cm}~φ).
  \end{split}
\end{align}

\begin{mainlemma}
\label{lem:lem-inv-strip}
Let $\text{n} : \Nat$ be the complexity measure of the \fstrip function defined
in~\eqref{eq:strip-fixed}.
If $Γ~⊢~\fstrip₁~φ~n$ then $Γ~⊢~φ$.
\end{mainlemma}

The following theorem is convenient to substitute equals by equals in
a theorem. Recall the equality (≡) is symmetric and transitive as well.
We use these properties without any mention.

\begin{mainlemma}
  \label{lem:subst}
  Substitution theorem.
\begin{equation*}
  \label{eq:substitution-theorem}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ φ$}   \AxiomC{$ψ ≡ φ$}
  \RightLabel{\fsubst}
  \BinaryInfC{$Γ ⊢ ψ$}
  \end{bprooftree}
\end{equation*}
\end{mainlemma}

We can now formulate the result that justifies the stripping strategy
of \Metis to prove goals.
For the sake of brevity, we state the following theorem for the
\strip function when the goal has two subgoals. In other cases,
we extend the theorem in the natural way.

\begin{mainth}
\label{thm:strip}
Let $\text{n} : \Nat$ be the complexity measure of the strip function defined in Appendix~\ref{app:strip-cm}~\eqref{eq:strip-cm}.
Let $s₂$ and $s₃$ be the subgoals of the goal $φ$, that is,
$$\fstrip₁~φ~n~≡~s₂∧~s₃.$$
If $Γ ⊢ s₂$ and $Γ ⊢ s₃$ then $Γ ⊢ φ$.
\end{mainth}
% -------------------------------------------------------------------

Since \Metis proves a conjecture by refutation,
to prove each subgoal, \Metis assumes the negation of it
by using the \negate rule after the \strip inference application
that introduces such a subgoal.

\end{document}
