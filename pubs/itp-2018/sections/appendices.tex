
\documentclass[../main.tex]{subfiles}
\begin{document}

\clearpage

\begin{subappendices}

\renewcommand{\thesection}{\Alph{section}}%

\section{Customized TSTP syntax}
\label{app:tstp-syntax}

We adopted a special \TSTP syntax to improve the readability of the \TSTP
examples shown in this document. Some of the modifications to the original
presentation of \TSTP syntax in Section~\ref{ssec:output-language} are the
following.

\begin{itemize}
  \item The formulas names are sub indexed (\eg, instead of \verb!axiom_0!,
  we write \verb!axiom₀!).
  \item We use \verb!inf! instead of \verb!inference! field.
  \item We shorten names generated automatically by \Metis, (\eg,
\verb!s₀! instead of \verb!subgoal_0! or \verb!n₀!
instead of \verb!normalize_0!).
  \item We remove the \verb!plain! role.
  \item We remove empty fields in the inference information.
  \item The brackets in the argument of a unary inference are removed (\eg,
instead of \verb!inf(rule, [], [n₀]))!, we write
\verb!inf(rule, [], n₀))!).
  \item If the inference rule does not need arguments except its parent nodes,
  we remove the field of useful information (\eg,
 \verb!inf(canonicalize, premise)! instead of
 \verb!inf(canonicalize, [], premise)!).
  \item We use the symbols (⊤, ⊥, ¬, ∧, ∨, ⇒) for formulas instead of
  (\verb!$false!, \verb!$true!, \verb!~!, \verb!&!, \verb!|!, \verb!=>!) \TPTP symbols.
  \item When the purpose to show a \TSTP derivation does not include
  some parts of the derivation we use the ellipsis (\verb!...!) to avoid
  such unnecessary parts.
\end{itemize}

For example, let us consider the \TSTP derivation generated by \Metis
in Fig.~\ref{fig:metis-proof-tstp} and its customized version in
Fig.~\ref{fig:metis-proof-tstp-customized}

\begin{figure}
\begin{verbatim}
  fof(premise, axiom, p).
  fof(goal, conjecture, p).
  fof(subgoal_0, plain, p, inference(strip, [], [goal])).
  fof(negate_0_0, plain, ~ p, inference(negate, [], [subgoal_0])).
  fof(normalize_0_0, plain, ~ p,
    inference(canonicalize, [], [negate_0_0])).
  fof(normalize_0_1, plain, p,
    inference(canonicalize, [], [premise])).
  fof(normalize_0_2, plain, $false,
    inference(simplify, [], [normalize_0_0, normalize_0_1]))
  cnf(refute_0_0, plain, $false,
    inference(canonicalize, [], [normalize_0_2])).
\end{verbatim}
\caption{\texttt{Metis}' \texttt{TSTP} derivation for the
problem $p\vdash p$.}
\label{fig:metis-proof-tstp}
\end{figure}

\clearpage
\begin{figure}[!ht]
\begin{verbatim}
  fof(premise, axiom, p).
  fof(goal, conjecture, p).
  fof(s₀, p, inf(strip, goal)).
  fof(neg₀, ¬ p, inf(negate, s₀)).
  fof(n₀, ¬ p, inf(canonicalize, neg₀)).
  fof(n₁, p, inf(canonicalize, premise)).
  fof(n₂, ⊥, inf(simplify, [n₀, n₁]))
  cnf(r₀, ⊥, inf(canonicalize, n₂)).
\end{verbatim}
\caption{\texttt{Metis}' \texttt{TSTP} derivation using a customized syntax}
\label{fig:metis-proof-tstp-customized}
\end{figure}
\vfill

\clearpage
\section{Bounded Recursion of the Strip Function}
\label{app:strip-cm}

In Section~\ref{sssec:strip-a-goal} we describe the
\strip function to get the subgoals of a certain a goal.
We define the first version of this function with the
$\fstrip₀$ function in~\eqref{eq:strip-zero} but the reader can note that this function is not a structurally recursive function.
Therefore, we define a structurally recursive function of this function in~\eqref{eq:strip-fixed}.

\begin{equation}
\label{eq:strip-zero}
\begin{aligned}
&\hspace{.495mm}\fstrip₀ : \Prop → \Prop\\
&\begin{array}{llll}
\fstrip₀ &(φ₁ ∧ φ₂)     &= \fuh~(\fstrip₀~φ₁) ∧ \fuh~(φ₁ ⇒ \fstrip₀~φ₂)\\
\fstrip₀ &(φ₁ ∨ φ₂)     &= \fuh~((¬ φ₁) ⇒ \fstrip₀~φ₂)\\
\fstrip₀ &(φ₁ ⇒ φ₂)     &= \fuh~(φ₁ ⇒ \fstrip₀~φ₂)\\
\fstrip₀ &(¬ (φ₁ ∧ φ₂)) &= \fuh~(φ₁ ⇒ \fstrip₀~(¬ φ₂))\\
\fstrip₀ &(¬ (φ₁ ∨ φ₂)) &= \fuh~(\fstrip₀~(¬ φ₁)) ∧ \fuh~((¬ φ₁) ⇒ \fstrip₀~(¬ φ₂))\\
\fstrip₀ &(¬ (φ₁ ⇒ φ₂)) &= \fuh~(\fstrip₀~φ₁) ∧ \fuh~(φ₁ ⇒ \fstrip₀~(¬ φ₂))\\
\fstrip₀ &(¬ (¬ φ₁))    &= \fuh~(\fstrip₀~φ₁)\\
\fstrip₀ &(¬ ⊥)         &= ⊤\\
\fstrip₀ &(¬ ⊤)         &= ⊥\\
\fstrip₀ &φ             &= φ.
\end{array}
\end{aligned}
\end{equation}

The complexity measure of $\fstrip₀$ is given by the $\fstrip_{cm}$ function
defined in~\eqref{eq:strip-cm}.

\begin{equation*}
\label{eq:strip-cm}
\begin{aligned}
&\hspace{.495mm}\fstrip_{cm} : \Prop \to \Nat \to \Prop\\
&\begin{array}{lll}
\fstrip_{cm} &(φ₁ ∧ φ₂)      &= \textrm{max}~(\fstrip_{cm}~φ₁)~(\fstrip_{cm}~φ₂) + 1\\
\fstrip_{cm} &(φ₁ ∨ φ₂)      &= \fstrip_{cm}~φ₂ + 1\\
\fstrip_{cm} &(φ₁ ⇒ φ₂)      &= \fstrip_{cm}~φ₂ + 1\\
\fstrip_{cm} &(¬ ⊤)          &= \fstrip_{cm}~(¬ φ₂) + 1\\
\fstrip_{cm} &(¬ ⊥)          &= \textrm{max}~(\fstrip_{cm}~(¬ φ₁))~(\fstrip_{cm}~(¬ φ₂)) + 1\\
\fstrip_{cm} &(¬ (φ₁ ∧ φ₂))  &= \textrm{max}~(\fstrip_{cm}~φ₁)~(\fstrip_{cm}~(¬ φ₂)) + 1\\
\fstrip_{cm} &(¬ (φ₁ ∨ φ₂))  &= \textrm{max}~(\fstrip_{cm}~(¬ φ₁))~(\fstrip_{cm}~(¬ φ₂)) + 1\\
\fstrip_{cm} &(¬ (φ₁ ⇒ φ₂))  &= \fstrip_{cm}~φ₁ + 1\\
\fstrip_{cm} &(¬ (¬ φ))      &= 1\\
\fstrip_{cm} &φ              &= 1
\end{array}
\end{aligned}
\end{equation*}

\section{Another Case in the Proof of the \strip Inference Rule}
\label{app:strip-proof-case}

\begin{itemize}
\item[∙] Case $φ ≡ φ₁ ⇒ φ₂$.
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{}
  \RightLabel{assume}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁$}
  \AxiomC{$Γ ⊢ \fstrip₁~(φ₁ ⇒ φ₂)~(\suc~n)$}
  \RightLabel{by~\eqref{eq:strip-fixed}}
  \UnaryInfC{$Γ ⊢ \fuh~(φ₁ ⇒ \fstrip₁~φ₂~n)$}
  \RightLabel{Lemma~\ref{lem:inv-uh-lem}}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ \fstrip₁~φ₂~n$}
  \RightLabel{weaken}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁ ⇒ \fstrip₁~φ₂~n$}
  \RightLabel{⇒-elim}
  \BinaryInfC{$Γ , φ₁ ⊢ \fstrip₁~φ₂~n$}
  \RightLabel{by~ind.~hyp.}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₂$}
  \RightLabel{⇒-intro.}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
  \end{bprooftree}
\end{equation*}
\end{itemize}


\clearpage
\section{Bounded Recursion of the Negative Normal Form Function}
\label{app:polarity-for-propositions}

In Section~\ref{sssec:canonicalize} we discuss a custom negative
normal form of a formula. To convert a formula to such a normal
form, we define the function $\fnnf_{0}$ in~\eqref{eq:nnf-zero}.

\begin{equation}
\label{eq:nnf-zero}
\begin{aligned}
&\hspace{.495mm}\fnnf_{0} : \Prop \to \Prop\\
&\begin{array}{lll}
\fnnf_{0} &(φ₁ ∧ φ₂)      &= \fcanon_{∧}~(\fassoc_{∧}~(\fnnf_{0}~φ₁ ∧ \fnnf_{0}~φ₂))\\
\fnnf_{0} &(φ₁ ∨ φ₂)      &= \fcanon_{∨}~(\fassoc_{∨}~(\fnnf_{0}~φ₁ ∨ \fnnf_{0}~φ₂))\\
\fnnf_{0} &(φ₁ ⇒ φ₂)      &= \fcanon_{∨}~(\fassoc_{∨}~(\fnnf_{0}~((¬ φ₁) ∨ φ₂)))\\
\fnnf_{0} &(¬ (φ₁ ∧ φ₂))  &= \fcanon_{∨}~(\fassoc_{∨}~(\fnnf_{0}~((¬ φ₁) ∨ (¬ φ₂))))\\
\fnnf_{0} &(¬ (φ₁ ∨ φ₂))  &= \fcanon_{∧}~(\fassoc_{∧}~(\fnnf_{0}~((¬ φ₁) ∧ (¬ φ₂))))\\
\fnnf_{0} &(¬ (φ₁ ⇒ φ₂))  &= \fcanon_{∧}~(\fassoc_{∧}~(\fnnf_{0}~((¬ φ₂) ∧ φ₁)))\\
\fnnf_{0} &(¬ (¬ φ))      &= \fnnf_{0}~φ₁\\
\fnnf_{0} &(¬ ⊤)          &= ⊥\\
\fnnf_{0} &(¬ ⊥)          &= ⊤\\
\fnnf_{0} &φ              &= φ
\end{array}
\end{aligned}
\end{equation}

However, then $\fnnf_{0}$ function is not a structurally recursive
function. Therefore, we define a bounded recursion in~\eqref{eq:nnf}
using as the second argument for the bounded recursion its complexity
measure. The $\fnnf_{cm}$ function in~\eqref{eq:nnf-cm} computes that
complexity measure.

\begin{equation}
\label{eq:nnf-cm}
\begin{aligned}
&\hspace{.495mm}\fnnf_{cm} : \Prop \to \Nat \to \Prop\\
&\begin{array}{lll}
\fnnf_{cm} &(φ₁ ∧ φ₂)      &= \fnnf_{cm}~φ₁ + \fnnf_{cm}~φ₂ + 1 \\
\fnnf_{cm} &(φ₁ ∨ φ₂)      &= \fnnf_{cm}~φ₁ + \fnnf_{cm}~φ₂ + 1 \\
\fnnf_{cm} &(φ₁ ⇒ φ₂)      &= 2 \cdot \fnnf_{cm}~φ₁  + \fnnf_{cm}~φ₂ + 1 \\
\fnnf_{cm} &(¬ (φ₁ ∧ φ₂))  &= \fnnf_{cm}~(¬ φ₁) + \fnnf_{cm}~(¬ φ₂) + 1 \\
\fnnf_{cm} &(¬ (φ₁ ∨ φ₂))  &= \fnnf_{cm}~(¬ φ₁) + \fnnf_{cm}~(¬ φ₂) + 1 \\
\fnnf_{cm} &(¬ (φ₁ ⇒ φ₂))  &= \fnnf_{cm}~(¬ φ₁) + 1 \\
\fnnf_{cm} &(¬ (¬ φ))      &= \fnnf_{cm}~φ₁ + \fnnf_{cm}~(¬ φ₂) + 3 \\
\fnnf_{cm} &(¬ ⊤)          &= 1 \\
\fnnf_{cm} &(¬ ⊥)          &= 1 \\
\fnnf_{cm} &φ              &= 1 \\
\end{array}
\end{aligned}
\end{equation}

Another approach to define the negative normal form in type theory
without using a complexity measure for the bounded recursion would
modify the definition of $\fnnf$ defined in~\cite{Bezem2002}. The
authors avoid the termination problem by using the polarity of the
formula as an additional argument of its negative normal form
function. However, be aware the polarity function is not standard and
\Metis has its own definition.

% \begin{equation}
% \label{def:polarity}
%   \begin{aligned}
%   &\hspace{.495mm}\fpolarity : \Prop \to \abbre{Polarity}\\
%     &\begin{array}{lll}
%       \fpolarity &(φ₁ ∧ φ₂) &= ⊕\\
%       \fpolarity &(φ₁ ∨ φ₂) &= ⊖\\
%       \fpolarity &(φ₁ ⇒ φ₂) &= ⊖\\
%       \fpolarity &(¬ φ)     &=
%         \begin{cases}
%         ⊕, &\text{ if }\fpolarity~φ=⊖;\\
%         ⊖, &\text{ if }\fpolarity~φ=⊕;
%         \end{cases}\\
%       \fpolarity &φ     &=⊕
%     \end{array}
%   \end{aligned}
% \end{equation}


% \section{A Small Example}
% \label{appendix}

% \subsection{\CPL Problem}

% \begin{equation*}
% \{\ (p ∨ q) ∧ (p ∨ r)\ \} \vdash p ∨ (q ∧ r)
% \end{equation*}

% \subsection{\TPTP Problem}

% \begin{verbatim}
%   fof(premise, axiom, ((p | q) & (p | r))).
%   fof(goal, conjecture, (p | (q & r))).
% \end{verbatim}

% \subsection{\Metis \TSTP Derivation}
% \verbatiminput{sections/data/problem.tstp}

% \subsection{\Agda Proof-term}
% \verbatiminput{sections/data/problem.agda}


% \section{Rank for a proposition}
% \label{app:rank-for-a-proposition}
% The rank for a proposition defined in~\cite{VanDalen1994} is
% a complexity measure.
% \begin{equation}
% % \label{eq:rank-definition}
% \begin{aligned}
% &\hspace{.495mm}\frank : \Prop → \Nat\\
% &\begin{array}{llll}
% \frank~(¬~φ)           &= \frank~φ₁~+~c_{¬}\\
% \frank~(φ₁~\square~φ₂) &= \fmax~(\frank~φ₁)~(\frank~φ₂) + c_{\square}\\
% \frank~φ               &= 0.
% \end{array}
% \end{aligned}
% \end{equation}


\clearpage
\section{A Complete Example of Proof-Reconstruction}
\label{app:complete-example}

\subsection{Installing Athena}

\Athena is the proof-reconstruction tool that accompanying this paper.
This tool is written in \Haskell and it was tested with
\prg{GHC}~8.2.1. To install \Athena, the package manager \verb!cabal!
is required as well. \Athena was tested with \verb!cabal!~1.24.0.

Let us download the \Athena repository running the following command:

\begin{verbatim}
  $ git clone https://github.com/jonaprieto/athena.git
  $ cd athena
\end{verbatim}

To install \Athena run the following command:

\begin{verbatim}
  $ make install
\end{verbatim}

To install the \Agda libraries, \verb!agda-prop!, \verb!agda-metis!, and
the \Agda standard library, run the following command:

\begin{verbatim}
  $ make install-libraries
\end{verbatim}

\subsection{Installing Metis}

To install the \Metis prover v2.3 (release 20171021),
we refer the reader to its official
repository at \url{https://github.com/gilith/metis}.

As an alternative to install the prover from the \Metis sources,
we have provided a \Haskell client
to use this prover but also other provers with \name{Online-ATPs}
tool\footnote{\url{https://github.com/jonaprieto/online-atps}.}.
To install this tool run the following command:

\begin{verbatim}
  $ make online-atps
  $ online-atps --version
  Online-atps version 0.1.1
\end{verbatim}

\subsection{TPTP problem}

Let us consider the following
theorem\footnote{Problem No.~13 in Disjunction Section in~\cite{Prieto-Cubides2017}.}:

\begin{equation}
\label{eq:complete-example-problem}
(p \Rightarrow q) \wedge (q \Rightarrow p) ⊢ (p \vee q) \Rightarrow (p \wedge q)
\end{equation}

This problem can be encode in \TPTP syntax (file \verb!problem.tptp!) as follows:

\begin{verbatim}
  $ cat problem.tptp
  fof(premise, axiom, (p => q) & (q => p)).
  fof(goal, conjecture, (p | q) => (p & q)).
\end{verbatim}

\subsection{Metis derivation}

To obtain the \Metis derivation of the \TPTP problem showed above,
make sure your \Metis version is supported by running the following
command. Recall we support the version 2.3 (release 20171021).

\begin{verbatim}
  $ metis --version
  metis 2.3 (release 20171021)
\end{verbatim}

To generate the \TSTP derivation of \verb!problem.tptp!
run the following command:

\begin{verbatim}
  $ metis --show proof problem.tptp > problem.tstp
  $ cat problem.tstp
  ...
  fof(premise, axiom, ((p => q) & (q => p))).
  fof(goal, conjecture, ((p | q) => (p & q))).
  fof(subgoal_0, plain, ((p | q) => p), inference(strip, [], [goal])).
  fof(subgoal_1, plain, (((p | q) & p) => q), inference(strip, [], [goal])).
  fof(negate_0_0, plain, (~ ((p | q) => p)),
      inference(negate, [], [subgoal_0])).
  ...
\end{verbatim}

If we are using the \name{Online-ATPs} tool run the following command:

\begin{verbatim}
  $ online-atps --atp=metis problem.tptp  > problem.tstp
\end{verbatim}

Using our customized \TSTP syntax, the above \Metis derivation looks like:

\begin{verbatim}
  fof(premise, axiom, (p ⇒ q) ∧ (q ⇒ p)).
  fof(goal, conjecture, (p ∨ q) ⇒ (p ∧ q)).
  fof(s₀, (p ∨ q) ⇒ p, inf(strip, goal)).
  fof(s₁, ((p ∨ q) ∧ p) ⇒ q, inf(strip, goal)).
  fof(neg₀, ¬ ((p ∨ q) ⇒ p), inf(negate, s₀)).
  fof(n₀₀, (¬ p ∨ q) ∧ (¬ q ∨ p), inf(canonicalize, premise)).
  fof(n₀₁, ¬ q ∨ p, inf(conjunct, n₀₀)).
  fof(n₀₂, ¬ p ∧ (p ∨ q), inf(canonicalize, neg₀)).
  fof(n₀₃, p ∨ q, inf(conjunct, n₀₂)).
  fof(n₀₄, ¬ p, inf(conjunct, n₀₂)).
  fof(n₀₅, q, inf(simplify, [n₀₃, n₀₄])).
  cnf(r₀₀, ¬ q ∨ p, inf(canonicalize, n₀₁)).
  cnf(r₀₁, q, inf(canonicalize, n₀₅)).
  cnf(r₀₂, p, inf(resolve, q, [r₀₁, r₀₀])).
  cnf(r₀₃, ¬ p, inf(canonicalize, n₀₄)).
  cnf(r₀₄, ⊥, inf(resolve, p, [r₀₂, r₀₃])).
  fof(neg₁, ¬ ((p ∨ q) ∧ p) ⇒ q), inf(negate, s₁)).
  fof(n₁₀, ¬ q ∧ p ∧ (p ∨ q), inf(canonicalize, neg₁)).
  fof(n₁₁, (¬ p ∨ q) ∧ (¬ q ∨ p), inf(canonicalize, premise)).
  fof(n₁₂, ¬ p ∨ q, inf(conjunct, n₁₁)).
  fof(n₁₃, ⊥, inf(simplify,[n₁₀, n₁₂])).
  cnf(r₁₀, ⊥, inf(canonicalize, n₁₃)).
\end{verbatim}
% \caption{Customized \Metis \TSTP derivation for the theorem in~\eqref{eq:complete-example-problem}}
% \label{app:customized-metis-complete-example}
% \end{figure}

\subsection{Generating the Agda file}

\begin{table}[!ht]
\caption{\Metis inference rules implemented in \name{agda-metis}.}
  \begin{center}
  {\renewcommand{\arraystretch}{1.6}%
    \begin{tabular}
      {|@{\hspace{2mm}}l@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{2mm}}|}

    \hline
    \textbf{\Metis rule} &\textbf{Theorem number}
     &\textbf{Implementation}
     \\ \hline

      \texttt{strip}
      &\ref{thm:strip}
      &\texttt{strip-thm}
      \\

      \texttt{conjunct}
      &\ref{thm:conjunct}
      &\texttt{conjunct-thm}
      \\

      \texttt{resolve}
      &\ref{thm:resolve}
      &\texttt{resolve-thm}
      \\

      \texttt{canonicalize}
      &\ref{thm:canonicalize}
      &\texttt{canonicalize-thm}
      \\

      \texttt{clausify}
      &\ref{thm:clausify}
      &\texttt{clausify-thm}
      \\

      \texttt{simplify}
      &\ref{thm:simplify}
      &\texttt{simplify-thm}
      \\[1ex]
    \hline
    \end{tabular}}
  \end{center}
\end{table}


To obtain the \Agda proof-term of the \Metis derivation run
the following command:

\begin{verbatim}
  $ athena problem.tstp
\end{verbatim}

The correspondent \Agda file will be created in the same directory
that contains \verb!problem.tstp! using the same name but the
extension of \Agda, that is, \verb!.agda!.


\begin{verbatim}
  $ cat problem.agda
  ------------------------------------------------------------------------------
  -- Athena version 0.1-f54e580.
  -- TSTP file: problem.tstp.
  ------------------------------------------------------------------------------

  module problem where

  ------------------------------------------------------------------------------

  open import ATP.Metis 2 public
  open import Data.PropFormula 2 public

  ------------------------------------------------------------------------------

  -- Variables.

  p : PropFormula
  p = Var (# 0)

  q : PropFormula
  q = Var (# 1)

  -- Axiom.

  a₁ : PropFormula
  a₁ = ((p ⊃ q) ∧ (q ⊃ p))

  -- Premise.

  Γ : Ctxt
  Γ = [ a₁ ]

  -- Conjecture.

  goal : PropFormula
  goal = ((p ∨ q) ⊃ (p ∧ q))

  -- Subgoals.

  subgoal₀ : PropFormula
  subgoal₀ = ((p ∨ q) ⊃ p)

  subgoal₁ : PropFormula
  subgoal₁ = (((p ∨ q) ∧ p) ⊃ q)

  ------------------------------------------------------------------------------
  -- Proof of subgoal₀.
  ------------------------------------------------------------------------------

  proof₀ : Γ ⊢ subgoal₀
  proof₀ =
    (RAA
      (resolve-thm ⊥ p
        (resolve-thm p q
          (simplify-thm q
            (conjunct-thm (p ∨ q)
              (canonicalize-thm ((¬ p) ∧ (p ∨ q))
                (assume {Γ = Γ} (¬ subgoal₀))))
            (conjunct-thm (¬ p)
              (canonicalize-thm ((¬ p) ∧ (p ∨ q))
                (assume {Γ = Γ} (¬ subgoal₀)))))
          (conjunct-thm ((¬ q) ∨ p)
            (canonicalize-thm (((¬ p) ∨ q) ∧ ((¬ q) ∨ p))
              (weaken (¬ subgoal₀)
                (assume {Γ = ∅} a₁)))))
        (conjunct-thm (¬ p)
          (canonicalize-thm ((¬ p) ∧ (p ∨ q))
            (assume {Γ = Γ} (¬ subgoal₀))))))

  ------------------------------------------------------------------------------
  -- Proof of subgoal₁.
  ------------------------------------------------------------------------------

  proof₁ : Γ ⊢ subgoal₁
  proof₁ =
    (RAA
      (simplify-thm ⊥
        (canonicalize-thm ((¬ q) ∧ (p ∧ (p ∨ q)))
          (assume {Γ = Γ} (¬ subgoal₁)))
        (conjunct-thm ((¬ p) ∨ q)
          (canonicalize-thm (((¬ p) ∨ q) ∧ ((¬ q) ∨ p))
            (weaken (¬ subgoal₁)
              (assume {Γ = ∅} a₁))))))

  ------------------------------------------------------------------------------
  -- Proof of the goal.
  ------------------------------------------------------------------------------

  proof : Γ ⊢ goal
  proof =
    ⊃-elim
      strip-thm
      (∧-intro proof₀ proof₁)
  \end{verbatim}

Now, we are ready to verify the \Metis derivation by type-checking with
\Agda the reconstructed proof showed above. Make sure the \Agda version is
 2.5.3.

\begin{verbatim}
  $ agda --version
  Agda version 2.5.3
  $ agda problem.agda
\end{verbatim}

As we can see in the \Agda code showed above, the term \verb!proof!,
the proof-term of the \Metis derivation is referring to the
proof-terms \verb!proof₀! and \verb!proof₁!. Recall, \Metis stripes
the goal into subgoals to prove it. Therefore, these terms are the
proof-terms for the refutations of the subgoals s₀ and s₁. We show
in the following sections the respective natural deduction trees for
these refutations.

\subsection{First refutation tree}

The \TSTP derivation that corresponds with the refutation
tree of the subgoal $s₀$ is the following:

\begin{verbatim}
  fof(premise, axiom, (p ⇒ q) ∧ (q ⇒ p)).
  fof(goal, conjecture, (p ∨ q) ⇒ (p ∧ q)).
  fof(s₀, (p ∨ q) ⇒ p, inf(strip, goal)).
  ...
  fof(neg₀, ¬ ((p ∨ q) ⇒ p), inf(negate, s₀)).
  fof(n₀₀, (¬ p ∨ q) ∧ (¬ q ∨ p), inf(canonicalize, premise)).
  fof(n₀₁, ¬ q ∨ p, inf(conjunct, n₀₀)).
  fof(n₀₂, ¬ p ∧ (p ∨ q), inf(canonicalize, neg₀)).
  fof(n₀₃, p ∨ q, inf(conjunct, n₀₂)).
  fof(n₀₄, ¬ p, inf(conjunct, n₀₂)).
  fof(n₀₅, q, inf(simplify,[n₀₃, n₀₄])).
  cnf(r₀₀, ¬ q ∨ p, inf(canonicalize, n₀₁)).
  cnf(r₀₁, q, inf(canonicalize, n₀₅)).
  cnf(r₀₂, p, inf(resolve, q, [r₀₁, r₀₀])).
  cnf(r₀₃, ¬ p, inf(canonicalize, n₀₄)).
  cnf(r₀₄, ⊥, inf(resolve, p, [r₀₂, r₀₃])).
  ...
\end{verbatim}

The refutation tree is the following:

\begin{center}
\begin{scprooftree}{1}
\AxiomC{$\mathcal{D}_1$}
%\AxiomC{$\mathcal{D}_3$}
\AxiomC{}
\RightLabel{assume $\neg s_0$}
\UnaryInfC{$Γ, \neg s_0 ⊢ \neg s_0$}
% \UnaryInfC{$Γ, \neg s_0 ⊢ (p ∨ q) ⇒ p$}
%\LeftLabel{$(\mathcal{D}_3)$\hspace{1.5cm}}
\RightLabel{Theorem~\ref{thm:canonicalize}}
\UnaryInfC{$Γ, \neg s_0 ⊢ \neg p ∧ (p ∨ q)$}
\RightLabel{Theorem~\ref{thm:conjunct}}
\UnaryInfC{$Γ, \neg s_0 ⊢ \neg p$}
\RightLabel{Theorem~\ref{thm:resolve}~with $ℓ = p$}
\LeftLabel{$(\mathcal{R}_{1})$\hspace{2mm}}
\BinaryInfC{$Γ, \neg s_0 ⊢ \bot$}
\RightLabel{RAA.}
\UnaryInfC{$Γ ⊢ s_0$}
\end{scprooftree}
\end{center}
\medskip

\begin{equation*}
\begin{bprooftree}
\AxiomC{$\mathcal{D}_2$}
\UnaryInfC{$Γ, \neg s_0 ⊢ \neg q ∨ p$}

\AxiomC{$\mathcal{D}_3$}
\UnaryInfC{$Γ, \neg s_0 ⊢ p ∨ q$}
%
\AxiomC{$\mathcal{D}_4$}
\UnaryInfC{$Γ, \neg s_0 ⊢ \neg p$}
%
%\LeftLabel{$(\mathcal{D}_4)$\hspace{1.5cm}}
\RightLabel{Theorem~\ref{thm:simplify}}
\BinaryInfC{$Γ, \neg s_0 ⊢ q$}
\LeftLabel{$(\mathcal{D}_1)$\hspace{2mm}}
\RightLabel{Theorem~\ref{thm:resolve}~with $ℓ = q$}
\BinaryInfC{$Γ, \neg s_0 ⊢ p$}
\end{bprooftree}
\end{equation*}

\begin{equation*}
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{axiom premise}
  \UnaryInfC{$Γ ⊢ (p ⇒ q) ∧ (q ⇒ p)$}
  \RightLabel{weaken}
  \UnaryInfC{$Γ, \neg s_0 ⊢ (p ⇒ q) ∧ (q ⇒ p)$}
  \LeftLabel{$(\mathcal{D}_2)$\hspace{2mm}}
  \RightLabel{Theorem~\ref{thm:canonicalize}}
  \UnaryInfC{$Γ, \neg s_0 ⊢ (\neg p ∨ q) ∧ (\neg q ∨ p)$}
  \RightLabel{Theorem~\ref{thm:conjunct}}
  \UnaryInfC{$Γ, \neg s_0 ⊢ \neg q ∨ p$}
\end{bprooftree}
\end{equation*}
\medskip
\begin{equation*}
\begin{bprooftree}
\AxiomC{}
\RightLabel{assume}
\UnaryInfC{$Γ, \neg s_0 ⊢ \neg s_0$}
\LeftLabel{$(\mathcal{D}_3)$\hspace{2mm}}
\RightLabel{Theorem~\ref{thm:canonicalize}}
\UnaryInfC{$Γ, \neg s_0 ⊢ \neg p ∧ (p ∨ q)$}
\RightLabel{Theorem~\ref{thm:conjunct}}
\UnaryInfC{$Γ, \neg s_0 ⊢ p ∨ q$}
\end{bprooftree}
\end{equation*}
\medskip
\begin{equation*}
\begin{bprooftree}
\AxiomC{}
\RightLabel{assume $\neg s_0$}
\UnaryInfC{$Γ, \neg s_0 ⊢ \neg s_0$}
% \UnaryInfC{$Γ, \neg s_0 ⊢ (p ∨ q) ⇒ p$}
\LeftLabel{$(\mathcal{D}_4)$\hspace{2mm}}
\RightLabel{Theorem~\ref{thm:canonicalize}}
\UnaryInfC{$Γ, \neg s_0 ⊢ \neg p ∧ (p ∨ q)$}
\RightLabel{Theorem~\ref{thm:conjunct}}
\UnaryInfC{$Γ, \neg s_0 ⊢ \neg p$}
\end{bprooftree}
\end{equation*}

\subsection{Second refutation tree}

The \TSTP derivation that corresponds with the refutation
tree of the subgoal $s₁$ is the following:

\begin{verbatim}
  fof(premise, axiom, (p ⇒ q) ∧ (q ⇒ p)).
  ...
  fof(s₁, ((p ∨ q) ∧ p) ⇒ q, inf(strip, goal)).
  ...
  fof(neg₁, ¬ (((p ∨ q) ∧ p) ⇒ q), inf(negate, s₁)).
  fof(n₁₀, ¬ q ∧ p ∧ (p ∨ q), inf(canonicalize, neg₁)).
  fof(n₁₁, (¬ p ∨ q) ∧ (¬ q ∨ p), inf(canonicalize, premise)).
  fof(n₁₂, ¬ p ∨ q, inf(conjunct, n₁₁)).
  fof(n₁₃, ⊥, inf(simplify,[n₁₀, n₁₂])).
  cnf(r₁₀, ⊥, inf(canonicalize, n₁₃)).
\end{verbatim}

The refutation tree is the following:

\begin{center}
\begin{scprooftree}{0.95}
\AxiomC{}
\RightLabel{assume ($\neg s₁)$}
\UnaryInfC{$Γ,\neg s₁ ⊢ \neg s₁$}
\RightLabel{Theorem~\ref{thm:canonicalize}}
\UnaryInfC{$Γ, \neg s₁⊢ \neg q ∧ p ∧ (p ∨ q)$}
\AxiomC{}
\RightLabel{axiom premise}
\UnaryInfC{$Γ ⊢ (p ⇒ q) ∧ (q ⇒ p)$}
\RightLabel{weaken}
\UnaryInfC{$Γ, \neg s₁ ⊢ (p ⇒ q) ∧ (q ⇒ p)$}
\RightLabel{Theorem~\ref{thm:canonicalize}}
\UnaryInfC{$Γ, \neg s₁ ⊢ (\neg p ∨ q) ∧ (\neg q ∨ p)$}
\RightLabel{Theorem~\ref{thm:conjunct}}
\UnaryInfC{$Γ, \neg s₁ ⊢ \neg p ∨ q$}
\LeftLabel{$(\mathcal{R}_{2})$\hspace{1mm}}
\RightLabel{Theorem~\ref{thm:simplify}}
\BinaryInfC{$Γ, \neg s₁ ⊢ \bot$}
\RightLabel{RAA.}
\UnaryInfC{$Γ ⊢ s₁$}
\end{scprooftree}
\end{center}

\subsection{The proof of the goal}

\begin{center}
\begin{scprooftree}{1}
\AxiomC{}
\RightLabel{Theorem~\ref{thm:strip}}
\UnaryInfC{$Γ ⊢ (s_0 ∧ s₁) ⇒ \text{goal}$}
\AxiomC{$\mathcal{R}_{1}$}
\UnaryInfC{$Γ ⊢ s_0$}
\AxiomC{$\mathcal{R}_2$}
\UnaryInfC{$Γ ⊢ s₁$}
\RightLabel{$\wedge$-intro}
\BinaryInfC{$Γ ⊢ s_0 ∧ s₁$}
\RightLabel{$⇒$-elim}
\BinaryInfC{$Γ ⊢ \text{goal}$}
\end{scprooftree}
\end{center}

\end{subappendices}

\end{document}
