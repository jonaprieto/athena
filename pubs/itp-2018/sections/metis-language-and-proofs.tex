%
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

% \begin{myremark}
% We address proof-reconstruction in this paper for refutation proofs.
% We annotate \abbre{CPL} problems using \verb!fof! formulas that
% \Metis converts to \abbre{CNF} clauses to look for a refutation.
% \end{myremark}


\section{Metis Prover}
\label{sec:metis-language-and-proofs}

\Metis is an automatic theorem prover for first-order logic with
equality developed by Hurd~\cite{hurd2003first}. This prover is
suitable for proof-reconstruction since it provides well-documented
proofs to justify its deduction steps from the basis of only six
inference rules for first-order logic (see, for example,
\cite{paulson2007source,Farber2015}). For the propositional fragment,
\Metis has three inference rules, see Fig.~\ref{fig:metis-inferences}.

\begin{figure}
\begin{equation*}
  \begin{bprooftree}
    \AxiomC{}
    \RightLabel{axiom~$φ₁,\cdots,φₙ$}
    \UnaryInfC{$Γ ⊢ φ₁ ∨ \cdots ∨ φₙ$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{}
    \RightLabel{assume $φ$}
    \UnaryInfC{$Γ ⊢ φ ∨ ¬ φ$}
  \end{bprooftree}
  \end{equation*}
  \vskip2mm
  \begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ℓ ∨ φ$}
    \AxiomC{$Γ ⊢ ¬ ℓ ∨ ψ$}
    \RightLabel{resolve $ℓ$}
    \BinaryInfC{$Γ ⊢ φ ∨ ψ$}
  \end{bprooftree}
\end{equation*}
\caption{\Metis inference rules for propositional logic.}
\label{fig:metis-inferences}
\end{figure}

% -------------------------------------------------------------------

\subsection{Input language}
\label{ssec:input-language}

The \TPTP language is the input language to encode problems used by \Metis.
It includes the first-order form (denoted by \name{fof}) and clause normal
form (denoted by \name{cnf}) formats~\cite{sutcliffe2009}.
The \TPTP syntax\footnote{See the complete syntax grammar
at \url{http://www.cs.miami.edu/~tptp/TPTP/SyntaxBNF.html}} is a
well-defined grammar to handle annotated formulas with the form:
\begin{verbatim}
  language(name, role, formula).
\end{verbatim}
where the \name{language} can be \name{fof} or \name{cnf} and the \name{name} serves
to identify the formula within the problem. Each
annotated formula also assumes a \name{role}. Some roles frequently used are \name{axiom},
\name{conjecture}, \name{definition}, \name{plain} and \name{hypothesis}. The reader
can find the complete list in~\cite{sutcliffe2009}.

In the last field of the annotated formula we found the \texttt{formula},
a well-written expression using the
the constants \verb!$true! and \verb!$false!, the negation unary
operator~(\verb!~!), and the binary connectives
(\verb!&!, \verb!|!, \verb!=>!) that represent
($⊤$, $⊥$, $¬$, $∧$, $∨$, $⇒$) respectively.
To refer us to propositional variables, we can use words composing by letters and numbers.
%http://www.cs.miami.edu/~tptp/TPTP/SyntaxBNF.html#atomic_word


\subsection{Output language}
\label{ssec:output-language}

The \TSTP language is an output language for derivations used by
\Metis and other ATPs~\cite{Sutcliffe-Schulz-Claessen-VanGelder-2006}.
A \TSTP  derivation generated by \Metis encodes a natural
deduction proof using only as valid deduction steps the inference rules
in Fig.~\ref{tab:agda-metis-table}.
These derivations are directed acyclic graphs, trees of refutations.
Each node stands for an application of an inference rule to the formulas
in the parent nodes. The leaves in the tree represent formulas in the given
\TPTP input. Each node is labeled with a name of its inference rule (\eg, \canonicalize).
Each edge in the tree links a premise with one conclusion.

Since \Metis attempts to prove conjectures by refutation, and the root
is the final derived formula in these proof trees,  we have at their
roots the conclusion $⊥$. Such derivations are a list of annotated
formulas with the form:

\begin{verbatim}
  language(name, role, formula, source [,useful info]).
\end{verbatim}

The new field regarding the \TPTP syntax is the \name{source} field
that mainly intends to record the inference rule of the deduction step.
This field has the pattern

\begin{verbatim}
  inference(rule, useful info, parents).
\end{verbatim}

where the \name{rule} is the inference name, the next field
includes supporting arguments to apply the reasoning step, and the
last field is a list of the parents nodes.

For increasing the readability of this paper, we are not presenting
these \TSTP derivations using the above description. Instead of it, we
have adopted a customized \TSTP syntax to keep as short as possible
the \Metis derivations. For instance,  we shortened some keywords,
removed unnecessary arguments, and replaced some symbols.
The complete description of these customizations are showed in Appendix~\ref{app:tstp-syntax}.

\begin{myexamplenum}
\label{fig:metis-example-tree}
We show in Fig.~\ref{complete-metis-example} the customized version
of the \Metis derivation of the theorem~\eqref{eq:complete-example-problem}.
This derivation will be used in Section~\ref{sec:proof-reconstruction} to
present the proof-reconstruction process.

\begin{equation}
\label{eq:complete-example-problem}
(p \Rightarrow q) \wedge (q \Rightarrow p) ⊢ (p \vee q) \Rightarrow (p \wedge q)
\end{equation}

\begin{figure}
\begin{Verbatim}[commandchars=\\\{\}, numbers=left,xleftmargin=5mm]
fof(premise, axiom, (p ⇒ q) ∧ (q ⇒ p)).  \label{line1}
fof(goal, conjecture, (p ∨ q) ⇒ (p ∧ q)).  \label{line2}
fof(s₀, (p ∨ q) ⇒ p, inf(strip, goal)).  \label{line3}
fof(s₁, ((p ∨ q) ∧ p) ⇒ q, inf(strip, goal)).  \label{line4}
fof(neg₀, ¬ ((p ∨ q) ⇒ p), inf(negate, s₀)).  \label{line5}
fof(n₀₀, (¬ p ∨ q) ∧ (¬ q ∨ p), inf(canonicalize, premise)).  \label{line6}
fof(n₀₁, ¬ q ∨ p, inf(conjunct, n₀₀)).  \label{line7}
fof(n₀₂, ¬ p ∧ (p ∨ q), inf(canonicalize, neg₀)).  \label{line8}
fof(n₀₃, p ∨ q, inf(conjunct, n₀₂)).  \label{line9}
fof(n₀₄, ¬ p, inf(conjunct, n₀₂)).  \label{line10}
fof(n₀₅, q, inf(simplify, [n₀₃, n₀₄])).  \label{line11}
cnf(r₀₀, ¬ q ∨ p, inf(canonicalize, n₀₁)).  \label{line12}
cnf(r₀₁, q, inf(canonicalize, n₀₅)).  \label{line13}
cnf(r₀₂, p, inf(resolve, q, [r₀₁, r₀₀])).  \label{line14}
cnf(r₀₃, ¬ p, inf(canonicalize, n₀₄)).  \label{line15}
cnf(r₀₄, ⊥, inf(resolve, p, [r₀₂, r₀₃])).  \label{line16}
fof(neg₁, ¬ ((p ∨ q) ∧ p) ⇒ q, inf(negate, s₁)).  \label{line17}
fof(n₁₀, ¬ q ∧ p ∧ (p ∨ q), inf(canonicalize, neg₁)).  \label{line18}
fof(n₁₁, (¬ p ∨ q) ∧ (¬ q ∨ p), inf(canonicalize, premise)).  \label{line19}
fof(n₁₂, ¬ p ∨ q, inf(conjunct, n₁₁)).  \label{line20}
fof(n₁₃, ⊥, inf(simplify,[n₁₀, n₁₂])).  \label{line21}
cnf(r₁₀, ⊥, inf(canonicalize, n₁₃)).  \label{line22}
\end{Verbatim}
\caption{Customized \Metis \TSTP derivation of the theorem in~\eqref{eq:complete-example-problem}.}
\label{complete-metis-example}
\end{figure}

\end{myexamplenum}


% -------------------------------------------------------------------

\subsection{Inference rules}
\label{ssec:metis-inferences-rules}

We present the list of inference rules used by \Metis in the \TSTP derivations
for propositional logic in Table~\ref{tab:agda-metis-table}. We reconstruct
these rules in Section~\ref{sec:proof-reconstruction} following the same order
of this table.

In this table, \strip is the first inference rule since is the first
one in appearing in the \TSTP derivations. The other rules are sorted
by a mix between their level of complexity of their main purpose and
their dependency with the reconstruction of other rules. For
instance, the \simplify rule and the \clausify rule need theorems
developed for the reconstruction of the \canonicalize rule. The
\canonicalize rule depends on the \resolve reconstruction which
depends on the reconstruction of the \conjunct rule.

An alert reader could also notice that the inference rules presented in
Fig.~\ref{fig:metis-inferences} diverge from the rules in
aforementioned table. The former rules are implemented by the latter
rules in the \TSTP derivations. For instance, as far as we know, in
\TSTP derivations,  the \emph{axiom} rule is implemented by the rules
\canonicalize, \clausify, \conjunct, and \simplify.

% \Metis looks for a refutation to prove \verb!fof! problems.
% A \verb!fof! problem contains the conjecture, the \emph{goal}, in the
% problem. This goal is stripped into subgoals by using the \strip rule. The
% subgoals are the conjuncts in a general conjunction that is equivalent to the
% aforementioned goal.
% Therefore, to prove the goal, \Metis proves independently each subgoal since
% they tend to be less complex or even fewer propositions. At the end, the
% conjunction of all subgoal proofs must prove the goal. Nevertheless, this last
% reasoning is not explicit neither in the \TSTP derivations nor in the
% documentation available about \Metis.
% Since \Metis replies refutation proofs, to prove each subgoal, in the \TSTP
% derivation, the inference rule \negate introduces the negation of such
% subgoals. The \negate rule is a specification of the \emph{assume} rule.

\begin{table}[!ht]

\caption{\Metis inference rules.}
  \begin{center}
  {\renewcommand{\arraystretch}{1.6}%
    \label{tab:agda-metis-table}
    \begin{tabular}{|@{\hspace{2mm}}l@{\hspace{4mm}}l@{\hspace{2mm}}c@{\hspace{2mm}}|}
    \hline
    \textbf{Rule} & \textbf{Purpose} &\textbf{Theorem number}\\ \hline

      \texttt{strip}
      &Strip a goal into subgoals
      &\ref{thm:strip}
      \\

      \texttt{conjunct}
      &Takes a formula from a conjunction
      &\ref{thm:conjunct}
      \\

      \texttt{resolve}
      &A general form of the resolution theorem
      &\ref{thm:resolve}
      \\

      \texttt{canonicalize}
      &Normalization of the formula
      &\ref{thm:canonicalize}
      \\

      \texttt{clausify}
      &Performs clausification
      &\ref{thm:clausify}
      \\

      \texttt{simplify}
      &Simplify definitions and theorems
      &\ref{thm:simplify}
      \\[1ex]
    \hline
    \end{tabular}}
  \end{center}
\end{table}

\end{document}
