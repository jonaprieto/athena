
\documentclass[runningheads,a4paper]{llncs}

\usepackage{bussproofs}
\newenvironment{bprooftree}
  {\leavevmode\hbox\bgroup}
  {\DisplayProof\egroup}


\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{multicol}

\usepackage{url}
\urldef{\mailsc}\path|{jprieto9, asr}@eafit.edu.co|
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

% --------------------------------------------------------------------------
% Tikz Configuration
% --------------------------------------------------------------------------
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows}
\usetikzlibrary{automata}
\usetikzlibrary{calc}
\usepackage{rotating}

\tikzset{
    hyperlink node/.style={
        alias=sourcenode,
        append after command={
            let     \p1 = (sourcenode.north west),
                \p2=(sourcenode.south east),
                \n1={\x2-\x1},
                \n2={\y1-\y2} in
            node [inner sep=0pt, outer sep=0pt,anchor=north west,at=(\p1)]
            {\hyperlink{#1}{\XeTeXLinkBox{\phantom{\rule{\n1}{\n2}}}}}
                    %xelatex needs \XeTeXLinkBox, won't create a link unless it
                    %finds text --- rules don't work without \XeTeXLinkBox.
                    %Still builds correctly with pdflatex and lualatex
        }
    }
}

\tikzstyle{vertex}=[auto=left,circle,fill=black!25,minimum size=5pt,inner sep=0pt]

% --------------------------------------------------------------------------
% Minted Configuration
% --------------------------------------------------------------------------
%% \usepackage{minted}
%% \setminted[cagda]{
%% , fontsize  = \footnotesize
%% , frame     = none
%% % , framerule = 0.4pt
%% % , framesep  = 0pt
%% , style     = cagda
%% }

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Towards Proof-Reconstruction of Problems in Classical Propositional Logic
in Agda}

% a short form should be given in case it is too long for the running head
\titlerunning{Towards Proof-Reconstruction of Problems in Classical
  Propositional Logic in Agda}

\author{Jonathan Prieto-Cubides%
\and Andr\'es Sicard-Ram\'irez}
%
\authorrunning{Proof-Reconstruction in Classical Propositional Logic}

\institute{EAFIT University, School of Sciences and Engineering,\\
Medell\'in, Colombia\\
\mailsc}

% \toctitle{Lecture Notes in Computer Science}
% \tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
...
\keywords{Proof reconstruction, Agda, Automatic theorem prover, Classical Propositional Logic, Metis }
\end{abstract}

\section{Introduction}
Proof reconstruction is a hard labor, it integrates two
complex systems. On one hand, we have the automatic theorem provers (henceforth
ATPs) that depending on the specification logic and background theories exist
many alternatives. They are SAT solvers (e.g. \verb!zChaff!~\cite{Moskewicz2001} and \verb!MiniSat!~\cite{Een2004}) to prove unsatisfiability of CNF formulas,
QBF solvers (e.g. \verb!GhostQ!~\cite{Klieber2014} and~\verb!DepQBF!~\cite{Lonsing2017}) to prove satisfiability and invalidity of quantified Boolean
formulas, SMT solvers (e.g \verb!CVC4!~\cite{Barrett2011}, \verb!veriT!~\cite{bouton2009}, and \verb!Z3!~\cite{DeMoura2008}) to
prove unsatisfiability of formulas from first-order logic with theories,  and
finally, the ATPs to prove validity of formulas from first-order logic with
equality (e.g. \verb!E!~\cite{Schulz:AICOM-2002},~\verb!Gandalf!~\cite{Tammet1997},~\verb!leanCoP!~\cite{Otten2008},~\verb!Metis!~\cite{hurd2003first},~\verb!SPASS!~\cite{Weidenbach2009} and ~\verb!Vampire!~\cite{Riazanov1999}),
high-order logic (e.g. \verb!Leo-II!~\cite{Benzmuller2008} and \verb!Satallax!~\cite{Brown2012}), intuitonistic logic
(e.g. \verb!ileanCoP!~\cite{Otten2008},~\verb!JProver!~\cite{Schmitt2001}, and \verb!Gandalf!~\cite{Tammet1997}), among others.

For proof reconstruction, we need from the ATP tools proof objects in a consistent format to work with, that is, a full script describing
step-by-step the table of the derivation to get the actual proof. Unfortunately,
not all ATPs can deliver proofs or some useful output for reconstruct a proof.
For problems in classical propositional logic (henceforth CPL), from a list of
at least forty\footnote{ATPs available in the website  \texttt{SystemOnTPTP} from the TPTP World} ATPs, just a few were able to deliver proofs (e.g.
\verb!CVC4!~\cite{Barrett2011}, \verb!SPASS!, and
\verb!Waldmeister!~\cite{hillenbrand1997}) and a little bit less generate proofs in a file
format like TSTP~\cite{sutcliffe2004tstp} (e.g. \verb!E!~\cite{Schulz:AICOM-2002}, \verb!Metis!~\cite{hurd2003first}, \verb!Vampire!, and \verb!Z3!) or LFSC~\cite{Stump2008}.

On the other hand, we have the proof checkers, Interactive Theorem Provers
%(henceforth ITP)
or proof assistants (e.g. \verb!Agda!~\cite{agdateam}, \verb!Coq!~\cite{coqteam}, \verb!Isabelle!~\cite{paulson1994isabelle}, \verb!HOL4!~\cite{norrish2007hol}). These programs allow us to define the formal language for the problems like operators, logic variables, axioms, and theorems. They can assist us to check and validate the proof script delivered by the provers. Because the formalism in the source (the proof generated by the ATP) is not necessarily the same formalism in the target (proof reconstructed in the proof assistant), the reconstruction of a proof involves a deep understanding around the deduction process done by the ATP, for translating that deduction later into the proof assistant, the so called ``reverse engineering''.

Many approaches have been proposed and some tools have been implemented for proof reconstruction in the last decades, we mention some of them in the following.

\subsection*{Related Work.}\label{Related Work}
\par
\verb!Sledgehammer! is a tool for \verb!Isabelle! proof
assistant~\cite{paulson1994isabelle} that provides a full integration of
automatic theorem provers including ATPs (see, for example,
\cite{meng2006automation}, ~\cite{blanchette2013extending} and \cite{Fleury2014}) and SMT solvers (see, for
example,~\cite{blanchette2013extending},~\cite{bohme2010} and \cite{Fleury2014}) with \verb!Isabelle/HOL!~\cite{nipkow2002isabelle}, the specialization of \verb!Isabelle! for Higher-Order Logic.

\verb!Waldmeister! is an automatic theorem prover for Unit Equational Logic \cite{hillenbrand1997}. Foster and Struth \cite{foster2011integrating} integrate \verb!Waldmeister! into \verb!Agda!~\cite{agdateam}. This integration requires a proof reconstruction step but authors' approach is restricted to Pure Equational Logic --also called Identity Theory \cite{humberstone2011}-- that is, First-Order Logic with Equality but no other predicate symbols and no functions symbols \cite{appel1959}.

An integration between SMT Solvers and \verb!Agda! in \cite{kanso2016light} use a \emph{oracle and reflection} approach to give certificates for propositional problems.

\verb!SMTCoq! (see \cite{armand2011} and \cite{Ekici2017} for more details) is a tool for the \verb!Coq! proof assistant \cite{coqteam} which provides a certified checker for proof witness coming from the SMT solver \verb!veriT! \cite{bouton2009} and adds a new tactic named verit, that calls \verb!veriT! on any \verb!Coq! goal.

Given a fixed but arbitrary First-Order signature, in \cite{bezem2002automated} transform a proof produced by the first-order automatic theorem prover \verb!Bliksem! \cite{deNivelle2003} in a \verb!Coq! proof term.

We structure the paper as follows. In section \ref{sec2}, we briefly introduce the \verb!Metis! Prover. In section \ref{secproofrecon}, we present our approach to reconstruct proofs deliver by \verb!Metis! in \verb!Agda!. In section 4, we present a complete example of a proof reconstructed with our tool for a CPL problem. In section \ref{secconclusion}, we discuss some limitations and conclusions, for ending up with the future work.

\section{Metis: Language and Proof Terms}\label{sec2}
\verb!Metis! is an automatic theorem prover for First-order Logic with Equality~\cite{hurd2003first}.

\subsection{Input and Output Language}
The \verb!TPTP! language --which includes the First-Order Form (FOF) and Clause Normal Form (CNF) formats \cite{sutcliffe2009} -- is de facto input standard language and the \verb!TSTP! language is de facto output standard language~\cite{sutcliffe2004tstp}.

\subsection{Proof Terms}

\verb!Metis!' proof terms encode natural deduction proofs. Its deduction system uses six simple inference rules and it proves conjectures by refutation.

\[
\begin{bprooftree}
\AxiomC{}
\RightLabel{axiom}
\UnaryInfC{$C$}
\end{bprooftree}
\qquad
\begin{bprooftree}
\AxiomC{}
\RightLabel{assume $L$}
\UnaryInfC{$L \vee \neg L$}
\end{bprooftree}
\qquad
\begin{bprooftree}
\AxiomC{}
\RightLabel{refl $t$}
\UnaryInfC{$t = t$}
\end{bprooftree}
\qquad
\begin{bprooftree}
\AxiomC{$C$}
\RightLabel{subst $\sigma$}
\UnaryInfC{$\sigma\,C$}
\end{bprooftree}
\qquad
\]

\[
\begin{bprooftree}
\AxiomC{}
\RightLabel{equality $L$ $p$ $t$}
\UnaryInfC{$\neg (L[p] = t) \vee \neg L \vee L[ p \mapsto t]$}
\end{bprooftree}
\qquad
\begin{bprooftree}
\AxiomC{$L \vee C$}
\AxiomC{$\neg L \vee D$}
\RightLabel{resolve $L$}
\BinaryInfC{$C \vee D$}
\end{bprooftree}
\]

Metis’ proofs are directed acyclic graphs (henceforth DAG), refutations trees. Each node stands for an application of an inference rule and the leaves in the tree represent formulas in the given problem. Each node is labeled with an axiom or an inference rule name (e.g. \verb!resolve!). Each edge links a premise with one conclusion. All proof graphs have in their root the conclusion ⊥ si
nce Metis uses refutation in each deduction step.


\subsection{Proof Rules}
Using \verb!Metis! to prove CPL problems, we found that their TSTP derivations showed six inference rules, \verb!canonicalize!, \verb!conjunct!, \verb!negate!, \verb!simplify!,  \verb!strip! and \verb!resolve!.

The \verb!canonicalize! rule transforms a formula to one of its normal form, CNF, NNF, and DNF.
This rule also performs simple simplification in the process, applying for instance some of the following theorems assuming commutative properties.

\[
\begin{bprooftree}
  \AxiomC{$P \vee \bot$}
  \UnaryInfC{$P$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$P \vee \top$}
\UnaryInfC{$P$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$P \vee \neg P$}
\UnaryInfC{$\top$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$P \wedge \bot$}
  \UnaryInfC{$\bot$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$P \wedge \top$}
  \UnaryInfC{$P$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$P \wedge \neg P$}
  \UnaryInfC{$\bot$}
\end{bprooftree}
\]

The \verb!strip! rule extracts a subgoal from a goal. The splitting process
takes a goal and recursively recolects all hypotesis required in order to prove the goal.
At the end, the final hypotesis represent the subgoals.




\section{Proof Reconstruction in Agda}
\label{secproofrecon}
As a proof checker, we choose the proof-assistant Agda without a clear reason in mind
rather than its syntax language shares similarity with Haskell, the programming language
of our proof-reconstruction tool, Athena.



\subsection{LCF-Style Theorem Proving}

\subsection{The Translation Method}
\subsection{Reconstruction Work-flow}
Explain in a diagram like we did in the slides for the AIM ...

\subsection{Emulation of Inference Rules in Agda}


% \subsection{Limitations}
%

% \section{Experimental Results}
% We could be able to reconstruct 88 problems in CPL.


\subsection{Implementation}
...
\subsection{Examples}
...


\section{Conclusions}
\label{secconclusion}
\verb!simplify! and \verb!canonicalize! coverage.
Proof-reconstruction can be done in Agda from the Metis' proofs.
...

\subsubsection*{Future Work.}
First-Order Logic support.

\subsubsection*{Acknowledgments.}
We thank EAFIT University in Medell\'in, Colombia for funding support.

\bibliographystyle{splncs03}
\bibliography{ref}

\end{document}
