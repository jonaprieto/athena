
\documentclass[runningheads,a4paper]{llncs}

\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{array}
\usepackage{bussproofs}
\newenvironment{bprooftree}
  {\leavevmode\hbox\bgroup}
  {\DisplayProof\egroup}

% --------------------------------------------------------------------------
% Tikz Configuration
% --------------------------------------------------------------------------
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows}
\usetikzlibrary{automata}
\usetikzlibrary{calc}
\usepackage{rotating}

\tikzset{
    hyperlink node/.style={
        alias=sourcenode,
        append after command={
            let     \p1 = (sourcenode.north west),
                \p2=(sourcenode.south east),
                \n1={\x2-\x1},
                \n2={\y1-\y2} in
            node [inner sep=0pt, outer sep=0pt,anchor=north west,at=(\p1)]
            {\hyperlink{#1}{\XeTeXLinkBox{\phantom{\rule{\n1}{\n2}}}}}
                    %xelatex needs \XeTeXLinkBox, won't create a link unless it
                    %finds text --- rules don't work without \XeTeXLinkBox.
                    %Still builds correctly with pdflatex and lualatex
        }
    }
}

\tikzstyle{vertex}=[auto=left,circle,fill=black!25,minimum size=5pt,inner sep=0pt]

%\usepackage[utf8]{inputenc}
\usepackage{ucs}
\usepackage{autofe}
\usepackage{afterpage}
\usepackage{comment}
\usepackage{url}
%\usepackage{times}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{color}
\usepackage{verbatim}
\usepackage{fancyvrb}

\DefineVerbatimEnvironment
  {code}{Verbatim}
  {} % {fontfamily=\tt} %freemodo

\setcounter{secnumdepth}{5}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%

%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
\ReadOnlyOnce{agda.fmt}%


\RequirePackage[T1]{fontenc}
\RequirePackage[utf8x]{inputenc}
\RequirePackage{ucs}
\RequirePackage{amsfonts}

\providecommand\mathbbm{\mathbb}

% TODO: Define more of these ...
\DeclareUnicodeCharacter{737}{\textsuperscript{l}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{8759}{::}
\DeclareUnicodeCharacter{9669}{\ensuremath{\triangleleft}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{\scriptscriptstyle ?}{=}}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rrbracket}}

% TODO: This is in general not a good idea.
\providecommand\textepsilon{$\epsilon$}
\providecommand\textmu{$\mu$}


%Actually, varsyms should not occur in Agda output.

% TODO: Make this configurable. IMHO, italics doesn't work well
% for Agda code.

\renewcommand\Varid[1]{\mathord{\textsf{#1}}}
\let\Conid\Varid
\newcommand\Keyword[1]{\textsf{\textbf{#1}}}
\EndFmtInput










%%format : = "\in"




\renewcommand*\rmdefault{cmr}

\usepackage{url}
% \urldef{\mailsc}\path|{jprieto9, asr}@eafit.edu.co|
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Towards Proof-Reconstruction of Problems in Classical Propositional Logic
in Agda}

% a short form should be given in case it is too long for the running head
\titlerunning{Towards Proof-Reconstruction of Problems in Classical
  Propositional Logic in Agda}

\author{Jonathan Prieto-Cubides%
\and Andr\'es Sicard-Ram\'irez}
%
\authorrunning{Proof-Reconstruction in Classical Propositional Logic}

\institute{EAFIT University, \emph{School of Sciences and Engineering},\\
Medell\'in, Colombia\\
\text{\tt \char123{}jprieto9\char44{}~asr\char125{}\char64{}eafit\char46{}edu\char46{}co}}

% \toctitle{Lecture Notes in Computer Science}
% \tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
...
\keywords{Proof reconstruction, Agda, Automatic theorem prover,
  Classical Propositional Logic, Metis }
\end{abstract}

\section{Introduction}
Proof reconstruction is a hard labor since it depends on the integration of two
complex system. On one hand, we have the automatic theorem provers
(henceforth ATP) and their specification logic. These tools are usually
classified in at least one of the following categories.
A SAT solver (e.g. \text{\tt zChaff}~\cite{Moskewicz2001} and \text{\tt MiniSat}
~\cite{Een2004}) to prove unsatisfiability of CNF formulas, a QBF solver
(e.g. \text{\tt GhostQ}~\cite{Klieber2014} and \text{\tt DepQBF}~\cite{Lonsing2017})
to prove satisfiability and invalidity of quantified Boolean formulas, a SMT
solver (e.g \text{\tt CVC4}~\cite{Barrett2011}, \text{\tt veriT}~\cite{bouton2009}, and
\text{\tt Z3}~\cite{DeMoura2008}) to prove unsatisfiability of formulas from
first-order logic with theories, and a prover for validity of formulas from
first-order logic with equality (e.g. \text{\tt E}~\cite{Schulz:AICOM-2002},
\text{\tt leanCoP}~\cite{Otten2008}, \text{\tt Metis}~\cite{hurd2003first}, \text{\tt SPASS}
~\cite{Weidenbach2009} and \text{\tt Vampire}~\cite{Riazanov1999}), high-order logic
(e.g. \text{\tt Leo\char45{}II}~\cite{Benzmuller2008} and \text{\tt Satallax}~\cite{Brown2012})
or intuitionistic logic (e.g. \text{\tt ileanCoP}~\cite{Otten2008},
\text{\tt JProver}~\cite{Schmitt2001}, and \text{\tt Gandalf}~\cite{Tammet1997}), among others.

On the other hand, we have the proof checkers, interactive theorem provers
(henceforth ITP) or proof assistants (e.g. \text{\tt Agda}~\cite{agdateam},
\text{\tt Coq}~\cite{coqteam}, \text{\tt Isabelle}~\cite{paulson1994isabelle}, and
\text{\tt HOL4}~\cite{norrish2007hol}). The ITP tools provide us the logic framework
to check and validate the reply of the ATPs, since they allow us to define the
formal language for the problems like operators, logic variables, axioms, and
theorems.

A proof reconstruction tool provides such an integration in one direction, the
bridge between ATPs to ITPs. This is mostly a translation of the reply delivered
by the prover into the formalism of the proof assistant.
Because the formalism of the source (the proof generated by the ATP) is not
necessarily the same logic in the target, the reconstruction turns out in a
``reverse engineering'' task. Then, reconstructing a proof involves a deep
understanding of the algorithms in the ATP and the specification logic in the ITP.

What we need from the ATP tools is a proof object in a consistent format to work
with, that is, a full script describing step-by-step with exhaustive details and
without ambiguities, the table of the derivation to get the actual proof.
For problems in classical propositional logic (henceforth CPL), from a list of
at least forty\footnote{ATPs available from the web service \texttt{SystemOnTPTP}
of the TPTP World.} ATPs, just a few provers are able to deliver proofs (e.g.
\text{\tt CVC4}~\cite{Barrett2011}, \text{\tt SPASS}, and \text{\tt Waldmeister}
~\cite{hillenbrand1997}) and a little bit less reply with a proof in a file
format like TSTP~\cite{sutcliffe2004tstp} (e.g. \text{\tt E}, \text{\tt Metis},
\text{\tt Vampire}, and \text{\tt Z3}), LFSC~\cite{Stump2008}, or the SMT-LIB
~\cite{Bohme2011} format.

Many approaches have been proposed and some tools have been implemented for
proof reconstruction in the last decades. These programs are relevant not only
because it helps to spread their usage but they also increase the confidence of
their users about their algorithms and their correctness (see, for example, bugs
in ATPs~\cite{Keller2013}, \cite{Bohme2011}, and \cite{Fleury2014}).
We mention some tools in the following.

\subsection*{Related Work.}\label{Related Work}

\text{\tt Sledgehammer} is a tool for \text{\tt Isabelle} proof assistant
~\cite{paulson1994isabelle} that provides a full integration of automatic
theorem provers including ATPs (see, for example, \cite{meng2006automation},
\cite{blanchette2013extending} and \cite{Fleury2014}) and SMT solvers (see,
for example, \cite{hurlin07practical}, \cite{bohme2010},
\cite{blanchette2013extending}, and \cite{Fleury2014}) with \text{\tt Isabelle\char47{}HOL}
\cite{nipkow2002isabelle}, the specialization of \text{\tt Isabelle} for
higher-order logic. Sultana, Benzm{\"{u}}ller, and Paulson~\cite{Een2004}
integrates \text{\tt Leo\char45{}II} and \text{\tt Satallax}, two theorem provers for high-order
logic with \text{\tt Isabelle\char47{}HOL} proposing a modular proof reconstruction work flow.

\text{\tt SMTCoq}~\cite{armand2011,Ekici2017} is a tool for the \text{\tt Coq} proof
assistant \cite{coqteam} which provides a certified checker for proof witness
coming from the SMT solver \text{\tt veriT} \cite{bouton2009} and adds a new tactic
named verit, that calls \text{\tt veriT} on any \text{\tt Coq} goal.
In \cite{bezem2002automated}, given a fixed but arbitrary first-order signature,
the authors transform a proof produced by the first-order automatic theorem
prover \text{\tt Bliksem} \cite{deNivelle2003} in a \text{\tt Coq} proof term.

Hurd~\cite{Hurd1999} integrates the first-order resolution prover \text{\tt Gandalf}
with \text{\tt HOL}~\cite{norrish2007hol}, a high-order theorem prover, following a
LCF model implementing the tactic \text{\tt GANDALF\char95{}TAC}. The SMT solver \text{\tt CVC4}
was integrated with \text{\tt HOL~Light}, a version of \text{\tt HOL} but with a simpler
logic core. \text{\tt PRocH}~ tool by Kaliszyk and Urban~\cite{kaliszyk2013}
reconstruct proofs from different ATPs to \text{\tt HOL~Light}, replaying the
detailed inference steps from the ATPs with internal inference methods
implemented in the ITP.

\text{\tt Waldmeister} is an automatic theorem prover for unit equational logic
\cite{hillenbrand1997}. Foster and Struth~\cite{foster2011integrating} integrate
\text{\tt Waldmeister} into \text{\tt Agda}~\cite{agdateam}. This integration requires a
proof reconstruction step but authors' approach is restricted to pure equational
logic --also called identity theory~\cite{humberstone2011}-- that is,
first-order logic with equality but no other predicate symbols and no functions
symbols~\cite{appel1959}.

Kanso and Setzer~\cite{kanso2016light} integrate as SAT solvers (\text{\tt iProver},
\text{\tt E}, and \text{\tt Z3}) in \text{\tt Agda} using an approach that they call
\emph{oracle and reflection}.

% replaying the Otter/Prover9 proofs in Mizar, and

In this paper, we describe the integration of \text{\tt Metis} prover with the proof
assistant \text{\tt Agda}. We structure the paper as follows. In section \ref{sec2},
we briefly introduce the \text{\tt Metis} prover. In section \ref{secproofrecon},
we present our approach to reconstruct proofs deliver by \text{\tt Metis} in
\text{\tt Agda}. In section 4, we present a complete example of a proof
reconstructed with our tool for a CPL problem. In section \ref{secconclusion},
we discuss some limitations and conclusions, for ending up with the future work.

\section{Metis: Language and Proof Terms}\label{sec2}
\text{\tt Metis} is an automatic theorem prover for first-order logic with
equality~\cite{hurd2003first}.

\subsection{Input and Output Language}
The \text{\tt TPTP} language --which includes the First-Order Form (FOF) and Clause
Normal Form (CNF) formats \cite{sutcliffe2009} -- is de facto input standard
language and the \text{\tt TSTP} language is de facto output standard
language~\cite{sutcliffe2004tstp}.

\subsection{Proof Terms}

\text{\tt Metis}' proof terms encode natural deduction proofs. Its deduction system
uses six simple inference rules and it proves conjectures by refutation.

\[
\scalebox{0.9}{
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{axiom}
  \UnaryInfC{$C$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{assume $L$}
  \UnaryInfC{$L \vee \neg L$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{refl $t$}
  \UnaryInfC{$t = t$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{$C$}
  \RightLabel{subst $\sigma$}
  \UnaryInfC{$\sigma\,C$}
\end{bprooftree}
\qquad
}
\]
\[
\scalebox{0.9}{
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{equality $L$ $p$ $t$}
  \UnaryInfC{$\neg (L[p] = t) \vee \neg L \vee L[ p \mapsto t]$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{$L \vee C$}
  \AxiomC{$\neg L \vee D$}
  \RightLabel{resolve $L$}
  \BinaryInfC{$C \vee D$}
\end{bprooftree}
}
\]

\text{\tt Metis}’ proofs are directed acyclic graphs (henceforth DAG), refutations
trees. Each node stands for an application of an inference rule and the leaves
in the tree represent formulas in the given problem. Each node is labeled with
an axiom or an inference rule name (e.g. \text{\tt resolve}). Each edge links a
premise with one conclusion. All proof graphs have in their root the conclusion
⊥ since \text{\tt Metis} uses refutation in each deduction step.

\subsection{Proof Rules}
Using \text{\tt Metis} to prove CPL problems, we found that their TSTP derivations
showed six inference rules, \text{\tt canonicalize}, \text{\tt conjunct}, \text{\tt negate},
\text{\tt simplify}, \text{\tt strip} and \text{\tt resolve}.

The \text{\tt canonicalize} rule transforms a formula to one of its normal form,
CNF, NNF, and DNF. This rule also performs simple simplification in the process,
applying for instance some of the following theorems assuming commutative
properties.

\[
\begin{bprooftree}
  \AxiomC{$P \vee \bot$}
  \UnaryInfC{$P$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$P \vee \top$}
  \UnaryInfC{$P$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$P \vee \neg P$}
  \UnaryInfC{$\top$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$P \wedge \bot$}
  \UnaryInfC{$\bot$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$P \wedge \top$}
  \UnaryInfC{$P$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$P \wedge \neg P$}
  \UnaryInfC{$\bot$}
\end{bprooftree}
\]

The \text{\tt strip} rule extracts a subgoal from a goal. The splitting process
takes a goal and recursively recollects all hypothesis required in order to prove the goal.
At the end, the final hypothesis represent the subgoals.

\section{Proof Reconstruction in Agda}
\label{secproofrecon}
As a proof checker, we choose the proof-assistant \text{\tt Agda}.

Such TPTP proofs produced by ATPs on the type-annotated input are the
starting point for the HOL proof reconstruction.

\subsection{LCF-Style Theorem Proving}

The propositional formulas are represented using the \text{\tt Prop} data type.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Prop}\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Var}\;{}\<[20]%
\>[20]{}\mathbin{:}\;\Conid{Fin}\;\Varid{n}\;\rightarrow\;\Conid{Prop}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\top\;{}\<[20]%
\>[20]{}\mathbin{:}\;\Conid{Prop}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\bot\;{}\<[20]%
\>[20]{}\mathbin{:}\;\Conid{Prop}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 ∧\char95 }\;\Varid{\char95 ∨\char95 }\;\Varid{\char95 ⇒\char95 }\;\Varid{\char95 ⇔\char95 }\;{}\<[20]%
\>[20]{}\mathbin{:}\;(\Varid{$\phi$}\;\psi\;\mathbin{:}\;\Conid{Prop})\;\rightarrow\;\Conid{Prop}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{¬\char95 }\;{}\<[20]%
\>[20]{}\mathbin{:}\;(\Varid{$\phi$}\;\mathbin{:}\;\Conid{Prop})\;{}\<[35]%
\>[35]{}\rightarrow\;\Conid{Prop}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The theorems in CPL are represented using an abstract data type to implement
a natural deduction calculus. Theorems represent the \emph{sequents} $\Gamma \vdash \phi$,
where $\Gamma$ is a set of hypothesis --using for the implementation the list data type
from the \text{\tt Agda} standard library version-- and $\phi$ is the
sequent's conclusion.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{43}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Varid{\char95 ⊢\char95 }\;\mathbin{:}\;(\Gamma\;\mathbin{:}\;\Conid{Ctxt})\;(\Varid{$\phi$}\;\mathbin{:}\;\Conid{Prop})\;\rightarrow\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{assume}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\rightarrow\;(\Varid{$\phi$}\;\mathbin{:}\;\Conid{Prop})\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{,}\;\Varid{$\phi$}\;\Varid{⊢}\;\Varid{$\phi$}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{axiom}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\rightarrow\;(\Varid{$\phi$}\;\mathbin{:}\;\Conid{Prop})\;{}\<[43]%
\>[43]{}\rightarrow\;\Varid{$\phi$}\;\Varid{∈}\;\Gamma\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{weaken}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\mskip1.5mu\}\;\rightarrow\;(\psi\;\mathbin{:}\;\Conid{Prop})\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{,}\;\psi\;\Varid{⊢}\;\Varid{$\phi$}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{weaken₂}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\mskip1.5mu\}\;\rightarrow\;(\psi\;\mathbin{:}\;\Conid{Prop})\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\psi\;\Varid{∷}\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{⊤-intro}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\top{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{⊥-elim}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\rightarrow\;(\Varid{$\phi$}\;\mathbin{:}\;\Conid{Prop})\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\bot\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{¬-intro}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\mskip1.5mu\}\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{,}\;\Varid{$\phi$}\;\Varid{⊢}\;\bot\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{¬}\;\Varid{$\phi$}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{¬-elim}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\mskip1.5mu\}\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{¬}\;\Varid{$\phi$}\;\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\bot{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{∧-intro}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\;\psi\mskip1.5mu\}\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;\rightarrow\;\Gamma\;\Varid{⊢}\;\psi\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;\Varid{∧}\;\psi{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{∧-proj₁}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\;\psi\mskip1.5mu\}\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;\Varid{∧}\;\psi\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{∧-proj₂}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\;\psi\mskip1.5mu\}\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;\Varid{∧}\;\psi\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\psi{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{∨-intro₁}\;\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\mskip1.5mu\}\;\rightarrow\;(\psi\;\mathbin{:}\;\Conid{Prop})\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;\Varid{∨}\;\psi{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{∨-intro₂}\;\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \psi\mskip1.5mu\}\;\rightarrow\;(\Varid{$\phi$}\;\mathbin{:}\;\Conid{Prop})\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\psi\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;\Varid{∨}\;\psi{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{∨-elim}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\;\psi\;\chi\mskip1.5mu\}\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{,}\;\Varid{$\phi$}\;\Varid{⊢}\;\chi\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{,}\;\psi\;\Varid{⊢}\;\chi\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{,}\;\Varid{$\phi$}\;\Varid{∨}\;\psi\;\Varid{⊢}\;\chi{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{⇒-intro}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\;\psi\mskip1.5mu\}\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{,}\;\Varid{$\phi$}\;\Varid{⊢}\;\psi\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;\Varid{⇒}\;\psi{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{⇒-elim}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\;\psi\mskip1.5mu\}\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;\Varid{⇒}\;\psi\;\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\psi{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{⇔-intro}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\;\psi\mskip1.5mu\}\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{,}\;\Varid{$\phi$}\;\Varid{⊢}\;\psi\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{,}\;\psi\;\Varid{⊢}\;\Varid{$\phi$}\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;\Varid{⇔}\;\psi{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{⇔-elim₁}\;\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\;\psi\mskip1.5mu\}\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;\Varid{⇔}\;\psi\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\psi{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{⇔-elim₂}\;\mathbin{:}\;\forall{}\;\{\mskip1.5mu \Gamma\mskip1.5mu\}\;\{\mskip1.5mu \Varid{$\phi$}\;\psi\mskip1.5mu\}\;{}\<[43]%
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\psi\;\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}\;\Varid{⇔}\;\psi\;{}\<[E]%
\\
\>[43]{}\rightarrow\;\Gamma\;\Varid{⊢}\;\Varid{$\phi$}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\subsection{The Translation Method}

\subsection{Reconstruction Work-flow}
Explain in a diagram like we did in the slides for the AIM ...

\subsection{Emulation of Inference Rules in Agda}


% \subsection{Limitations}
%

% \section{Experimental Results}
% We could be able to reconstruct 88 problems in CPL.


\subsection{Implementation}
...
\subsection{Examples}
...


\section{Conclusions}
\label{secconclusion}
\text{\tt simplify} and \text{\tt canonicalize} coverage.
Proof-reconstruction can be done in Agda from the Metis' proofs.
...

\subsubsection*{Future Work.}
First-Order Logic support.

\subsubsection*{Acknowledgments.}
We thank EAFIT University of Medell\'in, Colombia for funding support. This is
part of first author's Master thesis in Applied Mathematics, written under the
supervision of Andr\'es Sicard-Ram\'irez for the Logic and Computation Research
Group at the EAFIT University.

We thank Joe Leslie-Hurd for supporting comments about \text{\tt Metis}.
We also acknowledge the work done by Alejandro G\'omez-Londo\~no~
\cite{Gomez-Londono2015} that deserves as the basis code for our parsing module
for TSTP files.
And last but not least, we gratefully acknowledge Andreas Abel and Chalmers
University of Gothenburg, Sweden for inviting us to be part of the Agda
Implementors’ Meeting XXV where we presented part of this paper.

\bibliographystyle{splncs03}
\bibliography{ref}
\addcontentsline{toc}{section}{References}

\end{document}
