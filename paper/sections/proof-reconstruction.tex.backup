\begin{equation}
\label{eq:rconj-def}
\begin{split}
&rconj(φ) =\begin{cases}
ψ₁ ∧ rconj(ψ₂ ∧ φ₂) &\text{if }φ = φ₁ ∧ φ₂\text{, } ψ≡rconj(φ₁),\\
&\text{and }ψ ≡ ψ₁ ∧ ψ₂,\\[3mm]
ψ ∧ rconj(φ₂)  &\text{if }φ = φ₁ ∧ φ₂\text{, } ψ≡rconj(φ₁),\\
φ &\text{otherwise.}
\end{cases}
\end{split}
\end{equation}

\begin{lemma}[thm-rconj] $Γ ⊢ φ$ then $Γ ⊢ rconj(φ)$.
\end{lemma}


\emph{Resolve.}

The \resolve rule is a generalization version for resolution
in propositional logic since the formulas are not shaped always as
the theorem expect (see Fig.~\ref{fig:metis-inferences}).
Since our approach is mere syntactic, in order to apply such a
theorem, we perform rearrangements inside the formulas to match with
the pattern expected by the resolution theorem. If this strategy
fails at some point, we could not check the rest of the proof.

Therefore, the best scenario to apply resolution occurs when the
literal $l$ and its negation appear in the exact place in the
formulas as the resolve inference shows.

\begin{figure}
\[%\scalebox{0.9}{
\begin{bprooftree}
\AxiomC{$Γ ⊢ (φ₁ ≡ l ∨ ψ₁)$}
\AxiomC{$Γ ⊢ (φ₂ ≡ ¬ l ∨ ψ₂)$}
\RightLabel{\thmresolve}
\BinaryInfC{$Γ ⊢ \resolve(φ₁, φ₂, l, (ψ₁ ∧ ψ₂))$}
\UnaryInfC{Γ ⊢ ψ₁ ∨ ψ₂}
\end{bprooftree}
%}
\]
% \caption{Resolution in \Metis.}
\label{fig:thm-resolve-best-case}
\end{figure}

To rearrange the propositions in order to match with a specific
pattern for applying a particular theorem like resolution, we have
define the following functions and provide
its respective theorems in \cite{AgdaMetis}.
These rearrangement functions are mainly inspired in
\cite{bohme2010}, for their treatment for conjunction and
disjunction equivalence.

\improvement{provide examples for each of the following functions.}

\begin{itemize}
  \item \name{reorder-∨.} Given two formulas, φ and ψ, both disjunctions, fix the order of the first one by following the syntactically
  order of the second one. If the process succeed (denote by φ ⤳ ψ),
  returns the target formula, ψ, otherwise, keep the first one, φ.
  \begin{align}
  \begin{split}
&\name{reorder-∨}\ :\ \Prop \to \Prop \to \Prop\\
&\name{reorder-∨}(φ, ψ) =
  \begin{cases}
  ψ   & φ ⤳ ψ\\
  ϕ   & \text{otherwise.}
  \end{cases}
  \end{split}
  \end{align}

  \item \name{reorder-∧.} Given two formulas, φ and ψ, both conjunctions, fix the order of the first one by following the order  of the second one.
  \item \name{reorder-∧∨.} Given two formulas, φ and ψ, both in CNF, fix the order of the first one by following the order  of the second one.
\end{itemize}

\begin{equation}
\resolve((φ₁, φ₂, l, ψ)
\end{equation}

\begin{theorem}[\thmresolve] $Γ ⊢ φ₁$, $Γ ⊢ φ₂$,
then $Γ ⊢ \resolve(φ₁, φ₂, l, ψ)$ where $l$ is a literal,
and ψ is the expected result.
\end{theorem}
\emph{NNF.}
A negative normal form for the formula φ is one in which negations
appear only in the literals and the expression is in terms only of
the boolean operators (¬, ∧, ∨).

To transform a formula φ to its equivalent \abbre{NNF} form, we
apply recursively the following equations. The function type for
\name{nnf} is $\PROP \to \PROP$.

\begin{equation}
\label{eq:nnf-definition}
\nnf(φ) =
\begin{cases}
\nnf(φ₁) ∧ \nnf(φ₂)
   & φ := φ₁ ∧ φ₂, \\

\nnf(φ₁) ∨ \nnf(φ₂)
   & φ := φ₁ ∨ φ₂, \\

\nnf(¬ φ₁ ∨ φ₂)
   & φ := φ₁ ⇒ φ₂, \\

\nnf(φ₁ ⇒ φ₂ ∧ φ₂ ⇒ φ₁)
   & φ := φ₁ ⇔ φ₂, \\

\nnf(¬ φ₁ ∨ ¬ φ₂)
   & φ := ¬ (φ₁ ∧ φ₂), \\

\nnf(¬ φ₁ ∧ ¬ φ₂)
   & φ := ¬ (φ₁ ∨ φ₂), \\

\nnf(φ₁)
   & φ := ¬ ¬ φ₁, \\


\nnf(¬ (φ₂ ∨ ¬ φ₁))
   & φ := ¬ (φ₁ ⇒ φ₂), \\

\nnf(¬ (φ₁ ⇒ φ₂ ∧ φ₂ ⇒ φ₁))
   & φ := ¬ (φ₁ ⇔ φ₂), \\
⊥  & φ := ¬ ⊤, \\
⊤  & φ := ¬ ⊥, \\

φ  & \text{otherwise}.
\end{cases}
\end{equation}

\subsection{The Translation Method}

Our system (see Fig~\ref{fig:proof-reconstruction-overview}) translates a \TSTP file into an \Agda proof by parsing it with a \Haskell tool. This tool reconstructs the proof tree, removing redundancies and cutting unnecessary steps (see for example repetitions in the derivation shown in Fig~\ref{fig:metis-example}). The output is \Agda code. Then, we use \Agda as a proof checker to type-check the proof. If type-checking succeed, then our proof is checked. Else, we have a failure proof due to three possible factors. First, a soundness bug in the ATP or a bug in the output printing. Second, a bug in the translation process in our \TSTP parsing module, the inner algorithms in the analysis of the proof tree, the pretty printer module, or a bug in \Haskell. Lastly, a bug in our proof checker \Agda.

% -------------------------------------------------------------------

\subsection{Rules as Theorems}

Main algorithms in \CPL need the propositions in some of their normal
forms. For instance, from the negative normal form
(henceforth, \abbre{NNF}), we can derive the conjunctive normal form,
and the disjunctive normal form as well.
Therefore, we start giving the definition of \abbre{NNF}, one
function definition, \name{nnf} and a refinement of it.
We will use it later for instance in the description of \canonicalize
rule. The following treatment to this function, \name{nnf},
applies for other conversion functions and theorems defined in
\cite{AgdaProp,AgdaMetis}.
We use the notation convention $:=$ for equivalence between
propositions. The \PROP inductive data type is defined as usual
based on the definition from section \ref{sec:preliminaries} and
implemented in \Agda with \name{PropFormula} in Section
\ref{sec:implementation}.

\subsection{Reconstruction Work-flow}

\begin{figure}
\begin{tikzpicture}
\node[text width=2cm, align=center](problem) at (0,0)
  {CPL \\ Problem};

\node[right = 1.2cm of problem, text width=2cm, align=center]
  (tptp){\TPTP \\ Problem};

\node[right= 1.2cm of tptp, text width=2cm, align=center]
   (metis) {\Metis \\ Prover};

\node[right= 1.2cm of metis, text width=2cm, align=center, inner sep=10pt]
   (tstp) {\TSTP \\ Derivation};

\node[below= 0.5cm of tstp, text width=2cm, align=center, inner sep=10pt]
  (athena) {\Haskell \\ Traslator};

\node[left = 1.2cm of athena, text width=2cm, align=center]
   (agdafile) {\Agda \\ Proof};

\node[left = 1.2cm of agdafile, text width=2cm, align=center]
   (agda) {Proof Checker};

\node[below = 0.5cm of problem, text width=2cm, align=center]
   (verified) {Checked};

\node[below = 0.5cm of verified, text width=2cm, align=center]
   (failure) {Error};

% node[below] {send to}
\draw[->, thick] (problem) to
  % node[below] {\tiny encoding}
  (tptp);
\draw[->, thick] (tptp) to
  % node[below] {\tiny }
  (metis);
\draw[->, thick] (metis) to
  % node[below] {\tiny replies on}
  (tstp);
\draw[->, thick] (tstp) to
  % node[right] {\tiny parsing}
  (athena);
\draw[->, thick] (athena) to
  % node[below] {\tiny traslation}
  (agdafile);
\draw[->, thick] (agdafile) to
  % node[below] {\tiny type-checking}
  (agda);
\draw[->, thick] (agda) to (verified);
\draw[->, thick, gray] (agda) to (failure);
\end{tikzpicture}
\caption{Proof reconstruction overview.}
\label{fig:proof-reconstruction-overview}
\end{figure}

% -------------------------------------------------------------------

\subsection{Proof Cheker}
\label{ssec:agda}\

\Agda is an interactive system for constructing proofs and programs,
based on Martin-L\"{o}f's type theory and extended with records, parametrised
modules, among other features.
One of the main strengths of \Agda is its support for writing proofs,
which we shall call \Agda's proof engine. It consists of: support for
inductively defined types, including inductive families, and function
definitions using pattern matching on such types, normalisation during type-
checking, commands for refining proof terms, coverage checker and termination
checker.
The inductive approach for representing classical propositional logic
is better because we benefit from \Agda's proof engine and its Unicode
support that allows us writing proofs similar as we find in math text books.

% -------------------------------------------------------------------

% \subsection{LCF-Style Theorem Proving}
% \label{ssec:lcf-style-theormem-proving}

% A propositional formula is a experssion of indivisible propositional atoms,
% logical connectives $\{\wedge, \vee, \Rightarrow, \Leftrightarrow, \neg\}$
% and logic constants $\{\top, \bot\}$.
% In \Agda, we define the formula
% as an inductive type using the keyword \texttt{data} and including every
% connective as a constructor. We represent propositional formulas with
% \name{Prop} data type using the following definition.

% %an extension of the syntax definition used in \cite{Altenkirch2015}.

% \begin{verbatim}
% data Prop : Set where
%   Var              : Fin n → Prop
%   ⊤                : Prop
%   ⊥                : Prop
%   _∧_ _∨_ _⇒_ _⇔_  : (φ ψ : Prop) → Prop
%   ¬_               : (φ : Prop)   → Prop
% \end{verbatim}

% On the other hand, we represent theorems in \CPL using an abstract data type
% to implement a natural deduction calculus.

% \begin{verbatim}
% data _⊢_ : (Γ : Ctxt)(φ : Prop) → Set where
% \end{verbatim}

% The sequents  $\Gamma \vdash \phi$ represent theorems,
% where $\Gamma$ is a set of premises and $\phi$ is the
% sequent's conclusion. Strictly speaking, we define the set of premises
% $\Gamma$ with \name{List} data type
% % \footnote{We use the \Agda standard library's implementation of the List data type.}.

% Our\CPLsystem define all inference rules for intuitonistic propositional logic
% (see Fig.~\ref{fig:theorem-constructors}) as constructors of the theorem
% data type, and we postulate the principle of the excluded middle (PEM).

% \begin{verbatim}
% postulate  PEM : ∀ {Γ} {φ} → Γ ⊢ φ ∨ ¬ φ
% \end{verbatim}

% \begin{figure}
% \[%\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{}
% \RightLabel{\scriptsize\tt assume $\varphi$}
% \UnaryInfC{$\Gamma , \varphi \vdash \varphi$}
% \end{bprooftree}\quad
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \varphi$}
% \RightLabel{\scriptsize\tt weaken $\psi$}
% \UnaryInfC{$\Gamma , \psi \vdash \varphi$}
% \end{bprooftree}\quad
% \begin{bprooftree}
% \AxiomC{}
% \RightLabel{\scriptsize\tt $\top$-intro}
% \UnaryInfC{$\Gamma \vdash \top$}
% \end{bprooftree}\quad
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \bot$}
% \RightLabel{\scriptsize\tt $\bot$-elim $\varphi$}
% \UnaryInfC{$\Gamma \vdash \varphi$}
% \end{bprooftree}
% %}
% \]

% \[%\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\Gamma , \varphi \vdash \bot$}
% \RightLabel{\scriptsize\tt $\neg$-intro}
% \UnaryInfC{$\Gamma \vdash \neg \varphi$}
% \end{bprooftree}\quad
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \neg \varphi$}
% \AxiomC{$\Gamma \vdash \varphi$}
% \RightLabel{\scriptsize\tt $\neg$-elim}
% \BinaryInfC{$\Gamma \vdash \bot$}
% \end{bprooftree}\quad
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \varphi$}
% \AxiomC{$\Gamma \vdash \psi$}
% \RightLabel{\scriptsize\tt $\wedge$-intro}
% \BinaryInfC{$\Gamma \vdash \varphi \wedge \psi$}
% \end{bprooftree}
% %}
% \]

% \[%\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \varphi \wedge \psi$}
% \RightLabel{\scriptsize\tt $\wedge$-proj$_1$}
% \UnaryInfC{$\Gamma\vdash \varphi$}
% \end{bprooftree}\quad
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \varphi \wedge \psi$}
% \RightLabel{\scriptsize\tt $\wedge$-proj$_2$}
% \UnaryInfC{$\Gamma\vdash \psi$}
% \end{bprooftree}\quad
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \varphi$}
% \RightLabel{\scriptsize\tt $\vee$-intro$_1$ $\psi$}
% \UnaryInfC{$\Gamma \vdash \varphi \vee \psi$}
% \end{bprooftree}
% %}
% \]

% \[%\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \psi$}
% \RightLabel{\scriptsize\tt $\vee$-intro$_2$ $\varphi$}
% \UnaryInfC{$\Gamma \vdash \varphi \vee \psi$}
% \end{bprooftree}\quad
% \begin{bprooftree}
% \AxiomC{$\Gamma ,\varphi \vdash \gamma $}
% \AxiomC{$\Gamma , \psi  \vdash \gamma$}
% \RightLabel{\scriptsize\tt $\vee$-elim}
% \BinaryInfC{$\Gamma , \varphi \vee \psi \vdash \gamma$}
% \end{bprooftree}\quad
% \begin{bprooftree}
% \AxiomC{$\Gamma , \varphi \vdash \psi$}
% \RightLabel{\scriptsize\tt $\Rightarrow$-intro}
% \UnaryInfC{$\Gamma \vdash \varphi \Rightarrow \psi$}
% \end{bprooftree}
% %}
% \]

% \[
% %\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \varphi \Rightarrow \psi$}
% \AxiomC{$\Gamma \vdash \varphi$}
% \RightLabel{\scriptsize\tt $\Rightarrow$-elim}
% \BinaryInfC{$\Gamma \vdash \psi$}
% \end{bprooftree}\quad
% \begin{bprooftree}
% \AxiomC{$\Gamma , \varphi \vdash \psi$}
% \AxiomC{$\Gamma , \psi \vdash \varphi$}
% \RightLabel{\scriptsize\tt $\Leftrightarrow$-intro}
% \BinaryInfC{$\Gamma \vdash \varphi \Leftrightarrow \psi$}
% \end{bprooftree}
% %}
% \]


% \[
% %\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \varphi$}
% \AxiomC{$\Gamma \vdash \varphi \Leftrightarrow \psi$}
% \RightLabel{\scriptsize\tt $\Leftrightarrow$-elim$_1$}
% \BinaryInfC{$\Gamma \vdash \psi$}
% \end{bprooftree}\quad
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \varphi$}
% \AxiomC{$\Gamma \vdash \varphi \Leftrightarrow \psi$}
% \RightLabel{\scriptsize\tt $\Leftrightarrow$-elim$_2$}
% \BinaryInfC{$\Gamma \vdash \psi$}
% \end{bprooftree}
% %}
% \]

% \caption{Inference rules for\CPLsystem.}
% \label{fig:theorem-constructors}
% \end{figure}

% % -------------------------------------------------------------------


% % -------------------------------------------------------------------

% \subsection{Emulation of Inference Rules in Agda}
% \label{ssec:emulating-inferences}

% \textit{Normalization.}

% \begin{figure}
% \[ \scalebox{0.9}{
% \begin{bprooftree}
%   \AxiomC{$\Gamma \vdash \varphi$}

%   \UnaryInfC{$\Gamma \vdash \texttt{cnf}~\varphi$}
% \end{bprooftree}
% \qquad
% \begin{bprooftree}
%   \AxiomC{$\Gamma \vdash \varphi$}
%   \UnaryInfC{$\Gamma \vdash \texttt{nnf}~\varphi$}
% \end{bprooftree}
% \qquad
% \begin{bprooftree}
%   \AxiomC{$\Gamma \vdash \varphi$}
%   \UnaryInfC{$\Gamma \vdash \texttt{dnf}~\varphi$}
% \end{bprooftree}
% }\]
% \end{figure}

% \begin{figure}
% \[%\scalebox{0.9}{
% \begin{bprooftree}
%   \AxiomC{$\Gamma \vdash \varphi \wedge \bot$}
%   \UnaryInfC{$\Gamma \vdash \bot$}
% \end{bprooftree}
% \begin{bprooftree}
%   \AxiomC{$\Gamma \vdash \varphi \wedge \top$}
%   \UnaryInfC{$\Gamma \vdash \varphi$}
% \end{bprooftree}
% \begin{bprooftree}
%   \AxiomC{$\Gamma \vdash \varphi \wedge \neg \varphi$}
%   \UnaryInfC{$\Gamma \vdash \bot$}
% \end{bprooftree}
% %}
% \]

% \[%\scalebox{0.9}{
% \begin{bprooftree}
%   \AxiomC{$\Gamma \vdash \varphi \vee \bot$}
%   \UnaryInfC{$\Gamma \vdash \varphi$}
% \end{bprooftree}
% \qquad
% \begin{bprooftree}
%   \AxiomC{$\Gamma \vdash \varphi \vee \top$}
%   \UnaryInfC{$\Gamma \vdash \top$}
% \end{bprooftree}
% \qquad
% \begin{bprooftree}
%   \AxiomC{$\Gamma \vdash \varphi \vee \neg \varphi$}
%   \UnaryInfC{$\Gamma \vdash \top$}
% \end{bprooftree}
% %}
% \]
% \end{figure}

% \textit{Resolution.}

% \begin{figure}
% \[%\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\delta_{\phi} := \Gamma \vdash \varphi$}
% \AxiomC{$\delta_{\psi} := \Gamma \vdash \psi$}
% \RightLabel{\texttt{resolve} $p$}
% \BinaryInfC{$\Gamma \vdash$ \texttt{resolve} $\phi\ \psi\ p$}
% \end{bprooftree}
% %}
% \]
% % \caption{Resolution in \Metis.}
% \label{fig:resolution-rule}
% \end{figure}

% \textit{Splitting a conjunct.}
% In the following theorem, we see the definition for the \name{conjunct} rule.
% It extracts the $\varphi_i$ conjunct from the conjunction given by $\varphi$.

% \[\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \varphi := \varphi_1 \wedge \cdots\wedge\varphi_i
% \wedge\cdots\wedge \varphi_n$}
% \AxiomC{$\varphi_i \equiv \psi$}
% \RightLabel{\footnotesize\tt conjunct $\psi$}
% \BinaryInfC{$\Gamma\vdash\varphi_i$}
% \end{bprooftree}
% }
% \]


% \textit{Splitting a goal}


% \begin{figure}
% \[\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \varphi_1 \wedge \varphi_2$}
% \UnaryInfC{$\Gamma \vdash \texttt{unshunt}~(\texttt{split}~\varphi_1) \wedge \texttt{unshunt}~(\varphi_1 \Rightarrow \texttt{split}~\varphi_2)$}
% \end{bprooftree}
% }\]

% \[\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \varphi_1 \vee \varphi_2$}
% \UnaryInfC{$\Gamma \vdash \texttt{unshunt}~(\neg \varphi_1 \Rightarrow \texttt{split}~\varphi_2)$}
% \end{bprooftree}
% }\]

% \[\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \varphi_1 \Rightarrow \varphi_2$}
% \UnaryInfC{$\Gamma \vdash \texttt{unshunt}~(\varphi_1 \Rightarrow \texttt{split}~\varphi_2)$}
% \end{bprooftree}\qquad
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \neg \neg \varphi$}
% \UnaryInfC{$\Gamma \vdash \texttt{unshunt}~(\texttt{split}~\varphi)$}
% \end{bprooftree}
% }\]

% \[\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$ \Gamma \vdash \varphi_1 \Leftrightarrow \varphi_2$}
% \UnaryInfC{$\Gamma\vdash\texttt{unshunt}~(\varphi_1 \Rightarrow \texttt{split}~\varphi_2) \wedge \texttt{unshunt}~(\varphi_2 \Rightarrow \texttt{split}~\varphi_1)$}
% \end{bprooftree}
% }\]

% \[\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \neg \top$}
% \UnaryInfC{$\Gamma \vdash \bot$}
% \end{bprooftree}\qquad
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \neg \bot$}
% \UnaryInfC{$\Gamma \vdash \top$}
% \end{bprooftree}\qquad
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \neg (\varphi_1 \wedge \varphi_2)$}
% \UnaryInfC{$\Gamma \vdash \texttt{unshunt} (\varphi_1 \Rightarrow \texttt{split}~ \neg \varphi_2)$}
% \end{bprooftree}
% }\]

% \[\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \neg (\varphi_1 \vee \varphi_2)$}
% \UnaryInfC{$\Gamma \vdash \texttt{unshunt}~(\texttt{split}~\neg \varphi_1) \wedge  \texttt{unshunt}~(\neg \varphi_1 \Rightarrow \texttt{split}~\neg \varphi_2)$}
% \end{bprooftree}
% }\]

% \[\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \neg (\varphi_1 \Rightarrow \varphi_2)$}
% \UnaryInfC{$\Gamma \vdash \texttt{unshunt}~(\texttt{split}~\varphi_1) \wedge \texttt{unshunt}~(\varphi_1 \Rightarrow \texttt{split}~\neg \varphi_2)$}
% \end{bprooftree}\qquad
% }\]

% \[\scalebox{0.9}{
% \begin{bprooftree}
% \AxiomC{$\Gamma \vdash \neg (\varphi_1 \Leftrightarrow \varphi_2)$}
% \UnaryInfC{$\Gamma \vdash \texttt{unshunt}~(\varphi_1 \Rightarrow \texttt{split}~\neg \varphi_2) \wedge \texttt{unshunt}~(\neg \varphi_2 \Rightarrow \texttt{split}~\varphi_1)$}
% \end{bprooftree}
% }\]
% \caption{Split a goal in an equivalent conjunction of subgoals.}
% \label{split}
% \end{figure}

% In the theorems above appear two recursive functions \texttt{unshunt} and \texttt{split}. They have the following definitions.

% \begin{verbatim}
% unshunt : Prop → Prop
% unshunt (φ₁ ⇒ (φ₂ ⇒ φ₃)) = unshunt ((φ₁ ∧ φ₂) ⇒ φ₃)
% unshunt (φ₁ ⇒ (φ₂ ∧ φ₃)) = unshunt (φ₁ ⇒ φ₂)) ∧ (unshunt(φ₁ ⇒ φ₃)
% unshunt φ                = φ
% \end{verbatim}

% \begin{verbatim}
% split : Prop → Prop
% split (φ₁ ∧ φ₂)     = {!!}
% split (φ₁ ∨ φ₂)     = {!!}
% split (φ₁ ⇒ φ₂)     = {!!}
% split (φ₁ ⇔ φ₂)     = {!!}
% split (¬ ⊤)         = {!!}
% split (¬ ⊥)         = {!!}
% split (¬ (φ₁ ∧ φ₂)) = {!!}
% split (¬ (φ₁ ∨ φ₂)) = {!!}
% split (¬ (φ₁ ⇒ φ₂)) = {!!}
% split (¬ (φ₁ ⇔ φ₂)) = {!!}
% split (¬ (¬ φ))     = {!!}
% split φ₁            = {!!}
% \end{verbatim}

% ...

% \textit{Simplification.}

% \begin{figure}
% \[%\scalebox{0.9}{
% \begin{bprooftree}
%   \AxiomC{$\Gamma \vdash \varphi \Leftrightarrow \psi$}
%   \AxiomC{$\Gamma \vdash \psi$}
%   \RightLabel{\footnotesize\tt $\Leftrightarrow$-elim}
%   \BinaryInfC{$\Gamma \vdash \varphi$}
% \end{bprooftree}
% \begin{bprooftree}
%   \AxiomC{$\Gamma \vdash \varphi \Rightarrow \psi$}
%   \AxiomC{$\Gamma \vdash \varphi$}
%   \RightLabel{\footnotesize\tt $\Rightarrow$-elim}
%   \BinaryInfC{$\Gamma \vdash \psi$}
% \end{bprooftree}
% \]
% \[
% \begin{bprooftree}
%   \AxiomC{$\Gamma \vdash \varphi \vee \neg \psi$}
%   \AxiomC{$\Gamma \vdash \neg \varphi$}
%   \BinaryInfC{$\Gamma \vdash \psi$}
% \end{bprooftree}
% %}
% \]

% \caption{Additional simplification theorems.}
% \label{fig:simplify-rule}
% \end{figure}