\documentclass[../main.tex]{subfiles}
\begin{document}

\section{Limitations of Type Theory}
\label{sec:limitations-type-theory}

% In Section~\label{ssec:structural-recursion},
% we describe how this observation is an issue from the type theory point of
% view. In Section~\ref{ssec:intuitionistic-logic} we mention
% the use intuitionistic-logic and its limitation.

\begin{notation}
We write the type judgments as $m : \abbre{M}$ to denote
that $m$ has $\abbre{M}$ type.
Types are written using small caps.
We use \Prop for the type of propositions and the dependent type, $Γ ⊢ φ$ for
theorems where $Γ : \List~\Prop$ and $φ : \Prop$.
$\abbre{List}$ type is the usual inductive type for lists.
For syntactical equivalence, we write the equality as $φ ≡ ψ$
for $φ,~ψ : \Prop$. For this equality, we assume the
reflexivity, symmetry and transitivity properties.
\end{notation}

% ...................................................................

% section section_name (end)
\subsection{Terminating functions}
\label{ssec:structural-recursion}


To reconstruct \Metis' inference rules in type theory, we observed that
transformations performed by some rules are implemented by \emph{general
recursive} functions.

Algorithms based on general recursions can not be translated
directly in type theory since it is not a guarantee they terminate. For that
reason, we follow the technique described in~\cite{Bertot2004} to avoid
termination problems by modifying the recursive functions to be
\emph{structural recursive}.
% (see \cite{Coquand1992,Abel2002,Bove2005} for more details).

This paper adopts the notion of \emph{structurally smaller} from
\citeauthor{Abel2002}~\cite{Abel2002} to say, a recursive function is
structurally recursive if it calls itself with only
structurally smaller arguments.

General recursive functions can be translated into structurally recursive
functions by using for instance, the \emph{Bounded Recursion} technique
presented in~\cite{Bertot2004}. For a yet another methods, we refer
the reader to \cite{Coquand1992,Abel2002,Bove2005}.
The bounded technique defines a new structural recursive function based on
the general recursive function by adding an argument to the function.
The new argument is the \emph{bound}, a natural number given by the
function complexity. In other words, the added argument will represent
the number of times the function needs to call itself to get the
expected outcome~\cite{Bertot2004}.

\begin{notation}
The type of natural numbers is called \Nat, and it is defined as
usual, where \zero and \suc are its data constructors. We use names
and symbols of the arithmetic operations as usual.
We include syntax sugar for $\zero$, $\suc$, $\suc~\zero$,
$\cdots$, with the decimal representation: $0$, $1$, $2$, $\cdots$
as well.
\end{notation}

Therefore, one approach to guarantee a structural recursive function based on
a general recursive function $\rm{f}:~\Prop~\to~\Prop$ is to formulate a new function $\rm{f}^{*}~:~\Prop~\to~\Nat~\to~\Prop$ where all of its recursive calls are done on smaller arguments.

\begin{myexample}
\label{ex:structural-recursion}

Let us consider the following example to exhibit the bounded technique
mentioned above for the \fuh function. This function is used for reconstructing
the \Metis \strip inference rule in Section~\ref{sssec:strip-a-goal}.

\begin{equation}
\label{eq:uh-definition}
\begin{aligned}
&\hspace{.495mm}\fuh_{0} : \Prop → \Prop\\
&\begin{array}{lll}
  \fuh_{0} &(φ₁ ⇒ (φ₂ ⇒ φ₃)) &= \fuh_{0}~((φ₁ ∧ φ₂) ⇒ φ₃)\\
  \fuh_{0} &(φ₁ ⇒ (φ₂ ∧ φ₃)) &= \fuh_{0}~(φ₁ ⇒ φ₂) ∧ \fuh_{0}~(φ₁ ⇒ φ₃)\\
  \fuh_{0} &φ                &= φ
\end{array}
\end{aligned}
\end{equation}

In~\eqref{eq:uh-definition}, the first two equation
call on arguments no structurally smaller.
For instance, on the first call, $φ ≡ (φ₁ ∧ φ₂) ⇒ φ₃$, the recursion
calls on the  $φ₁ ⇒ (φ₂ ⇒ φ₃)$ argument that is not a subformula of φ.
Therefore, one way to translate $\fuh_{0}$ to type
theory is to define a new function using a bounded recursion.

\begin{equation}
\label{eq:uh-structured}
\begin{aligned}
&\hspace{.495mm} \fuh_{1} : \Prop → \Nat \to \Prop\\
&\begin{array}{llll}
\fuh_{1} &(φ₁ ⇒ (φ₂ ⇒ φ₃)) &(\suc~n) &= \fuh_{1}~((φ₁ ∧ φ₂) ⇒ φ₃)~n\\
\fuh_{1} &(φ₁ ⇒ (φ₂ ∧ φ₃)) &(\suc~n) &= \fuh_{1}~(φ₁ ⇒ φ₂)~n ∧ \fuh_{1}~(φ₁ ⇒ φ₃)~n\\
\fuh_{1} &φ &n &= φ
\end{array}
\end{aligned}
\end{equation}

We bounded the recursion calls in~\eqref{eq:uh-structured} with \Nat type argument. This natural number represents the complexity measure of $\fuh_{0}$
function.

Recall the \emph{complexity measure} defined in \cite{Agudelo-Agudelo2017}
and presented in \cite{VanDalen1994} as \emph{the rank for a
proposition}, is a function $\Prop \to \Nat$ that assigns a natural
number for a proposition $φ$ like the following $\frank$ function.
The symbols $c_{¬}$ and $c_{\square}$ are non-negative integer
numbers called the complexity of the respective connective.


\begin{equation}
% \label{eq:rank-definition}
\begin{aligned}
&\hspace{.495mm}\frank : \Prop → \Nat\\
&\begin{array}{llll}
\frank~(¬~φ)           &= \frank~φ₁~+~c_{¬}\\
\frank~(φ₁~\square~φ₂) &= \fmax~(\frank~φ₁)~(\frank~φ₂) + c_{\square}\\
\frank~φ               &= 0
\end{array}
\end{aligned}
\end{equation}

We define the $\fuh_{cm}: \Prop → \Nat$ function as
the complexity measure for the $\fuh_0$ function.

\begin{equation}
  \label{eq:uh-complexity}
  \begin{aligned}
    &\hspace{.495mm}\fuh_{cm} : \Prop → \Nat\\
    &\begin{array}{llll}
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ⇒ φ₃)) &= \fuh_{cm}~φ₃ + 2\\
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ∧ φ₃)) &= \fmax~(\fuh_{cm}~φ₂)~(\fuh_{cm}~φ₃) + 1\\
    \fuh_{cm}~φ                &= 0
    \end{array}
  \end{aligned}
\end{equation}

Following the technique mentioned above, we get the structural
recursive definition of the $\fuh_{0}$ function presented
in~\eqref{eq:uh}.

\begin{align}
  \label{eq:uh}
  \begin{split}
  &\fuh : \Prop → \Prop\\
  &\fuh~φ~ = \fuh_{1}~φ~(\fuh_{cm}~φ).
  \end{split}
\end{align}

\end{myexample}

For a more complete treatment of general recursion, and how to
define well-founded and well-structural recursive functions, we refer
the reader to \citeauthor{Bove2005}~\cite{Bove2005}.

\subsection{Intuitionistic logic (ESCRIBIENDO)}
\label{ssec:intuitionistic-logic}


We follow the same approach presented in~\cite{Altenkirch2015} to work with propositional
logic in type theory. Therefore, we include
in the constructors for theorems, structural rules and formation rules of
all connectives in Fig.~\ref{fig:CPL-inference-rules}.

Since we pretend to reconstruct proofs replied by \Metis, and \Metis works
in classical logic,  we have included as an axiom, the
principle of excluded third (\abbre{PEM}).

Assuming \abbre{PEM}, we can justify refutation proofs.
We derive the \emph{reductio ad absurdum} rule (\abbre{RAA}) as the
formulation of the principle of proof by contradiction, that is, a derivation
of a contradiction, $⊥$, from the hypothesis $(¬ φ)$, is a
derivation of $φ$.

\begin{figure}
\begin{equation*}
  \begin{bprooftree}
    \AxiomC{}
    \RightLabel{assume}
    \UnaryInfC{$Γ , φ ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{weaken}
    \UnaryInfC{$Γ , ψ ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{}
    \RightLabel{$⊤$-intro}
    \UnaryInfC{$Γ ⊢ ⊤$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ⊥$}
    \RightLabel{$⊥$-elim}
    \UnaryInfC{$Γ ⊢ φ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ ⊥$}
    \RightLabel{$¬$-intro}
    \UnaryInfC{$Γ ⊢ ¬ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ¬ φ$}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{$¬$-elim}
    \BinaryInfC{$Γ ⊢ ⊥$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \AxiomC{$Γ ⊢ ψ$}
    \RightLabel{$\wedge$-intro}
    \BinaryInfC{$Γ ⊢ φ \wedge ψ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ \wedge ψ$}
    \RightLabel{$\wedge$-proj$_1$}
    \UnaryInfC{$Γ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ \wedge ψ$}
    \RightLabel{$\wedge$-proj$_2$}
    \UnaryInfC{$Γ⊢ ψ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{$\vee$-intro$_1$}
    \UnaryInfC{$Γ ⊢ φ \vee ψ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ψ$}
    \RightLabel{$\vee$-intro$_2$}
    \UnaryInfC{$Γ ⊢ φ \vee ψ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ γ $}
    \AxiomC{$Γ , ψ  ⊢ γ$}
    \RightLabel{$\vee$-elim}
    \BinaryInfC{$Γ , φ \vee ψ ⊢ γ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ ψ$}
    \RightLabel{$\Rightarrow$-intro}
    \UnaryInfC{$Γ ⊢ φ \Rightarrow ψ$}
  \end{bprooftree}
\end{equation*}

\[
%\scalebox{0.9}{
\begin{bprooftree}
\AxiomC{$Γ ⊢ φ \Rightarrow ψ$}
\AxiomC{$Γ ⊢ φ$}
\RightLabel{$\Rightarrow$-elim}
\BinaryInfC{$Γ ⊢ ψ$}
\end{bprooftree}\qquad
\begin{bprooftree}
\AxiomC{}
\RightLabel{PEM}
\UnaryInfC{$Γ ⊢ φ ∨ ¬ φ$}
\end{bprooftree}
\]

% \[
% \qquad
% \begin{bprooftree}
% \AxiomC{$Γ, ¬ φ ⊢ ⊥$}
% \RightLabel{RAA}
% \UnaryInfC{$Γ ⊢ φ$}
% \end{bprooftree}
% \]


\caption{Inference rules for propositional logic.}
\label{fig:CPL-inference-rules}
\end{figure}


\end{document}
