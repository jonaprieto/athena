
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Introduction (ESCRIBIENDO)}
\label{sec:introduction}

Reconstructing and verifying proofs delivered by automatic theorem provers
(henceforth ATP) are non-trivial tasks.
In the last decades, \ATPs is fast becoming a key instrument in 
different disciplines (\eg verifying cryptographic protocols for information security) and researchers have shown an increased interest to prove the validity of the deduction algorithms.
One reason to say that is the bugs found in many ATPs~\cite{Keller2013,Bohme2011,Fleury2014}.
For that reason, in order to give confidence to the user of these systems,
many ATPs has started to include in their outputs, the proofs of the
conclusion. However, existing research recognizes that in many cases these proofs encode non-trivial reasoning
hard to reconstruct them and therefore to verify them.

Hence proof-reconstructing becomes a reverse engineering task
in which the source, the proof, and its quality play an important role.
To begin with the proof-reconstruction, it is necessary to have
the proof of the \ATP in a consistent format, that is, a full script 
describing step-by-step with exhaustive details and without ambiguities, the 
derivation to get the actual proof.  
For classical propositional logic (henceforth \CPL), from a list of at least forty\footnote{\ATPs 
available from the web
service \name{SystemOnTPTP} of the TPTP World.} \ATPs, just a few
provers were able to deliver proofs and fewer like \name{EProver} or \Metis 
replied the proof in an admissible file format.

One approach to address the proof-reconstruction 
is integrating the \ATP, the \emph{source} system, with a proof assistant, the 
\emph{target} system.
The target system becomes in the proof checker. These proof assistants allow 
us to define the formal language used in the proofs, \ie, operators, logic 
variables, axioms, and theorems. A proof-reconstruction tool provides such an
integration, translating the replied generated by the prover into the formalism of the proof assistant.

Previous studies have reported proof-reconstruction using proof assistants for classical logic where the development is at a mature stage.
In contrast, we choose a proof assistant for type theory
where proof verification becomes a type-checking task of the proof-term following the Curry-Howard isomorphism. Then, the proof-reconstruction generates such proof-terms by reconstructing the proof replied by the \ATP.
However, some limitations arises by using type theory as we describe in Section~\ref{sec:limitations-type-theory}.

In this paper, we describe how to reconstruct proofs in type theory
replied by \Metis Prover\footnote{v2.3 release 2017102}.
We ported the subset of the \Metis inference rules for the propositional 
fragment using a syntactical treatment of that logic. The \Metis reasoning was formalized in \Agda~\cite{AgdaProp,AgdaMetis}. 
to reconstruct \Metis proofs, we built a proof-reconstruction tool named
\Athena~\cite{Athena} that is able to generate \Agda\footnote{v2.5.3} proof-terms for \Metis derivations. We have avoided the use of propositions meanings towards a future work to support other formalisms.
% but also to contrast the deep embedding using to write propositions in \Agda 
% with a shallow embedding. 


% The proof-reconstruction problem aims to solve this issue.
% One way to address this problem is using another major system in this field, the proof assistants.

% A proof-reconstruction tool using this approach will try to verify the proof delivered by the ATP using the proof assistant.

% In this paper, we purpose one of such proof-reconstruction tools.
% Our approach describes the design and implementation to reconstruct
% proofs of the \Metis prover into a proof assistant for type theory like
% \Agda. We use type theory to guarantee that proofs of the \ATP are valid.



% The main disadvantage of X

% One of the main obstacles to reconstruct proof generated by this tools
% are their

% One of the main obstacles to reconstruct proofs generated by
% automatic provers consists of ...

% However,

% The performance of X is limited by ...

% synopsys

%

% Existing research recognizes the critical role by ...

% What we known about X is largely based on ....

% Few published studied have examined the role of

% focus on a full description of the inference rules in the ATP logic.

% No previous studies has given sufficient considerations to ...

% This paper describes the design and implementation of X...

% This study provides new insights into the automatic reasoning of \Metis prover.
% Understanding the link between the ATP and ITP will help xxxx

% DECIR QUE ES NOVEDOSO EN AGDA Y Q NO ESTA HECHO EN TEORIA DE TIPOS
% SYNTATICA VS SEMANTICA.
% APPLICACIONES

% We describe how to reconstruct proofs delivered by an automatic theorem prover
% (henceforth \ATP)
% and an interactive theorem prover (henceforth
% \ITP).

% One way to reconstruct proofs of \ATPs consists of using an \ITP.
% An \ITP system provide us the logic framework to check and validate
% the reply of the \ATPs since 

% A proof-reconstruction tool provides such an integration, translating
% the reply generated by the prover into the formalism of the proof
% assistant.

% Then, reconstructing a proof involves an in-depth
% understanding of the algorithms in the \ATP and the logic specification
% in the \ITP. To begin with the proof-reconstruction, it is
% necessary to have a proof from the \ATP in a consistent
% format, that is, a full script describing step-by-step
% with exhaustive details and without ambiguities, the derivation to
% get the actual proof.

% For problems in classical propositional logic (henceforth \CPL),
% from a list of at least forty\footnote{\ATPs available from the web
% service \name{SystemOnTPTP} of the TPTP World.} \ATPs, just a few
% provers were able to deliver proofs (e.g.,
% \name{CVC4}~\cite{Barrett2011}, \name{SPASS}, and
% \name{Waldmeister}~\cite{hillenbrand1997}) and fewer replied with
% a proof
% in a file format like \TSTP~\cite{Sutcliffe-Schulz-Claessen-VanGelder-2006}
% (e.g., \name{E}, \Metis, \name{Vampire}, and \name{Z3}),
% \len{LFSC}~\cite{Stump2008}, or the \len{SMT-LIB}~\cite{Bohme2011} format.

%  These
% programs are relevant not only because it helps to spread their
% usage but they also increase the confidence of their users about
% their algorithms and their correctness (see, for example, bugs in
% \ATPs~\cite{Keller2013,Bohme2011,Fleury2014} and
% \cite{Kanso2012}).
% We mention some of these tools in Section~\ref{sec:related-work}.

In this paper, 



The formalization of these rules allow us to justify step-by-step \Metis derivations. We implemented this formalization in \Agda and we built
a translator tool, \Athena, to generate automatically the proof-terms
from \Metis proofs.

This paper has been organized in the following way.
We mention in Section~\ref{sec:limitations-type-theory}
some limitations of the proof-reconstruction from the type theory
point of view. In Section~\ref{sec:metis-language-and-proofs}, we introduce the
\Metis prover and its deduction system.
In Section~\ref{sec:proof-reconstruction}, we show our
approach to reconstruct proofs deliver by \Metis.
Related work is described in Section~\ref{sec:related-work}.
Section~\ref{sec:conclusions} summarizes the main findings and suggest future work.

% Finally, in appendix \textsc{A}, we provide a small example of the
% proof-reconstruction workflow.

The program and formalizations in \Agda mentioned in this paper are available
as \verb!Git! repositories at \verb!Github!:

\begin{itemize}
  \item The \Athena program to translate proofs generated by \Metis to \Agda code:
  \url{http://github.com/jonaprieto/athena}.
  \item The \verb!agda-prop! library as a formal system in \Agda for propositional logic:
  \url{http://github.com/jonaprieto/agda-prop}.
  \item The \verb!agda-metis! library as a formalization in \Agda to justify \Metis proofs in propositional
  logic:
  \url{http://github.com/jonaprieto/agda-prop}.
\end{itemize}

\end{document}
