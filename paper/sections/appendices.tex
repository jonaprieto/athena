
\documentclass[../main.tex]{subfiles}
\begin{document}

\newpage

\begin{subappendices}

\renewcommand{\thesection}{\Alph{section}}%
% or try \arabic{section}

% \section{Classical Propositional Logic}
% \label{app:CPL}

% \paragraph*{Propositions.}
% We define the propositional logic as usual.  A proposition is an
% expression formed by indivisible propositional atoms (e.g., symbols
% $φ₀, φ₁, \dots$) and the logic constants: \emph{falsum} $(⊥)$,
% \emph{verum} ($⊤$), the binary connectives ($∧, ∨, ⇒, ⇔)$, and the
% negation $(¬)$. We use an inductive definition of the set of
% propositions, denoted \Prop, as the mechanism to produce any
% propositional formula~\cite{VanDalen1994}.

% \begin{itemize}
% \item $⊥, ⊤ \in \Prop$.
% \item $ϕ_i \in \Prop$ for all $i \in \mathbb{N}$.
% \item If $φ, ψ\in \Prop$, then $(φ\ \square\ ψ) \in \Prop$,
% where the symbol ($\square$) is one of the binary connectives mentioned above.
% \item If $φ \in \Prop$, then $(¬ φ) \in \Prop$.
% \end{itemize}

% \paragraph*{Inference rules.}
% An inference rule is a deduction step of the form of a set of
% propositional \emph{premises} that produces propositions as the
% conclusion.  A derivation is a

% is a mechanism to obtain the conclusion $φ$ from
% the application of some deduction steps. Such deduction step has

% As we show in Fig.~\ref{fig:derivation}, the premises are always above the line, the conclusion
% is below it, and the name of the inference or the theorem used is
% on the left or on the right of the line.
% % As a notation convention, if the name of a rule used in the derivation step is typed using verbatim font face, for example, \verb!resolve!, it means the inference rule belongs to our implementation~\cite{AgdaProp, AgdaMetis} in the Proof Assistant of a inference rule presented
% % with a similar name.

% \begin{figure}
% \begin{equation*}
% \begin{bprooftree}
%   \AxiomC{$φ ∧ ψ$}
%   \RightLabel{∧-proj₂}
%   \UnaryInfC{$ψ$}
%   \AxiomC{$φ ∧ ψ$}
%   \RightLabel{∧-proj₁}
%   \UnaryInfC{$φ$}
%   \RightLabel{∧-intro}
%   \BinaryInfC{$ψ ∧ φ$}
% \end{bprooftree}
% \end{equation*}
% \caption{Derivation example.}
% \label{fig:derivation}
% \end{figure}

% \paragraph*{Theorems.}
% A sequent $Γ ⊢ φ$ represents a theorem, but we
% define it as a relation between a set of propositions premises $Γ$,
% and $φ$ as the conclusion of the sequent.
% The symbol $⊢$ is called turnstile.
% If $Γ = ∅$, we write $⊢ φ$, and we say that $φ$ is a theorem.
% A theorem, $Γ ⊢ φ$ , means that there is a derivation with
% conclusion $φ$ and with all (uncanceled) hypotheses in $Γ$.

% \paragraph*{Natural deductions.}
% The natural deduction introduced by Gentzen in 1930s defines a formal system
% for derivations that uses a set of inference rules as the only way to obtain a
% conclusion. We use this system to refer to formal proofs as natural deduction
% proofs and conversely.

% In this document, we extend the \CPL formal system
% Fig.~\ref{fig:CPL-inference-rules} described on
% paper~\cite{Altenkirch2015} to include inferences rules for the biconditional
% connective, $PEM$ and $RAA$ postulates, among others.


% \paragraph*{Proof trees.}
% We use trees to represent derivations and natural deduction proofs
% (see for instance, the proof tree in a \Metis' derivation in
% Fig.~\ref{fig:metis-example}).  In a proof tree, the root is the
% conclusion of the entire derivation. The nodes labeled with the name
% of the inference rule contains the result of applying that rule to
% their parents. Lastly, the leaves in the tree become the premises, not
% all necessary canceled.


\section{Customized \TSTP syntax}
\label{app:tstp-syntax}

We adopted a special \TSTP syntax to improve the readability of the \TSTP
examples shown in this document. Some of the modifications to the original
presentation of \TSTP syntax in Section~\ref{ssec:output-language} are the
following.

\begin{itemize}
  \item The formulas names are sub indexed (\eg, instead of \verb!axiom_0!,
  we write \verb!axiom₀!).
  \item We use \verb!inf! instead of \verb!inference! field.
  \item We shorten names generated automatically by \Metis, (\eg,
\verb!s₀! instead of \verb!subgoal_0! or \verb!n₀!
instead of \verb!normalize_0!).
  \item We remove the \verb!plain! role.
  \item We remove empty fields in the inference information.
  \item The brackets in the argument of a unary inference are removed (\eg,
instead of \verb!inf(rule, [], [n₀]))!, we write
\verb!inf(rule, [], n₀))!).
  \item If the inference rule does not need arguments except its parent nodes,
  we remove the field of useful information (\eg,
 \verb!inf(canonicalize, premise)! instead of
 \verb!inf(canonicalize, [], premise)!).
  \item We use the symbols (⊤, ⊥, ¬, ∧, ∨, ⇒) for formulas instead of
  (\verb!$false!, \verb!$true!, \verb!~!, \verb!&!, \verb!|!, \verb!=>!) \TPTP symbols.
  \item When the purpose to show a \TSTP derivation does not include
  some parts of the derivation we use the ellipsis (\verb!...!) to avoid
  such unnecessary parts.
\end{itemize}

For example, let us consider the \TSTP derivation generated by \Metis
in Fig.~\ref{fig:metis-proof-tstp} and its customized version in
Fig.~\ref{fig:metis-proof-tstp-customized}

\begin{figure}[!h]
\begin{verbatim}
  fof(premise, axiom, p).
  fof(goal, conjecture, p).
  fof(subgoal_0, plain, p, inference(strip, [], [goal])).
  fof(negate_0_0, plain, ~ p, inference(negate, [], [subgoal_0])).
  fof(normalize_0_0, plain, ~ p,
    inference(canonicalize, [], [negate_0_0])).
  fof(normalize_0_1, plain, p,
    inference(canonicalize, [], [premise])).
  fof(normalize_0_2, plain, $false,
    inference(simplify, [], [normalize_0_0, normalize_0_1]))
  cnf(refute_0_0, plain, $false,
    inference(canonicalize, [], [normalize_0_2])).
\end{verbatim}
\caption{\texttt{Metis}' \texttt{TSTP} derivation for the
problem $p\vdash p$.}
\label{fig:metis-proof-tstp}
\end{figure}

\begin{figure}[!h]
\begin{verbatim}
  fof(premise, axiom, p).
  fof(goal, conjecture, p).
  fof(s₀, p, inf(strip, goal)).
  fof(neg₀, ¬ p, inf(negate, s₀)).
  fof(n₀, ¬ p, inf(canonicalize, neg₀)).
  fof(n₁, p, inf(canonicalize, premise)).
  fof(n₂, ⊥, inf(simplify, [n₀, n₁]))
  cnf(r₀, ⊥, inf(canonicalize, n₂)).
\end{verbatim}
\caption{\texttt{Metis}' \texttt{TSTP} derivation using a customized syntax}
\label{fig:metis-proof-tstp-customized}
\end{figure}

\section{Complexity Measure of the \strip Function}
\label{app:strip-cm}

In Section~\ref{sssec:strip-a-goal} we describe the
\strip function to get the subgoals of a certain a goal.
We define in~\eqref{eq:strip-cm} its complexity measure.

\begin{equation*}
\label{eq:strip-cm}
\begin{aligned}
&\hspace{.495mm}\fstrip_{cm} : \Prop \to \Nat \to \Prop\\
&\begin{array}{lll}
\fstrip_{cm} &(φ₁ ∧ φ₂)      &= \textrm{max}~(\fstrip_{cm}~φ₁)~(\fstrip_{cm}~φ₂) + 1\\
\fstrip_{cm} &(φ₁ ∨ φ₂)      &= \fstrip_{cm}~φ₂ + 1\\
\fstrip_{cm} &(φ₁ ⇒ φ₂)      &= \fstrip_{cm}~φ₂ + 1\\
\fstrip_{cm} &(¬ ⊤)          &= \fstrip_{cm}~(¬ φ₂) + 1\\
\fstrip_{cm} &(¬ ⊥)          &= \textrm{max}~(\fstrip_{cm}~(¬ φ₁))~(\fstrip_{cm}~(¬ φ₂)) + 1\\
\fstrip_{cm} &(¬ (φ₁ ∧ φ₂))  &= \textrm{max}~(\fstrip_{cm}~φ₁)~(\fstrip_{cm}~(¬ φ₂)) + 1\\
\fstrip_{cm} &(¬ (φ₁ ∨ φ₂))  &= \textrm{max}~(\fstrip_{cm}~(¬ φ₁))~(\fstrip_{cm}~(¬ φ₂)) + 1\\
\fstrip_{cm} &(¬ (φ₁ ⇒ φ₂))  &= \fstrip_{cm}~φ₁ + 1\\
\fstrip_{cm} &(¬ (¬ φ))      &= 1\\
\fstrip_{cm} &φ              &= 1
\end{array}
\end{aligned}
\end{equation*}


\section{Complexity Measure of the Negative Normal Form function}
\label{app:polarity-for-propositions}

In Section~\ref{sssec:canonicalize} we define a custom negative
normal form of a formula by defining a bounded recursion
in~\eqref{eq:nnf}. Its complexity measure is defined as follows.

\begin{equation}
\label{eq:nnf-cm}
\begin{aligned}
&\hspace{.495mm}\fnnf_{cm} : \Prop \to \Nat \to \Prop\\
&\begin{array}{lll}
\fnnf_{cm} &(φ₁ ∧ φ₂)      &= \fnnf_{cm}~φ₁ + \fnnf_{cm}~φ₂ + 1 \\
\fnnf_{cm} &(φ₁ ∨ φ₂)      &= \fnnf_{cm}~φ₁ + \fnnf_{cm}~φ₂ + 1 \\
\fnnf_{cm} &(φ₁ ⇒ φ₂)      &= 2 \cdot \fnnf_{cm}~φ₁  + \fnnf_{cm}~φ₂ + 1 \\
\fnnf_{cm} &(¬ (φ₁ ∧ φ₂))  &= \fnnf_{cm}~(¬ φ₁) + \fnnf_{cm}~(¬ φ₂) + 1 \\
\fnnf_{cm} &(¬ (φ₁ ∨ φ₂))  &= \fnnf_{cm}~(¬ φ₁) + \fnnf_{cm}~(¬ φ₂) + 1 \\
\fnnf_{cm} &(¬ (φ₁ ⇒ φ₂))  &= \fnnf_{cm}~(¬ φ₁) + 1 \\
\fnnf_{cm} &(¬ (¬ φ))      &= \fnnf_{cm}~φ₁ + \fnnf_{cm}~(¬ φ₂) + 3 \\
\fnnf_{cm} &(¬ ⊤)          &= 1 \\
\fnnf_{cm} &(¬ ⊥)          &= 1 \\
\fnnf_{cm} &φ              &= 1 \\
\end{array}
\end{aligned}
\end{equation}

Another approach to define the negative normal form in type theory without
using a complexity measure for the bounded recursion is described in~\cite{Bezem2002}.
The authors avoid a termination problem by using the
polarity of the formula as an additional argument of its negative normal form function.
However, be aware the polarity function is not standard, and \Metis has its own
definition.

% \begin{equation}
% \label{def:polarity}
%   \begin{aligned}
%   &\hspace{.495mm}\fpolarity : \Prop \to \abbre{Polarity}\\
%     &\begin{array}{lll}
%       \fpolarity &(φ₁ ∧ φ₂) &= ⊕\\
%       \fpolarity &(φ₁ ∨ φ₂) &= ⊖\\
%       \fpolarity &(φ₁ ⇒ φ₂) &= ⊖\\
%       \fpolarity &(¬ φ)     &=
%         \begin{cases}
%         ⊕, &\text{ if }\fpolarity~φ=⊖;\\
%         ⊖, &\text{ if }\fpolarity~φ=⊕;
%         \end{cases}\\
%       \fpolarity &φ     &=⊕
%     \end{array}
%   \end{aligned}
% \end{equation}


\section{A case in the proof of the \strip inference rule}
\label{app:strip-proof-case}

\begin{itemize}
\item[∙] Case $φ ≡ φ₁ ⇒ φ₂$.
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{}
  \RightLabel{assume}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁$}
  \AxiomC{$Γ ⊢ \fstrip₁~(φ₁ ⇒ φ₂)~(\suc~n)$}
  \RightLabel{by~\eqref{eq:strip-fixed}}
  \UnaryInfC{$Γ ⊢ \fuh~(φ₁ ⇒ \fstrip₁~φ₂~n)$}
  \RightLabel{Lemma~\ref{lem:inv-uh-lem}}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ \fstrip₁~φ₂~n$}
  \RightLabel{weaken}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁ ⇒ \fstrip₁~φ₂~n$}
  \RightLabel{⇒-elim}
  \BinaryInfC{$Γ , φ₁ ⊢ \fstrip₁~φ₂~n$}
  \RightLabel{by~ind.~hyp.}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₂$}
  \RightLabel{⇒-intro.}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
  \end{bprooftree}
\end{equation*}
\end{itemize}

% \section{A Small Example}
% \label{appendix}

% \subsection{\CPL Problem}

% \begin{equation*}
% \{\ (p ∨ q) ∧ (p ∨ r)\ \} \vdash p ∨ (q ∧ r)
% \end{equation*}

% \subsection{\TPTP Problem}

% \begin{verbatim}
%   fof(a1, axiom, ((p | q) & (p | r))).
%   fof(goal, conjecture, (p | (q & r))).
% \end{verbatim}

% \subsection{\Metis \TSTP Derivation}
% \verbatiminput{sections/data/problem.tstp}

% \subsection{\Agda Proof-term}
% \verbatiminput{sections/data/problem.agda}


% \section{Rank for a proposition}
% \label{app:rank-for-a-proposition}
% The rank for a proposition defined in~\cite{VanDalen1994} is
% a complexity measure.
% \begin{equation}
% % \label{eq:rank-definition}
% \begin{aligned}
% &\hspace{.495mm}\frank : \Prop → \Nat\\
% &\begin{array}{llll}
% \frank~(¬~φ)           &= \frank~φ₁~+~c_{¬}\\
% \frank~(φ₁~\square~φ₂) &= \fmax~(\frank~φ₁)~(\frank~φ₂) + c_{\square}\\
% \frank~φ               &= 0.
% \end{array}
% \end{aligned}
% \end{equation}


\end{subappendices}

\end{document}
