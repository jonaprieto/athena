
\documentclass[../main.tex]{subfiles}
\begin{document}

\newpage

\begin{subappendices}

\renewcommand{\thesection}{\Alph{section}}%
% or try \arabic{section}

% \section{Classical Propositional Logic}
% \label{app:CPL}

% \paragraph*{Propositions.}
% We define the propositional logic as usual.  A proposition is an
% expression formed by indivisible propositional atoms (e.g., symbols
% $φ₀, φ₁, \dots$) and the logic constants: \emph{falsum} $(⊥)$,
% \emph{verum} ($⊤$), the binary connectives ($∧, ∨, ⇒, ⇔)$, and the
% negation $(¬)$. We use an inductive definition of the set of
% propositions, denoted \Prop, as the mechanism to produce any
% propositional formula~\cite{VanDalen1994}.

% \begin{itemize}
% \item $⊥, ⊤ \in \Prop$.
% \item $ϕ_i \in \Prop$ for all $i \in \mathbb{N}$.
% \item If $φ, ψ\in \Prop$, then $(φ\ \square\ ψ) \in \Prop$,
% where the symbol ($\square$) is one of the binary connectives mentioned above.
% \item If $φ \in \Prop$, then $(¬ φ) \in \Prop$.
% \end{itemize}

% \paragraph*{Inference rules.}
% An inference rule is a deduction step of the form of a set of
% propositional \emph{premises} that produces propositions as the
% conclusion.  A derivation is a

% is a mechanism to obtain the conclusion $φ$ from
% the application of some deduction steps. Such deduction step has

% As we show in Fig.~\ref{fig:derivation}, the premises are always above the line, the conclusion
% is below it, and the name of the inference or the theorem used is
% on the left or on the right of the line.
% % As a notation convention, if the name of a rule used in the derivation step is typed using verbatim font face, for example, \verb!resolve!, it means the inference rule belongs to our implementation~\cite{AgdaProp, AgdaMetis} in the Proof Assistant of a inference rule presented
% % with a similar name.

% \begin{figure}
% \begin{equation*}
% \begin{bprooftree}
%   \AxiomC{$φ ∧ ψ$}
%   \RightLabel{∧-proj₂}
%   \UnaryInfC{$ψ$}
%   \AxiomC{$φ ∧ ψ$}
%   \RightLabel{∧-proj₁}
%   \UnaryInfC{$φ$}
%   \RightLabel{∧-intro}
%   \BinaryInfC{$ψ ∧ φ$}
% \end{bprooftree}
% \end{equation*}
% \caption{Derivation example.}
% \label{fig:derivation}
% \end{figure}

% \paragraph*{Theorems.}
% A sequent $Γ ⊢ φ$ represents a theorem, but we
% define it as a relation between a set of propositions premises $Γ$,
% and $φ$ as the conclusion of the sequent.
% The symbol $⊢$ is called turnstile.
% If $Γ = ∅$, we write $⊢ φ$, and we say that $φ$ is a theorem.
% A theorem, $Γ ⊢ φ$ , means that there is a derivation with
% conclusion $φ$ and with all (uncanceled) hypotheses in $Γ$.

% \paragraph*{Natural deductions.}
% The natural deduction introduced by Gentzen in 1930s defines a formal system
% for derivations that uses a set of inference rules as the only way to obtain a
% conclusion. We use this system to refer to formal proofs as natural deduction
% proofs and conversely.

% In this document, we extend the \CPL formal system
% Fig.~\ref{fig:CPL-inference-rules} described on
% paper~\cite{Altenkirch2015} to include inferences rules for the biconditional
% connective, $PEM$ and $RAA$ postulates, among others.


% \paragraph*{Proof trees.}
% We use trees to represent derivations and natural deduction proofs
% (see for instance, the proof tree in a \Metis' derivation in
% Fig.~\ref{fig:metis-example}).  In a proof tree, the root is the
% conclusion of the entire derivation. The nodes labeled with the name
% of the inference rule contains the result of applying that rule to
% their parents. Lastly, the leaves in the tree become the premises, not
% all necessary canceled.


\section{Customized \TSTP syntax}
\label{app:tstp-syntax}

We adopted a special \TSTP syntax to improve the readability of the \TSTP
examples shown in this document. Some of the modifications to the original
presentation of \TSTP syntax in Section~\ref{ssec:output-language} are the
following.

\begin{itemize}
  \item The formulas names are sub indexed (\eg, instead of \verb!axiom_0!,
  we write \verb!axiom₀!).
  \item We use \verb!inf! instead of \verb!inference! field.
  \item We shorten names generated automatically by \Metis, (\eg,
\verb!s₀! instead of \verb!subgoal_0! or \verb!n₀!
instead of \verb!normalize_0!).
  \item We remove the \verb!plain! role.
  \item We remove empty fields in the inference information.
  \item The brackets in the argument of a unary inference are removed (\eg,
instead of \verb!inf(rule, [], [n₀]))!, we write
\verb!inf(rule, [], n₀))!).
  \item If the inference rule does not need arguments except its parent nodes,
  we remove the field of useful information (\eg,
 \verb!inf(canonicalize, premise)! instead of
 \verb!inf(canonicalize, [], premise)!).
  \item We use the symbols (⊤, ⊥, ¬, ∧, ∨, ⇒) for formulas instead of
  (\verb!$false!, \verb!$true!, \verb!~!, \verb!&!, \verb!|!, \verb!=>!) \TPTP symbols.
  \item When the purpose to show a \TSTP derivation does not include
  some parts of the derivation we use the ellipsis (\verb!...!) to avoid
  such unnecessary parts.
\end{itemize}

For example, let us consider the \TSTP derivation generated by \Metis
in Fig.~\ref{fig:metis-proof-tstp} and its customized version in
Fig.~\ref{fig:metis-proof-tstp-customized}

\begin{figure}[!ht]
\begin{verbatim}
  fof(premise, axiom, p).
  fof(goal, conjecture, p).
  fof(subgoal_0, plain, p, inference(strip, [], [goal])).
  fof(negate_0_0, plain, ~ p, inference(negate, [], [subgoal_0])).
  fof(normalize_0_0, plain, ~ p,
    inference(canonicalize, [], [negate_0_0])).
  fof(normalize_0_1, plain, p,
    inference(canonicalize, [], [premise])).
  fof(normalize_0_2, plain, $false,
    inference(simplify, [], [normalize_0_0, normalize_0_1]))
  cnf(refute_0_0, plain, $false,
    inference(canonicalize, [], [normalize_0_2])).
\end{verbatim}
\caption{\texttt{Metis}' \texttt{TSTP} derivation for the
problem $p\vdash p$.}
\label{fig:metis-proof-tstp}
\end{figure}

\begin{figure}[!ht]
\begin{verbatim}
  fof(premise, axiom, p).
  fof(goal, conjecture, p).
  fof(s₀, p, inf(strip, goal)).
  fof(neg₀, ¬ p, inf(negate, s₀)).
  fof(n₀, ¬ p, inf(canonicalize, neg₀)).
  fof(n₁, p, inf(canonicalize, premise)).
  fof(n₂, ⊥, inf(simplify, [n₀, n₁]))
  cnf(r₀, ⊥, inf(canonicalize, n₂)).
\end{verbatim}
\caption{\texttt{Metis}' \texttt{TSTP} derivation using a customized syntax}
\label{fig:metis-proof-tstp-customized}
\end{figure}

\newpage
\newpage
\section{Complexity Measure of the \strip Function}
\label{app:strip-cm}

In Section~\ref{sssec:strip-a-goal} we describe the
\strip function to get the subgoals of a certain a goal.
We define in~\eqref{eq:strip-cm} its complexity measure.

\begin{equation*}
\label{eq:strip-cm}
\begin{aligned}
&\hspace{.495mm}\fstrip_{cm} : \Prop \to \Nat \to \Prop\\
&\begin{array}{lll}
\fstrip_{cm} &(φ₁ ∧ φ₂)      &= \textrm{max}~(\fstrip_{cm}~φ₁)~(\fstrip_{cm}~φ₂) + 1\\
\fstrip_{cm} &(φ₁ ∨ φ₂)      &= \fstrip_{cm}~φ₂ + 1\\
\fstrip_{cm} &(φ₁ ⇒ φ₂)      &= \fstrip_{cm}~φ₂ + 1\\
\fstrip_{cm} &(¬ ⊤)          &= \fstrip_{cm}~(¬ φ₂) + 1\\
\fstrip_{cm} &(¬ ⊥)          &= \textrm{max}~(\fstrip_{cm}~(¬ φ₁))~(\fstrip_{cm}~(¬ φ₂)) + 1\\
\fstrip_{cm} &(¬ (φ₁ ∧ φ₂))  &= \textrm{max}~(\fstrip_{cm}~φ₁)~(\fstrip_{cm}~(¬ φ₂)) + 1\\
\fstrip_{cm} &(¬ (φ₁ ∨ φ₂))  &= \textrm{max}~(\fstrip_{cm}~(¬ φ₁))~(\fstrip_{cm}~(¬ φ₂)) + 1\\
\fstrip_{cm} &(¬ (φ₁ ⇒ φ₂))  &= \fstrip_{cm}~φ₁ + 1\\
\fstrip_{cm} &(¬ (¬ φ))      &= 1\\
\fstrip_{cm} &φ              &= 1
\end{array}
\end{aligned}
\end{equation*}

\section{Another Case in the Proof of the \strip Inference Rule}
\label{app:strip-proof-case}

\begin{itemize}
\item[∙] Case $φ ≡ φ₁ ⇒ φ₂$.
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{}
  \RightLabel{assume}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁$}
  \AxiomC{$Γ ⊢ \fstrip₁~(φ₁ ⇒ φ₂)~(\suc~n)$}
  \RightLabel{by~\eqref{eq:strip-fixed}}
  \UnaryInfC{$Γ ⊢ \fuh~(φ₁ ⇒ \fstrip₁~φ₂~n)$}
  \RightLabel{Lemma~\ref{lem:inv-uh-lem}}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ \fstrip₁~φ₂~n$}
  \RightLabel{weaken}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁ ⇒ \fstrip₁~φ₂~n$}
  \RightLabel{⇒-elim}
  \BinaryInfC{$Γ , φ₁ ⊢ \fstrip₁~φ₂~n$}
  \RightLabel{by~ind.~hyp.}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₂$}
  \RightLabel{⇒-intro.}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
  \end{bprooftree}
\end{equation*}
\end{itemize}


\newpage
\section{Complexity Measure of the Negative Normal Form Function}
\label{app:polarity-for-propositions}

In Section~\ref{sssec:canonicalize} we discuss a custom negative
normal form of a formula. To convert a formula to such a normal
form, we define the function $\fnnf_{0}$ in~\eqref{eq:nnf-zero}.

\begin{equation}
\label{eq:nnf-zero}
\begin{aligned}
&\hspace{.495mm}\fnnf_{0} : \Prop \to \Prop\\
&\begin{array}{lll}
\fnnf_{0} &(φ₁ ∧ φ₂)      &= \fcanon_{∧}~(\fassoc_{∧}~(\fnnf_{0}~φ₁ ∧ \fnnf_{0}~φ₂))\\
\fnnf_{0} &(φ₁ ∨ φ₂)      &= \fcanon_{∨}~(\fassoc_{∨}~(\fnnf_{0}~φ₁ ∨ \fnnf_{0}~φ₂))\\
\fnnf_{0} &(φ₁ ⇒ φ₂)      &= \fcanon_{∨}~(\fassoc_{∨}~(\fnnf_{0}~((¬ φ₁) ∨ φ₂)))\\
\fnnf_{0} &(¬ (φ₁ ∧ φ₂))  &= \fcanon_{∨}~(\fassoc_{∨}~(\fnnf_{0}~((¬ φ₁) ∨ (¬ φ₂))))\\
\fnnf_{0} &(¬ (φ₁ ∨ φ₂))  &= \fcanon_{∧}~(\fassoc_{∧}~(\fnnf_{0}~((¬ φ₁) ∧ (¬ φ₂))))\\
\fnnf_{0} &(¬ (φ₁ ⇒ φ₂))  &= \fcanon_{∧}~(\fassoc_{∧}~(\fnnf_{0}~((¬ φ₂) ∧ φ₁)))\\
\fnnf_{0} &(¬ (¬ φ))      &= \fnnf_{0}~φ₁\\
\fnnf_{0} &(¬ ⊤)          &= ⊥\\
\fnnf_{0} &(¬ ⊥)          &= ⊤\\
\fnnf_{0} &φ              &= φ
\end{array}
\end{aligned}
\end{equation}

However, then $\fnnf_{0}$ function is not a structurally recursive
function. Therefore, we define a bounded recursion in~\eqref{eq:nnf}
using as the second argument for the bounded recursion its complexity
measure. The $\fnnf_{cm}$ function in~\eqref{eq:nnf-cm} computes that
complexity measure.

\begin{equation}
\label{eq:nnf-cm}
\begin{aligned}
&\hspace{.495mm}\fnnf_{cm} : \Prop \to \Nat \to \Prop\\
&\begin{array}{lll}
\fnnf_{cm} &(φ₁ ∧ φ₂)      &= \fnnf_{cm}~φ₁ + \fnnf_{cm}~φ₂ + 1 \\
\fnnf_{cm} &(φ₁ ∨ φ₂)      &= \fnnf_{cm}~φ₁ + \fnnf_{cm}~φ₂ + 1 \\
\fnnf_{cm} &(φ₁ ⇒ φ₂)      &= 2 \cdot \fnnf_{cm}~φ₁  + \fnnf_{cm}~φ₂ + 1 \\
\fnnf_{cm} &(¬ (φ₁ ∧ φ₂))  &= \fnnf_{cm}~(¬ φ₁) + \fnnf_{cm}~(¬ φ₂) + 1 \\
\fnnf_{cm} &(¬ (φ₁ ∨ φ₂))  &= \fnnf_{cm}~(¬ φ₁) + \fnnf_{cm}~(¬ φ₂) + 1 \\
\fnnf_{cm} &(¬ (φ₁ ⇒ φ₂))  &= \fnnf_{cm}~(¬ φ₁) + 1 \\
\fnnf_{cm} &(¬ (¬ φ))      &= \fnnf_{cm}~φ₁ + \fnnf_{cm}~(¬ φ₂) + 3 \\
\fnnf_{cm} &(¬ ⊤)          &= 1 \\
\fnnf_{cm} &(¬ ⊥)          &= 1 \\
\fnnf_{cm} &φ              &= 1 \\
\end{array}
\end{aligned}
\end{equation}

Another approach to define the negative normal form in type theory
without using a complexity measure for the bounded recursion would
modify the definition of $\fnnf$ defined in~\cite{Bezem2002}. The
authors avoid the termination problem by using the polarity of the
formula as an additional argument of its negative normal form
function. However, be aware the polarity function is not standard and
\Metis has its own definition.

% \begin{equation}
% \label{def:polarity}
%   \begin{aligned}
%   &\hspace{.495mm}\fpolarity : \Prop \to \abbre{Polarity}\\
%     &\begin{array}{lll}
%       \fpolarity &(φ₁ ∧ φ₂) &= ⊕\\
%       \fpolarity &(φ₁ ∨ φ₂) &= ⊖\\
%       \fpolarity &(φ₁ ⇒ φ₂) &= ⊖\\
%       \fpolarity &(¬ φ)     &=
%         \begin{cases}
%         ⊕, &\text{ if }\fpolarity~φ=⊖;\\
%         ⊖, &\text{ if }\fpolarity~φ=⊕;
%         \end{cases}\\
%       \fpolarity &φ     &=⊕
%     \end{array}
%   \end{aligned}
% \end{equation}


% \section{A Small Example}
% \label{appendix}

% \subsection{\CPL Problem}

% \begin{equation*}
% \{\ (p ∨ q) ∧ (p ∨ r)\ \} \vdash p ∨ (q ∧ r)
% \end{equation*}

% \subsection{\TPTP Problem}

% \begin{verbatim}
%   fof(a1, axiom, ((p | q) & (p | r))).
%   fof(goal, conjecture, (p | (q & r))).
% \end{verbatim}

% \subsection{\Metis \TSTP Derivation}
% \verbatiminput{sections/data/problem.tstp}

% \subsection{\Agda Proof-term}
% \verbatiminput{sections/data/problem.agda}


% \section{Rank for a proposition}
% \label{app:rank-for-a-proposition}
% The rank for a proposition defined in~\cite{VanDalen1994} is
% a complexity measure.
% \begin{equation}
% % \label{eq:rank-definition}
% \begin{aligned}
% &\hspace{.495mm}\frank : \Prop → \Nat\\
% &\begin{array}{llll}
% \frank~(¬~φ)           &= \frank~φ₁~+~c_{¬}\\
% \frank~(φ₁~\square~φ₂) &= \fmax~(\frank~φ₁)~(\frank~φ₂) + c_{\square}\\
% \frank~φ               &= 0.
% \end{array}
% \end{aligned}
% \end{equation}


\newpage
\section{Complete Example}
\label{app:complete-example}

\subsection{Installing \Athena}

\Athena is the proof-reconstruction tool that accompanying this paper.
This tool is written in \Haskell and it was tested with \prg{GHC}~8.2.1.
To install \Athena, the package manager \verb!cabal! is required as well.
\Athena was tested with \verb!cabal!~1.24.0.

Let us download the \Athena repository running the following command:

\begin{verbatim}
  $ git clone https://github.com/jonaprieto/athena.git
  $ cd athena
\end{verbatim}

To install \Athena run the following command.

\begin{verbatim}
  $ make install
\end{verbatim}

To install the \Agda libraries, \verb!agda-prop!, \verb!agda-metis!, and
the \Agda standard library, run the following command:

\begin{verbatim}
  $ make install-libraries
  $ ls lib/
  agda-metis  agda-prop  agda-stdlib
\end{verbatim}

\subsection{Installing the \Metis Prover}

To install the \Metis prover v2.3 (release 20171021),
we refer the reader to its official
repository at \url{https://github.com/gilith/metis}.

As an alternative to install the prover from the \Metis sources,
we have provided a \Haskell client
to use this prover but also other provers with \name{Online-ATPs}
tool\footnote{\url{https://github.com/jonaprieto/online-atps}.}.
To install this tool run the following command:

\begin{verbatim}
  $ make online-atps
  $ online-atps --version
  Online-atps version 0.1.1
\end{verbatim}

\subsection{\TPTP problem}

Let us consider the following
theorem\footnote{Problem No.~13 in Disjunction Section in~\cite{Prieto-Cubides2017}.}:

\begin{equation}
\label{eq:complete-example-problem}
(p \Rightarrow q) \wedge (q \Rightarrow p) ⊢ (p \vee q) \Rightarrow (p \wedge q)
\end{equation}

This problem can be encode in \TPTP syntax (file \verb!problem.tptp!) as follows:

\begin{verbatim}
  $ cat problem.tptp
  fof(premise, axiom, (p => q) & (q => p)).
  fof(goal, conjecture, (p | q) => (p & q)).
\end{verbatim}

\subsection{\Metis derivation}

To obtain the \Metis derivation of the \TPTP problem showed above,
make sure your \Metis version is supported by running the following command.
Recall, we support the version 2.3 (release 20171021).

\begin{verbatim}
  $ metis --version
  metis 2.3 (release 20171021)
\end{verbatim}

and run the following command:

\begin{verbatim}
  $ metis --show proof problem.tptp > problem.tstp
  $ cat problem.tstp
  ...
  fof(a1, axiom, ((p => q) & (q => p))).
  fof(goal, conjecture, ((p | q) => (p & q))).
  fof(subgoal_0, plain, ((p | q) => p), inference(strip, [], [goal])).
  fof(subgoal_1, plain, (((p | q) & p) => q), inference(strip, [], [goal])).
  fof(negate_0_0, plain, (~ ((p | q) => p)),
      inference(negate, [], [subgoal_0])).
  ...
\end{verbatim}

If we are using the \name{Online-ATPs} tool run the following command:

\begin{verbatim}
  online-atps --atp=metis problem.tptp  > problem.tstp
\end{verbatim}

Using our customized \TSTP syntax, the above \Metis solution looks like:

\begin{verbatim}
  fof(premise, axiom, (p ⇒ q) ∧ (q ⇒ p)).
  fof(goal, conjecture, (p ∨ q) ⇒ (p ∧ q))).
  fof(s₁, (p ∨ q) ⇒ p, inf(strip, goal)).
  fof(s₂, ((p ∨ q) ∧ p) ⇒ q, inf(strip, goal)).
  fof(neg₁, ¬ ((p ∨ q) ⇒ p), inf(negate, s₁)).
  fof(n₀₀, (¬ p ∨ q) ∧ (¬ q ∨ p), inf(canonicalize, premise)).
  fof(n₀₁, ¬ q ∨ p, inf(conjunct, n₀₀)).
  fof(n₀₂, ¬ p ∧ (p ∨ q), inf(canonicalize, neg₁)).
  fof(n₀₃, p ∨ q, inf(conjunct, n₀₂)).
  fof(n₀₄, ¬ p, inf(conjunct, n₀₂)).
  fof(n₀₅, q, inf(simplify,[n₀₃, n₀₄])).
  cnf(r₀₀, ¬ q ∨ p, inf(canonicalize, n₀₁)).
  cnf(r₀₁, q, inf(canonicalize, n₀₅)).
  cnf(r₀₂, p, inf(resolve, q, [r₀₁, r₀₀])).
  cnf(r₀₃, ¬ p, inf(canonicalize, n₀₄)).
  cnf(r₀₄, ⊥, inf(resolve, p, [r₀₂, r₀₃])).
  fof(neg₂, ¬ (((p ∨ q) ∧ p) ⇒ q), inf(negate, s₂)).
  fof(n₁₀, ¬ q ∧ p ∧ (p ∨ q), inf(canonicalize, neg₂)).
  fof(n₁₁, (¬ p ∨ q) ∧ (¬ q ∨ p), inf(canonicalize, premise)).
  fof(n₁₂, ¬ p ∨ q, inf(conjunct, n₁₁)).
  fof(n₁₃, ⊥, inf(simplify,[n₁₀, n₁₂])).
  cnf(r₁₀, ⊥, inf(canonicalize, n₁₃)).
\end{verbatim}
% \caption{Customized \Metis \TSTP derivation for the theorem in~\eqref{eq:complete-example-problem}}
% \label{app:customized-metis-complete-example}
% \end{figure}

\subsection{Generating the \Agda proof-term}

To obtain the \Agda proof-term of the \Metis derivation run
the following command:

\begin{verbatim}
  $ athena problem.tstp
\end{verbatim}

The \Agda file will be created in the same directory. This
file is named by replacing the extension \verb!tstp! with \verb!agda!.

\begin{verbatim}
  $ cat problem.agda
  ------------------------------------------------------------------------------
  -- Athena version 0.1-b3d15b8.
  -- TSTP file: problem.tstp.
  ------------------------------------------------------------------------------

  module problem where

  ------------------------------------------------------------------------------

  open import ATP.Metis 2 public
  open import Data.PropFormula 2 public

  ------------------------------------------------------------------------------

  -- Variables.

  p : PropFormula
  p = Var (# 0)

  q : PropFormula
  q = Var (# 1)

  -- Axiom.

  premise : PropFormula
  premise = ((p ⇒ q) ∧ (q ⇒ p))

  -- Premise.

  Γ : Ctxt
  Γ = [ premise ]

  -- Conjecture.

  goal : PropFormula
  goal = ((p ∨ q) ⇒ (p ∧ q))

  -- Subgoals.

  subgoal₀ : PropFormula
  subgoal₀ = ((p ∨ q) ⇒ p)

  subgoal₁ : PropFormula
  subgoal₁ = (((p ∨ q) ∧ p) ⇒ q)

  ------------------------------------------------------------------------------
  -- Proof.
  ------------------------------------------------------------------------------

  proof₀ : Γ ⊢ subgoal₀
  proof₀ =
    (RAA
      (resolve-thm ⊥ p
        (resolve-thm p q
          (simplify-thm q
            (conjunct-thm (p ∨ q)
              (canonicalize-thm ((¬ p) ∧ (p ∨ q))
                (assume {Γ = Γ} (¬ subgoal₀))))
            (conjunct-thm (¬ p)
              (canonicalize-thm ((¬ p) ∧ (p ∨ q))
                (assume {Γ = Γ} (¬ subgoal₀)))))
          (conjunct-thm ((¬ q) ∨ p)
            (canonicalize-thm (((¬ p) ∨ q) ∧ ((¬ q) ∨ p))
              (weaken (¬ subgoal₀)
                (assume {Γ = ∅} premise)))))
        (conjunct-thm (¬ p)
          (canonicalize-thm ((¬ p) ∧ (p ∨ q))
            (assume {Γ = Γ} (¬ subgoal₀))))))
  ---------------------------------------------------------------------------- ∎

  proof₁ : Γ ⊢ subgoal₁
  proof₁ =
    (RAA
      (simplify-thm ⊥
        (canonicalize-thm ((¬ q) ∧ (p ∧ (p ∨ q)))
          (assume {Γ = Γ} (¬ subgoal₁)))
        (conjunct-thm ((¬ p) ∨ q)
          (canonicalize-thm (((¬ p) ∨ q) ∧ ((¬ q) ∨ p))
            (weaken (¬ subgoal₁)
              (assume {Γ = ∅} premise))))))
  ---------------------------------------------------------------------------- ∎

  proof : Γ ⊢ goal
  proof =
    ⇒-elim
      strip-thm
      (∧-intro proof₀ proof₁)
  ---------------------------------------------------------------------------- ∎
\end{verbatim}

Now, we are ready to verify the \Metis derivation by type-checking with
\Agda the reconstructed proof showed above. Make sure the \Agda version is
 2.5.3.

\begin{verbatim}
  $ agda --version
  Agda version 2.5.3
  $ agda problem.agda
\end{verbatim}

As we can see in the \Agda code showed above, the term \verb!proof!, the proof-term
of the \Metis derivation is referring to the proof-terms \verb!proof₀! and \verb!proof₁!.
Recall, \Metis stripes the goal into subgoals to prove it. Therefore, these
terms are the proof-terms for the refutations of the subgoals s₁ and s₂.
We show in the following sections the respective natural deduction trees for these
refutations.

\subsection{Refutation tree for the subgoal $s₁$: $(p ∨ q) ⇒ p$}
For this subgoal, its respective \TSTP derivation is
the following:

\begin{verbatim}
  fof(premise, axiom, (p ⇒ q) ∧ (q ⇒ p)).
  fof(goal, conjecture, (p ∨ q) ⇒ (p ∧ q))).
  fof(s₁, (p ∨ q) ⇒ p, inf(strip, goal)).
  ...
  fof(neg₁, ¬ ((p ∨ q) ⇒ p), inf(negate, s₁)).
  fof(n₀₀, (¬ p ∨ q) ∧ (¬ q ∨ p), inf(canonicalize, premise)).
  fof(n₀₁, ¬ q ∨ p, inf(conjunct, n₀₀)).
  fof(n₀₂, ¬ p ∧ (p ∨ q), inf(canonicalize, neg₁)).
  fof(n₀₃, p ∨ q, inf(conjunct, n₀₂)).
  fof(n₀₄, ¬ p, inf(conjunct, n₀₂)).
  fof(n₀₅, q, inf(simplify,[n₀₃, n₀₄])).
  cnf(r₀₀, ¬ q ∨ p, inf(canonicalize, n₀₁)).
  cnf(r₀₁, q, inf(canonicalize, n₀₅)).
  cnf(r₀₂, p, inf(resolve, q, [r₀₁, r₀₀])).
  cnf(r₀₃, ¬ p, inf(canonicalize, n₀₄)).
  cnf(r₀₄, ⊥, inf(resolve, p, [r₀₂, r₀₃])).
  ...
\end{verbatim}

The refutation tree is the following:

\begin{center}
\begin{scprooftree}{0.85}
\AxiomC{$\mathcal{D}_1$}
\UnaryInfC{$Γ, \neg s_1 ⊢ \neg q ∨ p$}

\AxiomC{$\mathcal{D}_2$}
\UnaryInfC{$Γ, \neg s_1 ⊢ p ∨ q$}
%
\AxiomC{$\mathcal{D}_3$}
\UnaryInfC{$Γ, \neg s_1 ⊢ \neg p$}
%
%\LeftLabel{$(\mathcal{D}_4)$\hspace{1.5cm}}
\RightLabel{Theorem~\ref{thm:simplify}}
\BinaryInfC{$Γ, \neg s_1 ⊢ q$}
\RightLabel{Theorem~\ref{thm:resolve}~with $ℓ = q$}
\BinaryInfC{$Γ, \neg s_1 ⊢ p$}
\RightLabel{}
%\AxiomC{$\mathcal{D}_3$}
\AxiomC{}
\RightLabel{assume $\neg s_1$}
\UnaryInfC{$Γ, \neg s_1 ⊢ \neg s_1$}
% \UnaryInfC{$Γ, \neg s_1 ⊢ (p ∨ q) ⇒ p$}
%\LeftLabel{$(\mathcal{D}_3)$\hspace{1.5cm}}
\RightLabel{Theorem~\ref{thm:canonicalize}}
\UnaryInfC{$Γ, \neg s_1 ⊢ \neg p ∧ (p ∨ q)$}
\RightLabel{Theorem~\ref{thm:conjunct}}
\UnaryInfC{$Γ, \neg s_1 ⊢ \neg p$}
\RightLabel{Theorem~\ref{thm:resolve}~with $ℓ = p$}
\LeftLabel{$(\mathcal{R}_{1})$\hspace{3cm}}
\BinaryInfC{$Γ, \neg s_1 ⊢ \bot$}
\RightLabel{RAA}
\UnaryInfC{$Γ ⊢ s_1$}
\end{scprooftree}
\end{center}

\begin{equation*}
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{axiom $a_1$}
  \UnaryInfC{$Γ ⊢ (p ⇒ q) ∧ (q ⇒ p)$}
  \RightLabel{weaken}
  \UnaryInfC{$Γ, \neg s_1 ⊢ (p ⇒ q) ∧ (q ⇒ p)$}
  \LeftLabel{$(\mathcal{D}_1)$\hspace{2cm}}
  \RightLabel{Theorem~\ref{thm:canonicalize}}
  \UnaryInfC{$Γ, \neg s_1 ⊢ (\neg p ∨ q) ∧ (\neg q ∨ p)$}
  \RightLabel{Theorem~\ref{thm:conjunct}}
  \UnaryInfC{$Γ, \neg s_1 ⊢ \neg q ∨ p$}
\end{bprooftree}
\end{equation*}

\begin{equation*}
\begin{bprooftree}
\AxiomC{}
\RightLabel{assume}
\UnaryInfC{$Γ, \neg s_1 ⊢ \neg s_1$}
\LeftLabel{$(\mathcal{D}_2)$\hspace{3cm}}
\RightLabel{Theorem~\ref{thm:canonicalize}}
\UnaryInfC{$Γ, \neg s_1 ⊢ \neg p ∧ (p ∨ q)$}
\RightLabel{Theorem~\ref{thm:conjunct}}
\UnaryInfC{$Γ, \neg s_1 ⊢ p ∨ q$}
\end{bprooftree}
\end{equation*}

\begin{equation*}
\begin{bprooftree}
\AxiomC{}
\RightLabel{assume $\neg s_1$}
\UnaryInfC{$Γ, \neg s_1 ⊢ \neg s_1$}
% \UnaryInfC{$Γ, \neg s_1 ⊢ (p ∨ q) ⇒ p$}
\LeftLabel{$(\mathcal{D}_3)$\hspace{3cm}}
\RightLabel{Theorem~\ref{thm:canonicalize}}
\UnaryInfC{$Γ, \neg s_1 ⊢ \neg p ∧ (p ∨ q)$}
\RightLabel{Theorem~\ref{thm:conjunct}}
\UnaryInfC{$Γ, \neg s_1 ⊢ \neg p$}
\end{bprooftree}
\end{equation*}



\subsection{Refutation tree for the subgoal $s₂$: $((p ∨ q) ∧ p) ⇒ q$}

For this subgoal, its respective \TSTP derivation is
the following:

\begin{verbatim}
  fof(premise, axiom, (p ⇒ q) ∧ (q ⇒ p)).
  ...
  fof(s₂, ((p ∨ q) ∧ p) ⇒ q, inf(strip, goal)).
  ...
  fof(neg₂, ¬ (((p ∨ q) ∧ p) ⇒ q), inf(negate, s₂)).
  fof(n₁₀, ¬ q ∧ p ∧ (p ∨ q), inf(canonicalize, neg₂)).
  fof(n₁₁, (¬ p ∨ q) ∧ (¬ q ∨ p), inf(canonicalize, premise)).
  fof(n₁₂, ¬ p ∨ q, inf(conjunct, n₁₁)).
  fof(n₁₃, ⊥, inf(simplify,[n₁₀, n₁₂])).
  cnf(r₁₀, ⊥, inf(canonicalize, n₁₃)).
\end{verbatim}

The refutation tree is the following:

\begin{center}
\begin{scprooftree}{0.85}
\AxiomC{}
\RightLabel{assume ($\neg s_2)$}
\UnaryInfC{$Γ,\neg s_2 ⊢ \neg s_2$}
\RightLabel{Theorem~\ref{thm:canonicalize}}
\UnaryInfC{$Γ, \neg s_2⊢ \neg q ∧ p ∧ (p ∨ q)$}
\AxiomC{}
\RightLabel{axiom $a_1$}
\UnaryInfC{$Γ ⊢ (p ⇒ q) ∧ (q ⇒ p)$}
\RightLabel{weaken}
\UnaryInfC{$Γ, \neg s_2 ⊢ (p⇒ q) ∧ (q ⇒ p)$}
\RightLabel{Theorem~\ref{thm:canonicalize}}
\UnaryInfC{$Γ, \neg s_2 ⊢ (\neg p ∨ q) ∧ (\neg q ∨ p)$}
\RightLabel{Theorem~\ref{thm:conjunct}}
\UnaryInfC{$Γ, \neg s_2 ⊢ \neg p ∨ q$}
\LeftLabel{$(\mathcal{R}_{2})$\hspace{1cm}}
\RightLabel{Theorem~\ref{thm:simplify}}
\BinaryInfC{$Γ, \neg s_2 ⊢ \bot$}
\RightLabel{RAA}
\UnaryInfC{$Γ ⊢ s_2$}
\end{scprooftree}
\end{center}

\subsection{The proof of the goal}

\begin{center}
\begin{scprooftree}{1}
\AxiomC{}
\RightLabel{Theorem~\ref{thm:strip}}
\UnaryInfC{$Γ ⊢ (s_1 ∧ s_2) ⇒ \text{goal}$}
\AxiomC{$\mathcal{R}_{1}$}
\UnaryInfC{$Γ ⊢ s_1$}
\AxiomC{$\mathcal{R}_2$}
\UnaryInfC{$Γ ⊢ s_2$}
\RightLabel{$\wedge$-intro}
\BinaryInfC{$Γ ⊢ s_1 ∧ s_2$}
\RightLabel{$⇒$-elim.}
\BinaryInfC{$Γ ⊢ \text{goal}$}
\end{scprooftree}
\end{center}

\end{subappendices}

\end{document}
