%
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Metis: Language and Proofs}
\label{sec:metis-language-and-proofs}

\Metis is an automatic theorem prover written in \len{Standard ML}
for first-order logic with equality developed by John Hurd
\cite{hurd2003first}. This prover is suitable for proof
reconstruction since it provides well-documented proof-objects to
justify its deduction steps from the basis of only six inference
rules. There are already some tools that perform proof-reconstruction
with \Metis, some of these systems are the following.

\name{Isabelle/HOL} incorporated \Metis as a macro-step
reconstruction tool for explaining proof steps (usually \CNF goals)
replied from other \ATPs like \name{CVC4}, \name{Vampire}, or
\name{Z3} (more details in Ref.~\cite{paulson2007source}).
In \cite{Farber2015}, \Metis was used to provide a tactic for
\name{HOL Light}; this challenges others like \emph{MESON}
or the \emph{leanCoP} tactic that reconstructs proofs
delivered by \name{leanCoP}~\cite{Farber2016}.

In this paper, we ported a subset of the \Metis' inference rules to
\Agda, the propositional fragmented without equality, that allows us to justify step-by-step the proofs delivered in
\TSTP format generated by the prover \Metis.

% -------------------------------------------------------------------

\subsection{Input and Output Language}
\label{ssec:input-and-output-language}

\textit{Input.}~The \TPTP language --which includes the first-order
form (denoted by \name{fof}) and clause normal form (denoted by
\name{cnf}) formats~\cite{sutcliffe2009} -- is de facto input
standard language to encode problems for many \ATPs. The \TPTP
syntax describes a well-defined grammar to handle annotated formulas
with the following form.

\begin{verbatim}
language(name, role, formula).
\end{verbatim}

The \name{language} can be \name{fof} or \name{cnf}. The \name{name}
serves to identify the formula within the problem. Each formula
assumes one \name{role}, this could be an \name{axiom},
\name{conjecture}, \name{definition}, or a \name{hypothesis}.
The formulas include Boolean connectives (\verb!&!, \verb!|!,
\verb!=>!, \verb!<=>!, \verb!~!) and logic constants \verb!$true!
and \verb!$false!, for the symbols (∧, ∨, ⇒, ⇔, ¬, ⊤, ⊥), respectively.

For instance, let us express the problem
$p\, \vdash \neg (p \wedge \neg p) ∨ (q \wedge \neg q)$
in \TPTP syntax as follows, declaring an \tptpaxiom $p$, and the
expected conclusion, the  \tptpconjecture
\verb!~ ((p & ~ p) | (q & ~ q))!.

\begin{verbatim}
fof(h, axiom, p).
fof(goal, conjecture, ~ ((p & ~ p) | (q & ~ q))).
\end{verbatim}

\textit{Output.}~\TSTP language is de facto output standard language
for derivations of ATPs~\cite{Sutcliffe-Schulz-Claessen-VanGelder-2006}. A \TSTP derivation
is a directed acyclic graph, a proof tree, where each leaf is a
formula from the \TPTP input. A node is a formula inferred from the
parent formulas. The root is the final derived formula. Such a
derivation is a list of annotated formulas with the form.

\begin{verbatim}
language(name, role, formula, source [,useful info]).
\end{verbatim}

The \name{source} field is an inference record with the following
pattern.

\begin{verbatim}
inference(rule, useful info, parents).
\end{verbatim}

The \name{rule} stands for the inference name; the other fields are
supporting arguments or useful information to apply the reasoning
step, and the list of parents nodes. For instance, in Fig.
\ref{fig:metis-proof-tstp}, \strip is the name of one of the
inference with no arguments and only one parent node, the
\name{goal}.

\begin{figure}
\begin{verbatim}
fof(premise, axiom, p).
fof(goal, conjecture, p).
fof(subgoal_0, plain, p, inference(strip, [], [goal])).
fof(negate_0_0, plain, ~ p, inference(negate, [], [subgoal_0])).
fof(normalize_0_0, plain, ∼ p,
  inference(canonicalize, [], [negate_0_0])).
fof(normalize_0_1, plain, p,
  inference(canonicalize, [], [premise])).
fof(normalize_0_2, plain, $false,
  inference(simplify, [], [normalize_0_0, normalize_0_1]))
cnf(refute_0_0, plain, $false,
  inference(canonicalize, [], [normalize_0_2])).
\end{verbatim}
\caption{The \texttt{Metis}' \texttt{TSTP} derivation for the
problem $p\vdash p$.}
\label{fig:metis-proof-tstp}
\end{figure}

% -------------------------------------------------------------------

\subsection{Proofs}
\label{ssec:metis-proofs}

A proof-object delivered in a \Metis' proof encodes a natural
deduction proof. The deduction system uses six inference rules
\cite{hurd2003first} listed in Fig.~\ref{fig:metis-inferences}.
With these inference rules as the only valid deduction steps, \Metis
attempts to prove conjectures by refutation (see. e.g.,
\emph{falsium} in the last conclusion of the \TSTP derivation in
Fig.~\ref{fig:metis-example}).

\begin{figure}
\[
% \scalebox{0.9}{
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{axiom}
  \UnaryInfC{$C$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{assume $L$}
  \UnaryInfC{$L ∨ \neg L$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{refl $t$}
  \UnaryInfC{$t = t$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{$C$}
  \RightLabel{subst $\sigma$}
  \UnaryInfC{$\sigma\,C$}
\end{bprooftree}
\qquad
% }
\]
\[
% \scalebox{0.9}{
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{equality $L$ $p$ $t$}
  \UnaryInfC{$\neg (L[p] = t) ∨ \neg L ∨ L[ p \mapsto t]$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{$L ∨ C$}
  \AxiomC{$\neg L ∨ D$}
  \RightLabel{resolve $L$}
  \BinaryInfC{$C ∨ D$}
\end{bprooftree}
% }
\]
\caption{Inference rules of the \texttt{Metis} prover.}
\label{fig:metis-inferences}
\end{figure}

These proofs are directed acyclic graphs, trees of refutations. Each
node stands for an application of an inference rule and the leaves
in the tree represent formulas in the given problem. Each node is
labeled with a name of the inference rule (e.g., \canonicalize in
Fig.~\ref{fig:metis-example}). Each edge links a premise with one
conclusion. The proof graphs have at their root the conclusion
$⊥$, since \Metis delivers proofs by refutation.

% -------------------------------------------------------------------

\subsection{Proof Rules}
\label{ssec:proof-rules}

We noted in \TSTP derivations that \Metis does not take into account
some inference rules for the \Metis' official documentation; we
refer to the \Metis' logic kernel.
Besides the six \Metis' inference rules from the Fig.
\ref{fig:metis-inferences}, its proof-objects, the \TSTP
derivations, exhibit an entirely different set of rules.

For instance, for the propositional logic fragment without equality,
only three rules are valid from the \Metis' Logic Kernel:
\emph{assume}, \emph{axiom}, and \emph{resolve}. Nevertheless, as we
observed in \TSTP derivations, for such a propositional fragment,
\Metis uses in its deductions steps, six rules where only the
\emph{resolve} inference persists from the original list. In the
case of \resolve, it differs from its original version since, in
\TSTP, this rule has by definition an argument, a literal. The other
undocumented rules found in \TSTP derivations are: \canonicalize,
\clausify, \conjunct, \negate, \simplify, and \strip.

\begin{figure}
\centering
  \begin{bprooftree}\tt
    \AxiomC{}
    \RightLabel{negate}
    \UnaryInfC{$\neg p$}
    \RightLabel{strip}
    \UnaryInfC{$\neg p$}
    \AxiomC{}
    \RightLabel{axiom}
    \UnaryInfC{$p$}
    \RightLabel{canonicalize}
    \UnaryInfC{$p$}
    \RightLabel{simplify}
    \BinaryInfC{$⊥$}
    \RightLabel{canonicalize}
    \UnaryInfC{$⊥$}
  \end{bprooftree}
  \caption{The \Metis' proof tree for $p \vdash p$ from the
  derivation in Fig.~\ref{fig:metis-proof-tstp}}
  \label{fig:metis-example}
\end{figure}

This lack of the \Metis' documentation represents one of the first barriers to build proof-reconstruction tools since some inference rules
like \canonicalize or \simplify summarize many essential steps to deduce the conclusion, making them hard to justify and emulate
(see a comment related on the presenting of \name{Sledgehammer}
in \citeauthor{paulson2007source}~\cite{paulson2007source} and \citeauthor{Farber2015}~\cite{Farber2015}).

Henceforth, one of our main purposes with this document consists of
giving a response to these rules looking at the \Metis' source code but also reviewing a representative set of solutions generated by
\Metis for the \CPL collection of \TPTP problems~\cite{Prieto-Cubides2017} including some problem from the \Metis repository itself.

In the following, we briefly describe each \Metis' rule from our perspective, but we present a formal description for each rule in Section \ref{sec:proof-reconstruction}.

\vskip 2mm

% ...................................................................

\textit{Splitting}. To prove a goal, \Metis splits the goal into
disjoint cases. This process produces a list of new subgoals, the
conjunction of these subgoals implies the goal. Then, a proof of the
goal becomes in smaller proofs, one refutation for each subgoal.
These subgoals are introduced in the \TSTP derivation with the \strip
inference rule. We refer the reader to see Section~\ref{sssec:splitting-goal} for the formalization of \strip rule.

\begin{verbatim}
fof(goal, conjecture, p & r & q).
fof(subgoal_0, plain, p, inference(strip, [], [goal])).
fof(subgoal_1, plain, p => r, inference(strip, [], [goal])).
fof(subgoal_2, plain, (p & r) => q, inference(strip, [], [goal])).
\end{verbatim}

% ...................................................................

\textit{Clausification.} The \clausify rule transforms a
propositional formula in clausal normal form, a conjunction
of clauses. Where a \emph{clause} is the disjunction of zero or more
literals and a \emph{literal} is an atom (positive literal) or a
negation of an atom (negative literal). Be aware this kind of conversion between one formula to its clausal normal form is not unique, and \Metis has a customized approach to perform that transformation. We refer the reader to see Section~\ref{sssec:clausification} for the formalization of \clausify rule.

\vskip 2mm

% ...................................................................

\textit{Normalization.} We observed \clausify rule described above is preceded by \canonicalize rule when \Metis introduces at some point of the derivation an axiom or a definition of the problem. In that case, both rules aim to perform a common task for
automatic theorem provers, Clausification, mainly described on paper
by \citeauthor{Sutcliffe1996}~\cite{Sutcliffe1996}. When the
aforementioned case does not occur we argue \canonicalize transforms
proposition into another one that mainly matches with its negative
normal form, its conjunctive normal form or its disjunctive normal
form. In addition, \canonicalize could also perform other tasks like
removing logic constants (⊥, ⊤), definitions, and tautologies, or even reorder both conjunctions and disjunctions of the proposition.

For instance, assuming the commutative properties for both
connectives, conjunction and disjunction, and using the theorems
in Fig.~\ref{fig:conjunctive-disjunctive-simpl}, \canonicalize could
use them to reduce a proposition to a one smaller by applying
recursively on the structure of the formula those theorems.
We refer the reader to see Section~\ref{sssec:normalization} to continue our approach to emulate this rule.

\begin{figure}
\[%\scalebox{0.9}{
  \begin{bprooftree}
    \AxiomC{$φ ∧ ⊥$}
    \UnaryInfC{$⊥$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$φ ∧ ⊤$}
    \UnaryInfC{$φ$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$φ ∧ ¬ φ$}
    \UnaryInfC{$⊥$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$φ ∧ φ$}
    \UnaryInfC{$φ$}
  \end{bprooftree}
%}
\]

\[%\scalebox{0.9}{
  \begin{bprooftree}
    \AxiomC{$φ ∨ ⊥$}
    \UnaryInfC{$φ$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$φ ∨ ⊤$}
    \UnaryInfC{$⊤$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$φ ∨ ¬ φ$}
    \UnaryInfC{$⊤$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$φ ∨ φ$}
    \UnaryInfC{$φ$}
  \end{bprooftree}
%}
\]
\caption{Definitions for conjunction and disjunction simplification
in the \canonicalize inference.}
\label{fig:conjunctive-disjunctive-simpl}
\end{figure}

% ...................................................................
\vskip 2mm

\textit{Resolution.} The \resolve rule incorporates  the resolution theorem showed in Fig.~\ref{fig:metis-inferences} with
three arguments: a positive literal $l$ to apply the resolution theorem, and two derivations, $\mathcal{D}₁$ and $\mathcal{D}₂$.

The positive literal $l$ must occur in
the formula from the first derivation $\mathcal{D}₁$, and the
negative literal must occur in the formula from the second derivation $\mathcal{D}₂$ (see the pattern in \Metis' logic core for the \emph{resolve} rule in Fig.~\ref{fig:metis-inferences}).
We refer the reader to see Section~\ref{sssec:resolve} for the formalization of the \resolve rule.

\begin{verbatim}
cnf(refute_0_0, plain, p | q,
  inference(canonicalize, [], [normalize_0_0])).
cnf(refute_0_1, plain, ~ p,
  inference(canonicalize, [], [normalize_0_4])).
cnf(refute_0_2, plain, q,
  inference(resolve, [$cnf(p)], [refute_0_0, refute_0_1])).
\end{verbatim}

% ...................................................................

\textit{Splitting a conjunct.} The \conjunct rule extracts from a
conjunction one of its conjuncts; it is a generalization of the
projection rules for the conjunction connective as the
following \TSTP derivation shows.
We refer the reader to see Theorem~\ref{thm:thm-conjunct}
in Section~\ref{sssec:splitting-a-conjunct} for its formalization.

\begin{verbatim}
fof(normalize_1, plain, p & q & r,
  inference(canonicalize, [], [x])).
fof(normalize_2, plain, q,
  inference(conjunct, [], [normalize_1])).
\end{verbatim}

\textit{Negate.}
Each subgoal proof is a refutation, thereby each proof assumes
the negation of its subgoal. The \negate rule
assumes the negation of a given subgoal. This rules always
appears after applies the \strip inference to the goal.

\begin{verbatim}
fof(subgoal_0, plain, p,
  inference(strip, [], [goal])).
fof(negate_0_0, plain, ~ p,
  inference(negate, [], [subgoal_0])).
\end{verbatim}

% ...................................................................

\textit{Simplification.}
The \simplify rule is an inference that performs simplification of
definitions and tautologies. This rule
transverses a list of formulas by applying different theorems (e.g.,
\emph{modus pones}, \emph{modus tollens}, or \emph{disjunctive
syllogism}) including the list of theorems used by \canonicalize in
Fig. \ref{fig:conjunctive-disjunctive-simpl} and the resolution
theorem of the \resolve rule.
We refer the reader to see Section~\ref{sssec:simplify}.

\end{document}
