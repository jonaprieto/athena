% % -*- root: main.tex -*-
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Metis: Language and Proofs}
\label{sec:metis-language-and-proofs}

\Metis is an automatic theorem prover written in \len{Standard ML}
for first-order logic with equality developed by John Hurd
\cite{hurd2003first}. This prover is suitable for proof
reconstruction since it provides well-documented proof-objects to
justify its deduction steps from the basis of only six inference
rules. There are already some tools that perform proof-reconstruction
with \Metis, some of these systems are the following.

\name{Isabelle/HOL} incorporated \Metis as a macro-step
reconstruction tool for explaining proof steps (usually \CNF goals)
replied from other \ATPs like \name{CVC4}, \name{Vampire}, or
\name{Z3} (more details in Ref.~\cite{paulson2007source}).
In \cite{Farber2015}, \Metis was used to provide a tactic for
\name{HOL Light}; this challenges others like \emph{MESON}
or the \emph{leanCoP} tactic that reconstructs proofs
delivered by \name{leanCoP}~\cite{Farber2016}.

In this paper, we ported a subset of the \Metis' inference rules to
\Agda, the propositional fragmented without equality.
That allows us to justify step-by-step the proofs delivered in
\TSTP format generated by the prover \Metis.

% -------------------------------------------------------------------

\subsection{Input and Output Language}
\label{ssec:input-and-output-language}

\textit{Input.}~The \TPTP language --which includes the first-order
form (denoted by \name{fof}) and clause normal form (denoted by
\name{cnf}) formats~\cite{sutcliffe2009} -- is de facto input
standard language to encode problems for many \ATPs. The \TPTP
syntax describes a well-defined grammar to handle annotated formulas
with the following form.

\begin{verbatim}
language(name, role, formula).
\end{verbatim}

The \name{language} can be \name{fof} or \name{cnf}. The \name{name}
serves to identify the formula within the problem. Each formula
assumes one \name{role}, this could be an \name{axiom},
\name{conjecture}, \name{definition}, or a \name{hypothesis}.
The formulas include Boolean connectives (\verb!&!, \verb!|!,
\verb!=>!, \verb!<=>!, \verb!~!) and logic constants \verb!$true!
and \verb!$false!, for the symbols (∧, ∨, ⇒, ⇔, ¬, ⊤, ⊥), respectively.

For instance, let us express the problem
$p\, \vdash \neg (p \wedge \neg p) \vee (q \wedge \neg q)$
in \TPTP syntax as follows, declaring an \tptpaxiom $p$, and the
expected conclusion, the  \tptpconjecture
\verb!~ ((p & ~ p) | (q & ~ q))!.

\begin{verbatim}
fof(h, axiom, p).
fof(goal, conjecture, ~ ((p & ~ p) | (q & ~ q))).
\end{verbatim}

\textit{Output.}~\TSTP language is de facto output standard language
for derivations of ATPs~\cite{sutcliffe2004tstp}. A \TSTP derivation
is a directed acyclic graph, a proof tree, where each leaf is a
formula from the \TPTP input. A node is a formula inferred from the
parent formulas. The root is the final derived formula. Such a
derivation is a list of annotated formulas with the form.

\begin{verbatim}
language(name, role, formula, source [,useful info]).
\end{verbatim}

The \name{source} field is an inference record with the following
pattern.

\begin{verbatim}
inference(rule, useful info, parents).
\end{verbatim}

The \name{rule} stands for the inference name; the other fields are
supporting arguments or useful information to apply the reasoning
step, and the list of parents nodes. For instance, in Fig.
\ref{fig:metis-proof-tstp}, \strip is the name of one of the
inference with no arguments and only one parent node, the
\name{goal}.

\begin{figure}
\begin{verbatim}
fof(premise, axiom, p).
fof(goal, conjecture, p).
fof(subgoal_0, plain, p, inference(strip, [], [goal])).
fof(negate_0_0, plain, ~ p, inference(negate, [], [subgoal_0])).
fof(normalize_0_0, plain, ∼ p,
  inference(canonicalize, [], [negate_0_0])).
fof(normalize_0_1, plain, p,
  inference(canonicalize, [], [premise])).
fof(normalize_0_2, plain, $false,
  inference(simplify, [], [normalize_0_0, normalize_0_1]))
cnf(refute_0_0, plain, $false,
  inference(canonicalize, [], [normalize_0_2])).
\end{verbatim}
\caption{The \texttt{Metis}' \texttt{TSTP} derivation for the
problem $p\vdash p$.}
\label{fig:metis-proof-tstp}
\end{figure}

% -------------------------------------------------------------------

\subsection{Proofs}
\label{ssec:metis-proofs}

A proof-object delivered in a \Metis' proof encodes a natural
deduction proof. The deduction system uses six inference rules
\cite{hurd2003first} listed in Fig.~\ref{fig:metis-inferences}.
With these inference rules as the only valid deduction steps, \Metis
attempts to prove conjectures by refutation (see. e.g.,
\emph{falsium} in the last conclusion of the \TSTP derivation in
Fig.~\ref{fig:metis-example}).

\begin{figure}
\[
% \scalebox{0.9}{
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{axiom}
  \UnaryInfC{$C$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{assume $L$}
  \UnaryInfC{$L \vee \neg L$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{refl $t$}
  \UnaryInfC{$t = t$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{$C$}
  \RightLabel{subst $\sigma$}
  \UnaryInfC{$\sigma\,C$}
\end{bprooftree}
\qquad
% }
\]
\[
% \scalebox{0.9}{
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{equality $L$ $p$ $t$}
  \UnaryInfC{$\neg (L[p] = t) \vee \neg L \vee L[ p \mapsto t]$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{$L \vee C$}
  \AxiomC{$\neg L \vee D$}
  \RightLabel{resolve $L$}
  \BinaryInfC{$C \vee D$}
\end{bprooftree}
% }
\]
\caption{Inference rules of the \texttt{Metis} prover.}
\label{fig:metis-inferences}
\end{figure}

These proofs are directed acyclic graphs, trees of refutations. Each
node stands for an application of an inference rule and the leaves
in the tree represent formulas in the given problem. Each node is
labeled with a name of the inference rule (e.g., \canonicalize in
Fig.~\ref{fig:metis-example}). Each edge links a premise with one
conclusion. The proof graphs have at their root the conclusion
$\bot$, since \Metis delivers proofs by refutation.

% -------------------------------------------------------------------

\subsection{Proof Rules}
\label{ssec:proof-rules}

We noted in \TSTP derivations that \Metis does not take into account
some inference rules for the \Metis' official documentation; we
refer to the \Metis' logic kernel.
Besides the six \Metis' inference rules from the Fig.
\ref{fig:metis-inferences}, its proof-objects, the \TSTP
derivations, exhibit an entirely different set of rules.

For instance, for the propositional logic fragment without equality,
only three rules are valid from the \Metis' Logic Kernel:
\emph{assume}, \emph{axiom}, and \emph{resolve}. Nevertheless, as we
observed in \TSTP derivations, for such a propositional fragment,
\Metis uses in its deductions steps, six rules where only the
\emph{resolve} inference persists from the original list. In the
case of \resolve, it differs from its original version since, in
\TSTP, this rule has by definition an argument, a literal. The other
undocumented rules found in \TSTP derivations are: \canonicalize,
\clausify, \conjunct, \negate, \simplify, and \strip.

\begin{figure}
\centering
\begin{bprooftree}\tt
  \AxiomC{}
  \RightLabel{\footnotesize negate}
  \UnaryInfC{$\neg p$}
  \RightLabel{\footnotesize strip}
  \UnaryInfC{$\neg p$}
  \AxiomC{}
  \RightLabel{\footnotesize axiom}
  \UnaryInfC{$p$}
  \RightLabel{\footnotesize canonicalize}
  \UnaryInfC{$p$}
  \RightLabel{\footnotesize simplify}
  \BinaryInfC{$\bot$}
  \RightLabel{\footnotesize canonicalize}
  \UnaryInfC{$\bot$}
\end{bprooftree}
\caption{The \Metis' proof tree for $p \vdash p$ from the
derivation in Fig.~\ref{fig:metis-proof-tstp}}
\label{fig:metis-example}
\end{figure}

This lack of the \Metis' documentation is an important matter for
us in the proof-reconstruction and certainty for other implementors
(see a comment related on the presenting of \name{Sledgehammer}
in \cite{paulson2007source} and \cite{Farber2015}). We faced
the ambiguity and lack of clearness of some rules like \canonicalize
or \simplify.
For example, we believe by applying these last
inferences, \Metis summarized many essential steps to deduce a
formula from a list of formulas.
\improvement{Add an example here to show a deduction where \Metis do
a lot between two steps.}
That inference's behavior is a drawback since, our approach
to reconstruct proofs needs take into account any assumption or
consideration as ordering for literals, application of
simplification theorems, reductions, among other valid
transformations.

\unsure{Should I give an Example?}

In this part, our main purpose consists of giving a response to
these rules looking at the \Metis' source code while inspecting a
representative set of solutions of \CPL problems
\cite{Prieto-Cubides2017} generated by \Metis.
This is an attempt to fulfill the \Metis's documentation, by
describing each rule from our perspective. Later on, in Section
\ref{sec:proof-reconstruction}, we present a formal description of
such rules.

\vskip 2mm

% ...................................................................

\textit{Splitting}. To prove a goal, \Metis splits the goal into
disjoint cases. This process produces a list of new subgoals, the
conjunction of these subgoals implies the goal as we show later in
subsection~\ref{ssec:emulating-inferences}. Then, a proof of the
goal becomes in smaller proofs, one refutation for each subgoal.
These subgoals are introduced in the \TSTP derivation with the \strip
inference rule.

\begin{verbatim}
fof(goal, conjecture, p & r & q).
fof(subgoal_0, plain, p, inference(strip, [], [goal])).
fof(subgoal_1, plain, p => r, inference(strip, [], [goal])).
fof(subgoal_2, plain, (p & r) => q, inference(strip, [], [goal])).
\end{verbatim}

% ...................................................................

\textit{Clausification.} The \clausify rule transforms a
propositional formula in clausal normal form or \CNF, a conjunction
of clauses. Where a clause is the disjunction of zero or more
literals and a literal is an atom (positive literal) or a negation
of an atom (negative literal). This conversion is not unique, and
\Metis performs this transformation using its criteria.
\improvement{We should mention that it was indeed a problem for the
proof-reconstruction? and refer the section next?}

% ...................................................................

\textit{Normalization.} \Metis uses the \canonicalize rule to
normalize a propositional formula that comes from an axiom or a
definition. It often converts each expression in one of its normal
form: the conjunctive normal form, the negative normal form or the
disjunctive normal form. Next, this rule simplifies the formula
with some definitions, applying recursively on the structure's
formula conjunctions and disjunctions simplifications to remove
tautologies (see Fig.~\ref{fig:conjunctive-disjunctive-simpl} for a
list of these theorems. We assume the commutative property for the
conjunction and disjunction connectives).

\begin{figure}
\[%\scalebox{0.9}{
  \begin{bprooftree}
    \AxiomC{$\varphi \wedge \bot$}
    \UnaryInfC{$\bot$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$\varphi \wedge \top$}
    \UnaryInfC{$\varphi$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$\varphi \wedge \neg \varphi$}
    \UnaryInfC{$\bot$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$\varphi \wedge \varphi$}
    \UnaryInfC{$\varphi$}
  \end{bprooftree}
%}
\]

\[%\scalebox{0.9}{
  \begin{bprooftree}
    \AxiomC{$\varphi \vee \bot$}
    \UnaryInfC{$\varphi$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$\varphi \vee \top$}
    \UnaryInfC{$\top$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$\varphi \vee \neg \varphi$}
    \UnaryInfC{$\top$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$\varphi \vee \varphi$}
    \UnaryInfC{$\varphi$}
  \end{bprooftree}
%}
\]
\caption{Definitions for conjunction and disjunction simplification
in the \canonicalize inference.}
\label{fig:conjunctive-disjunctive-simpl}
\end{figure}

% ...................................................................

\textit{Resolution.} The \resolve rule is the resolution theorem
showed in Fig.~\ref{fig:metis-inferences}. For its application, we
need the positive literal for resolution and two derivations to
deduce the \emph{resolvent}. The positive literal $p$ must occur in
the formula from the first derivation, and the negative literal must
occur in the formula from the second derivation (this follows the
same pattern in \Metis' logic core in Fig.~\ref{fig:metis-inferences}
for the resolve inference).

\begin{verbatim}
cnf(refute_0_0, plain, p | q,
  inference(canonicalize, [], [normalize_0_0])).
cnf(refute_0_1, plain, ~ p,
  inference(canonicalize, [], [normalize_0_4])).
cnf(refute_0_2, plain, q,
  inference(resolve, [$cnf(p)], [refute_0_0, refute_0_1])).
\end{verbatim}

% ...................................................................

\textit{Splitting a conjunct.} The \conjunct rule extracts from a
conjunction one of its conjuncts; it is a generalization of the
projection rules for the conjunction connective as the
following \TSTP derivation shows.

\begin{verbatim}
fof(normalize_1, plain, p & q & r,
  inference(canonicalize, [], [x])).
fof(normalize_2, plain, q,
  inference(conjunct, [], [normalize_1])).
\end{verbatim}

\textit{Negate.}
Each subgoal proof is a refutation, thereby each proof assumes
the negation of its subgoal. The \negate rule
introduces the negation of a subgoal that results
after applies the \strip inference to the goal.

\begin{verbatim}
fof(subgoal_0, plain, p,
  inference(strip, [], [goal])).
fof(negate_0_0, plain, ~ p,
  inference(negate, [], [subgoal_0])).
\end{verbatim}

% ...................................................................

\textit{Simplification.}
The \simplify rule is an inference that performs simplification of
definitions or tautologies over a list of derivations. This rule
transverses a list of formulas by applying different theorems (e.g.,
\emph{modus pones}, \emph{modus tollens}, or \emph{disjunctive
syllogism}) including the list of theorems used by \canonicalize in
Fig. \ref{fig:conjunctive-disjunctive-simpl} and the resolution
theorem of the \resolve rule.

Moreover, we are not completely sure about the exact behavior for
all \Metis' inference rules. It is somewhat complicated to grasp it
completely since the source code is around the 10.000 lines of code.

\end{document}