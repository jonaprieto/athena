%
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\subsection{Metis: Language and Proofs}
\label{ssec:metis-language-and-proofs}

\Metis is an automatic theorem prover written in \len{Standard ML}
for first-order logic with equality developed by John Hurd
\cite{hurd2003first}. This prover is suitable for proof
reconstruction since it provides well-documented proof-objects to
justify its deduction steps from the basis of only six inference
rules. There are already some tools that perform proof-reconstruction
with \Metis, some of these systems are the following.

\name{Isabelle/HOL} incorporated \Metis as a macro-step
reconstruction tool for explaining proof steps (usually \CNF goals)
replied from other \ATPs like \name{CVC4}, \name{Vampire}, or
\name{Z3} (more details in Ref.~\cite{paulson2007source}).
In \cite{Farber2015}, \Metis was used to provide a tactic for
\name{HOL Light}; this challenges others like \emph{MESON}
or the \emph{leanCoP} tactic that reconstructs proofs
delivered by \name{leanCoP}~\cite{Farber2016}.

% -------------------------------------------------------------------

\subsubsection{Input Language.}
\label{ssec:input-language}

The \TPTP language --which includes the first-order
form (denoted by \name{fof}) and clause normal form (denoted by
\name{cnf}) formats~\cite{sutcliffe2009} -- is de facto input
standard language to encode problems for many \ATPs. The \TPTP
syntax describes a well-defined grammar to handle annotated formulas
with the following form.

\begin{verbatim}
language(name, role, formula).
\end{verbatim}

The \name{language} can be \name{fof} or \name{cnf}. The \name{name}
serves to identify the formula within the problem. Each formula
assumes one \name{role}, this could be an \name{axiom},
\name{conjecture}, \name{definition}, or a \name{hypothesis}.
The formulas include Boolean connectives (\verb!&!, \verb!|!,
\verb!=>!, \verb!<=>!, \verb!~!) and logic constants \verb!$true!
and \verb!$false!, for the symbols (∧, ∨, ⇒, ⇔, ¬, ⊤, ⊥), respectively.

For instance, let us express the problem
$p\, \vdash \neg (p \wedge \neg p) ∨ (q \wedge \neg q)$
in \TPTP syntax. We begin by declaring the $p$ axiom using the \verb!axiom!
keyword. Later, we include the expected conclusion using the \verb!conjecture! keyword.

\begin{verbatim}
fof(h, axiom, p).
fof(goal, conjecture, ~ ((p & ~ p) | (q & ~ q))).
\end{verbatim}

This study aimed to address proof-reconstruction for refutation
proofs. Then, we annotated \abbre{CPL} problems using \verb!fof! formulas.
\Metis converts \abbre{FOF} formulas to \abbre{CNF} clauses to look for a
refutation.

\subsubsection{Output Language.}
\label{ssec:output-language}

The \TSTP language is de facto output standard language
for derivations of ATPs~\cite{Sutcliffe-Schulz-Claessen-VanGelder-2006}.
A \TSTP derivation is a directed acyclic graph, a proof tree,
where each leaf is a formula from the \TPTP input. A node is a formula
inferred from the parent formulas. The root is the final derived formula.
Such a derivation is a list of annotated formulas with the form.

\begin{verbatim}
language(name, role, formula, source [,useful info]).
\end{verbatim}

The \name{source} field is an inference record with the following
pattern.

\begin{verbatim}
inference(rule, useful info, parents).
\end{verbatim}

The \name{rule} stands for the inference name; the other fields are
supporting arguments or useful information to apply the reasoning
step, and the list of parents nodes. For instance, in Fig.
\ref{fig:metis-proof-tstp}, \strip is the name of one of the
inference with no arguments and only one parent node, the
\name{goal}.

\begin{figure}
\begin{verbatim}
fof(premise, axiom, p).
fof(goal, conjecture, p).
fof(subgoal_0, plain, p, inference(strip, [], [goal])).
fof(negate_0_0, plain, ~ p, inference(negate, [], [subgoal_0])).
fof(normalize_0_0, plain, ∼ p,
  inference(canonicalize, [], [negate_0_0])).
fof(normalize_0_1, plain, p,
  inference(canonicalize, [], [premise])).
fof(normalize_0_2, plain, $false,
  inference(simplify, [], [normalize_0_0, normalize_0_1]))
cnf(refute_0_0, plain, $false,
  inference(canonicalize, [], [normalize_0_2])).
\end{verbatim}
\caption{The \texttt{Metis}' \texttt{TSTP} derivation for the
problem $p\vdash p$.}
\label{fig:metis-proof-tstp}
\end{figure}

\begin{figure}
\[
% \scalebox{0.9}{
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{axiom}
  \UnaryInfC{$C$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{assume $L$}
  \UnaryInfC{$L ∨ \neg L$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{refl $t$}
  \UnaryInfC{$t = t$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{$C$}
  \RightLabel{subst $\sigma$}
  \UnaryInfC{$\sigma\,C$}
\end{bprooftree}
\qquad
% }
\]
\[
% \scalebox{0.9}{
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{equality $L$ $p$ $t$}
  \UnaryInfC{$\neg (L[p] = t) ∨ \neg L ∨ L[ p \mapsto t]$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{$L ∨ C$}
  \AxiomC{$\neg L ∨ D$}
  \RightLabel{resolve $L$}
  \BinaryInfC{$C ∨ D$}
\end{bprooftree}
% }
\]
\caption{CNF Inference rules of the \texttt{Metis} prover.}
\label{fig:metis-inferences}
\end{figure}

% -------------------------------------------------------------------

\subsubsection{Proof Rules.}
\label{sssec:proof-rules}

Since the scope of the problems treated in this research is \CPL, from the list of \Metis inference rules in Fig.~\ref{fig:metis-inferences}, we found that only three rules apply: \emph{axiom}, \emph{assume} and \emph{resolve} rule.
Nonetheless, \TSTP derivations replied by \Metis use other rules. They are \canonicalize, \clausify, \conjunct, \simplify, \negate, and
\strip.

\Metis looks for a refutation to prove \verb!fof! problems.
A \verb!fof! problem contains the conjecture also named the \emph{goal} in the problem. This goal is stripped into subgoals by using the \strip rule. The subgoals are the conjuncts in a general conjunction that is equivalent to the aforementioned goal.
Therefore, to prove the goal, \Metis proves independently each subgoal since they tend to be less complex or even smaller propositions. At the end, the conjunction of all subgoal proofs must prove the goal. Nevertheless, this last reasoning is not explicit neither in the \TSTP derivations nor in the \Metis' documentation.
Since \Metis replies refutation proofs, to prove each subgoal, in the \TSTP derivation, the inference rule \negate introduces the negation of such subgoals. The \negate rule is a specification of the \emph{assume} rule.

Finally, \emph{axiom} rule appears in \TSTP derivation by one of the following rules to in the problem a \verb!fof! axiom: \canonicalize, \clausify, \conjunct, or \simplify. Then, the last rule remains is \emph{resolve}, it appears by the
binary rule, \resolve, the version in \Metis of the resolution
theorem. For a more detailed description of this rules see the Section~\ref{sec:proof-reconstruction}.

\subsubsection{Proofs.}
\label{sssec:metis-proofs}

\begin{figure}
\centering
  \begin{bprooftree}\tt
    \AxiomC{}
    \RightLabel{negate}
    \UnaryInfC{$\neg p$}
    \RightLabel{strip}
    \UnaryInfC{$\neg p$}
    \AxiomC{}
    \RightLabel{axiom}
    \UnaryInfC{$p$}
    \RightLabel{canonicalize}
    \UnaryInfC{$p$}
    \RightLabel{simplify}
    \BinaryInfC{$⊥$}
    \RightLabel{canonicalize}
    \UnaryInfC{$⊥$}
  \end{bprooftree}
  \caption{The \Metis' proof tree for $p \vdash p$ from the
  derivation in Fig.~\ref{fig:metis-proof-tstp}}
  \label{fig:metis-example}
\end{figure}

A proof-object delivered in a \Metis' proof encodes a natural
deduction proof. The deduction system uses six inference rules
\cite{hurd2003first} listed in Fig.~\ref{fig:metis-inferences}.
With these inference rules as the only valid deduction steps, \Metis
attempts to prove conjectures by refutation (see. e.g.,
\emph{falsium} in the last conclusion of the \TSTP derivation in
Fig.~\ref{fig:metis-example}).

These proofs are directed acyclic graphs, trees of refutations. Each
node stands for an application of an inference rule and the leaves
in the tree represent formulas in the given problem. Each node is
labeled with a name of the inference rule (e.g., \canonicalize in
Fig.~\ref{fig:metis-example}). Each edge links a premise with one
conclusion. The proof graphs have at their root the conclusion
$⊥$, since \Metis delivers proofs by refutation.

\end{document}
