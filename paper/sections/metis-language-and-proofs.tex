%
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Metis: Language and Proofs}
\label{sec:metis-language-and-proofs}

\Metis is an automatic theorem prover written in \len{ML}
for first-order logic with equality developed by John Hurd
\cite{hurd2003first}. This prover is suitable for proof
reconstruction since it provides well-documented proofs
to justify its deduction steps from the basis of only six inference
rules.
In Fig.~\ref{fig:metis-inferences}, we show the three \Metis rules for
propositional logic.

\begin{figure}
\begin{equation*}
  \begin{bprooftree}
    \AxiomC{}
    \RightLabel{axiom}
    \UnaryInfC{$Γ ⊢ φ$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{}
    \RightLabel{assume $L$}
    \UnaryInfC{$Γ ⊢ φ ∨ ¬ φ$}
  \end{bprooftree}
  \end{equation*}
  \vskip2mm
  \begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ l ∨ φ$}
    \AxiomC{$Γ ⊢ ¬ l ∨ ψ$}
    \RightLabel{resolve $l$}
    \BinaryInfC{$Γ ⊢ φ ∨ ψ$}
  \end{bprooftree}
\end{equation*}
\caption{CPL inference rules of the \texttt{Metis} prover.}
\label{fig:metis-inferences}
\end{figure}

% -------------------------------------------------------------------

\subsection{Input language}
\label{ssec:input-language}

The \TPTP language --which includes the first-order
form (denoted by \name{fof}) and clause normal form (denoted by
\name{cnf}) formats~\cite{sutcliffe2009,Sicard-Ramirez2016} -- is the
input language to encode problems used by \Metis.
The \TPTP syntax describes a well-defined grammar to handle annotated
formulas with the following form.

\begin{verbatim}
language(name, role, formula).
\end{verbatim}

The \name{language} can be \name{fof} or \name{cnf}. The \name{name}
serves to identify the formula within the problem. Each formula
assumes a \name{role}, this could be an \name{axiom},
\name{conjecture}, \name{definition}, or a \name{hypothesis}.
%existen otros
%----Keywords:    fof cnf thf tff include
%----Punctuation: ( ) , . [ ] :
%----Operators:   ! ? ~ & | <=> => <= <~> ~| ~& * +
%----Predicates:  = != $true $false

%----Top of Page---------------------------------------------------------------
%----CNF formulae (variables implicitly universally quantified)
% <cnf_formula>          ::= <disjunction> | (<disjunction>)
% <disjunction>          ::= <literal> | <disjunction> <vline> <literal>
% <literal>              ::= <fof_atomic_formula> | ~ <fof_atomic_formula> |
%                            <fof_infix_unary>
The formulas include the binary Boolean connectives
(\verb!&!, \verb!|!, \verb!=>!, \verb!<=>!, \verb!~!) and logic constants \verb!$true!
% the boolean type ($true and $false)
and \verb!$false!, for the symbols (∧, ∨, ⇒, ⇔, ¬, ⊤, ⊥), respectively.

For instance, let us express the problem
$p\, \vdash \neg (p \wedge \neg p) ∨ (q \wedge \neg q)$
in \TPTP syntax. We begin by declaring the $p$ axiom using the \verb!axiom!
keyword. Later, we include the expected conclusion using the \verb!conjecture!
keyword.

\begin{verbatim}
fof(h, axiom, p).
fof(goal, conjecture, ~ ((p & ~ p) | (q & ~ q))).
\end{verbatim}

This study aimed to address proof-reconstruction for refutation
proofs. Then, we annotated \abbre{CPL} problems using \verb!fof! formulas.
\Metis converts \abbre{FOF} formulas to \abbre{CNF} clauses to look for a
refutation.

\subsection{Output language}
\label{ssec:output-language}

The \TSTP language is de facto output standard language
for derivations of ATPs~\cite{Sutcliffe-Schulz-Claessen-VanGelder-2006,Sicard-Ramirez2016}.
A \TSTP derivation is a directed acyclic graph, a proof tree,
where each leaf is a formula from the \TPTP input. A node is a formula
inferred from the parent formulas. The root is the final derived formula,
such a derivation is a list of annotated formulas with the form.

\begin{verbatim}
language(name, role, formula, source [,useful info]).
\end{verbatim}

The \name{source} field is an inference record with the following
pattern.

\begin{verbatim}
inference(rule, useful info, parents).
\end{verbatim}

The \name{rule} stands for the inference name; the other fields are
supporting arguments or useful information to apply the reasoning
step, and the list of parents nodes.

\begin{verbatim}
fof(subgoal_0, plain, p, inference(strip, [], [goal])).
\end{verbatim}

In the script above, \strip is for example the name of the inference.
It has no arguments and derives from one parent node with goal name.
\name{goal}.


% -------------------------------------------------------------------

\subsection{Inference rules}
\label{ssec:metis-inferences-rules}

% \TSTP derivations replied by \Metis use other rules. They are
% \canonicalize, \clausify, \conjunct, \simplify, \negate, and \strip.

% \Metis looks for a refutation to prove \verb!fof! problems.
% A \verb!fof! problem contains the conjecture, the \emph{goal}, in the
% problem. This goal is stripped into subgoals by using the \strip rule. The
% subgoals are the conjuncts in a general conjunction that is equivalent to the
% aforementioned goal.
% Therefore, to prove the goal, \Metis proves independently each subgoal since
% they tend to be less complex or even fewer propositions. At the end, the
% conjunction of all subgoal proofs must prove the goal. Nevertheless, this last
% reasoning is not explicit neither in the \TSTP derivations nor in the
% documentation available about \Metis.
% Since \Metis replies refutation proofs, to prove each subgoal, in the \TSTP
% derivation, the inference rule \negate introduces the negation of such
% subgoals. The \negate rule is a specification of the \emph{assume} rule.

Finally, \emph{axiom} rule appears in \TSTP derivations by using one of the following rules: \canonicalize, \clausify, \conjunct, or \simplify.
Then, the last rule remains is \emph{resolve}, it
appears by the binary rule, \resolve, the version in \Metis of the resolution
theorem. For a more detailed description of this rules see Section~\ref{sec:proof-reconstruction}.

\subsection{Proofs.}
\label{ssec:metis-proofs}

\begin{figure}
\begin{verbatim}
fof(premise, axiom, p).
fof(goal, conjecture, p).
fof(subgoal_0, plain, p, inference(strip, [], [goal])).
fof(negate_0_0, plain, ~ p, inference(negate, [], [subgoal_0])).
fof(normalize_0_0, plain, ∼ p,
  inference(canonicalize, [], [negate_0_0])).
fof(normalize_0_1, plain, p,
  inference(canonicalize, [], [premise])).
fof(normalize_0_2, plain, $false,
  inference(simplify, [], [normalize_0_0, normalize_0_1]))
cnf(refute_0_0, plain, $false,
  inference(canonicalize, [], [normalize_0_2])).
\end{verbatim}
\caption{\texttt{Metis}' \texttt{TSTP} derivation for the
problem $p\vdash p$.}
\label{fig:metis-proof-tstp}
\end{figure}

\begin{figure}
\centering
  \begin{bprooftree}\tt
    \AxiomC{}
    \RightLabel{negate}
    \UnaryInfC{$\neg p$}
    \RightLabel{strip}
    \UnaryInfC{$\neg p$}
    \AxiomC{}
    \RightLabel{axiom}
    \UnaryInfC{$p$}
    \RightLabel{canonicalize}
    \UnaryInfC{$p$}
    \RightLabel{simplify}
    \BinaryInfC{$⊥$}
    \RightLabel{canonicalize}
    \UnaryInfC{$⊥$}
  \end{bprooftree}
  \caption{\Metis' proof tree for $p \vdash p$. Derivation in Fig.~\ref{fig:metis-proof-tstp}}
  \label{fig:metis-example}
\end{figure}

The output of a proof delivered by \Metis encodes a natural
deduction proof. The deduction system uses six inference rules
\cite{hurd2003first} listed in Fig.~\ref{fig:metis-inferences}.
With these inference rules as the only valid deduction steps, \Metis
attempts to prove conjectures by refutation (e.g.,
\emph{falsium} in the last conclusion of the \TSTP derivation in
Fig.~\ref{fig:metis-example}).

These proofs are directed acyclic graphs, trees of refutations. Each
node stands for an application of an inference rule and the leaves
in the tree represent formulas in the given problem. Each node is
labeled with a name of the inference rule (e.g., \canonicalize in
Fig.~\ref{fig:metis-example}). Each edge links a premise with one
conclusion. The proof graphs have at their root the conclusion
$⊥$, since \Metis delivers proofs by refutation.

\end{document}
