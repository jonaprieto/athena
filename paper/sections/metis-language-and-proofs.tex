%
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Metis: Language and Proofs}
\label{sec:metis-language-and-proofs}

\Metis is an automatic theorem prover written in \len{ML}
for first-order logic with equality developed by John Hurd
\cite{hurd2003first}. This prover is suitable for proof
reconstruction since it provides well-documented proofs
to justify its deduction steps from the basis of only six inference
rules. In Fig.~\ref{fig:metis-inferences}, we show the three \Metis
rules for propositional logic.

\begin{figure}
\begin{equation*}
  \begin{bprooftree}
    \AxiomC{}
    \RightLabel{axiom}
    \UnaryInfC{$Γ ⊢ φ$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{}
    \RightLabel{assume $L$}
    \UnaryInfC{$Γ ⊢ φ ∨ ¬ φ$}
  \end{bprooftree}
  \end{equation*}
  \vskip2mm
  \begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ l ∨ φ$}
    \AxiomC{$Γ ⊢ ¬ l ∨ ψ$}
    \RightLabel{resolve $l$}
    \BinaryInfC{$Γ ⊢ φ ∨ ψ$}
  \end{bprooftree}
\end{equation*}
\caption{CPL inference rules of the \texttt{Metis} prover.}
\label{fig:metis-inferences}
\end{figure}

% -------------------------------------------------------------------

\subsection{Input language}
\label{ssec:input-language}

The \TPTP language is the input language to encode problems used by \Metis.
It includes the first-order form (denoted by \name{fof}) and clause normal form (denoted by \name{cnf}) formats~\cite{sutcliffe2009,Sicard-Ramirez2016}.
The \TPTP syntax describes a well-defined grammar to handle annotated
formulas with the following form:

\begin{verbatim}
language(name, role, formula).
\end{verbatim}

Where the \name{language} can be \name{fof} or \name{cnf}. The \name{name}
serves to identify the formula within the problem. Each formula
assumes a \name{role}, this could be an \name{axiom},
\name{conjecture}, \name{definition}, \name{plain} or an \name{hypothesis}.
The formulas include the constants \verb!$true!, negation unary operator (\verb!~!), and the binary connectives (\verb!&!, \verb!|!, \verb!=>!, \verb!<=>!),

\begin{myexample}
For instance, let us express the problem
$p\, \vdash \neg (p \wedge \neg p) ∨ (q \wedge \neg q)$
in \TPTP syntax. We begin by declaring the $p$ axiom using the \verb!axiom!
keyword. Later, we include the expected conclusion using the
\verb!conjecture! keyword.

  \begin{verbatim}
  fof(h, axiom, p).
  fof(goal, conjecture, ~ ((p & ~ p) | (q & ~ q))).
  \end{verbatim}

\end{myexample}

\begin{remark}
We address proof-reconstruction in this paper for refutation proofs.
We annotate \abbre{CPL} problems using \verb!fof! formulas that
\Metis converts to \abbre{CNF} clauses to look for a refutation.
\end{remark}

\subsection{Output language}
\label{ssec:output-language}

The \TSTP language is an output language for derivations of
ATPs~\cite{Sutcliffe-Schulz-Claessen-VanGelder-2006,Sicard-Ramirez2016}.
A \TSTP derivation is a directed acyclic graph, a proof tree,
where each leaf is a formula from the \TPTP input. A node is a formula
inferred from the parent formulas. The root is the final derived formula,
such a derivation is a list of annotated formulas with the following form.

\begin{verbatim}
language(name, role, formula, source [,useful info]).
\end{verbatim}

Where the \name{source} field is an inference record with the following
pattern:

\begin{verbatim}
inference(rule, useful info, parents).
\end{verbatim}

The \name{rule} in the line above stands for the inference name;
the other fields are supporting arguments or useful information to
apply the reasoning step, and list the parents nodes.

\begin{myexample}

\begin{verbatim}
fof(subgoal_0, plain, p, inference(strip, [], [goal])).
\end{verbatim}

In the script above, \strip is for example the name of the inference.
It has no arguments and derives from one parent node named  \verb!goal!. The
result of this inference when it applies to the \verb!goal! formula is
\verb!p!.

\end{myexample}

We adopt a customized \TSTP syntax to keep as short as possible the \Metis derivations for increasing the readability in this paper.

\begin{myexample}

Let us consider the following \TSTP derivation using
the customized \TSTP syntax. Note that we remove
empty fields in the inference information, we shorten names as long as possible, and we delete the \verb!role! field when the role is
\verb!plain!.

\begin{verbatim}
fof(premise, axiom, p).
fof(goal, conjecture, p).
fof(sg0, p, inf(strip, [goal])).
fof(neg0, ~ p, inf(negate, [sg0])).
fof(norm0, ∼ p, inf(canonicalize, [neg0])).
fof(norm1, p, inf(canonicalize, [premise])).
fof(norm2, $false, inf(simplify, [norm0, norm1]))
cnf(refute0, $false, inf(canonicalize, [norm2])).
\end{verbatim}

\end{myexample}

% -------------------------------------------------------------------

\subsection{Proofs}
\label{ssec:metis-proofs}

A proof delivered by \Metis encodes a natural
deduction proof.
With these inference rules as the only valid deduction steps, \Metis
attempts to prove conjectures by refutation (\eg,
\emph{falsium} in the root of the \TSTP derivation).

These proofs are directed acyclic graphs, trees of refutations
Each node stands for an application of an inference rule and the leaves
in the tree represent formulas in the given problem. Each node is
labeled with a name of the inference rule (\eg, \canonicalize).
Each edge links a premise with one conclusion.
The proof graphs have at their root the conclusion
$⊥$, since \Metis delivers proofs by refutation.

\begin{figure}[!ht]
\centering
  \begin{bprooftree}\tt
    \AxiomC{}
    \RightLabel{negate}
    \UnaryInfC{$\neg p$}
    \RightLabel{strip}
    \UnaryInfC{$\neg p$}
    \AxiomC{}
    \RightLabel{axiom}
    \UnaryInfC{$p$}
    \RightLabel{canonicalize}
    \UnaryInfC{$p$}
    \RightLabel{simplify}
    \BinaryInfC{$⊥$}
    \RightLabel{canonicalize}
    \UnaryInfC{$⊥$}
  \end{bprooftree}
  \caption{A \Metis proof tree.}
  \label{fig:metis-example}
\end{figure}

\subsection{Inference rules}
\label{ssec:metis-inferences-rules}

In the following table we present the list of inference rules used
by \Metis in its \TSTP derivations for propositional logic.

% \Metis looks for a refutation to prove \verb!fof! problems.
% A \verb!fof! problem contains the conjecture, the \emph{goal}, in the
% problem. This goal is stripped into subgoals by using the \strip rule. The
% subgoals are the conjuncts in a general conjunction that is equivalent to the
% aforementioned goal.
% Therefore, to prove the goal, \Metis proves independently each subgoal since
% they tend to be less complex or even fewer propositions. At the end, the
% conjunction of all subgoal proofs must prove the goal. Nevertheless, this last
% reasoning is not explicit neither in the \TSTP derivations nor in the
% documentation available about \Metis.
% Since \Metis replies refutation proofs, to prove each subgoal, in the \TSTP
% derivation, the inference rule \negate introduces the negation of such
% subgoals. The \negate rule is a specification of the \emph{assume} rule.

% Finally, \emph{axiom} rule appears in \TSTP derivations by using one of the following rules: \canonicalize, \clausify, \conjunct, or \simplify.
% Then, the last rule remains is \emph{resolve}, it
% appears by the binary rule, \resolve, the version in \Metis of the resolution
% theorem. For a more detailed description of this rules see Section~\ref{sec:proof-reconstruction}.


\begin{table}[!ht]
\label{tab:agda-metis-table}
\caption{\Metis inference rules.}
  \begin{center}
  {\renewcommand{\arraystretch}{1.6}%
    \begin{tabular}{|@{\hspace{2mm}}l@{\hspace{2mm}}l@{\hspace{2mm}}l@{\hspace{2mm}}|}
    \hline
    \textbf{\Metis rule} & \textbf{Purpose} &\textbf{Theorem}\\ \hline
    \texttt{canonicalize}
      &Normalization of the formula
      &\ref{thm:canonicalize}
    \\
    \texttt{clausify}
      &Performs clausification
      &\ref{thm:clausify}
    \\
    \hyperlink{atp-conjunct}{\texttt{conjunct}}
      &Takes a formula from a conjunction
      &\ref{thm:conjunct}
    \\
    % \texttt{negate}
    %   &Negate the formula
    %   &\ref{thm:negate}
    % \\
    \texttt{resolve}
      &A general form of the resolution theorem
      &\ref{thm:resolve}
    \\
    \texttt{simplify}
      &Simplify definitions and theorems
      &\ref{thm:simplify}
    \\
    \texttt{strip}
      &Strip a goal into subgoals
      &\ref{thm:strip}
    \\[1ex]
    \hline
    \end{tabular}}
  \end{center}
\end{table}

\end{document}
