\documentclass[../main.tex]{subfiles}
\begin{document}

\section{Type Theory}
\label{sec:type-theory}

Type theory is another formalism for the foundation of mathematics, and it has become in a key instrument to study logic and proof theory.
It was proposed in 1902 to avoid the Russell's paradox and it follows
the same philosophy of constructive mathematics where the witness of
a statement is \emph{everything}. In that direction, we could say
the main actors in type theory are the statements and their proofs.
The \emph{types} are theorems and their \emph{terms} are the proofs.

Since it is a formal system, in type theory, we have a syntax and a set of derivation rules. These rules enables us to get certain kind of conclusions that we call \emph{judgments}. A judgment is a statement that says a
term has certain type.

\begin{notation}
Types are written using small caps.
We write the type judgments as $m : \abbre{M}$ to denote
that $m$ has $\abbre{M}$ type.
\end{notation}

With the derivation rules we produce derivation trees inside
the judgments. These trees represent proofs of theorems.
We use such level of expressiveness for the reconstructed proofs
of the \ATPs.

% Since type theory can be seen as typed lambda calculus with dependent products,
% compute terms is basically $\beta$-reductions.
% And we



We choose a proof-assistant for type theory
because of the verification of proofs is type-checking, that is,
given a type of the theorem and the proof-term, verify that term
effectively has the type of the theorem.
Therefore, by following the Curry-Howard correspondence,

% Therefore the proof-reconstruction tool generates proof-terms by reconstructing the proof using the formalization
% the prover in type theory. However, this approach suffers from some limitations of type theory as we describe in Section~\ref{sec:type-theory}.


\begin{notation}
We use \Prop for the type of propositions and the dependent type, $Γ ⊢ φ$ for
theorems where $Γ : \List~\Prop$ and $φ : \Prop$.
$\abbre{List}$ type is the usual inductive type for lists.
For syntactical equivalence, we write the equality as $φ ≡ ψ$
for $φ,~ψ : \Prop$. For this equality, we assume the
reflexivity, symmetry and transitivity properties.
\end{notation}

% ...................................................................

% section section_name (end)
\subsection{Terminating functions}
\label{ssec:structural-recursion}


To reconstruct \Metis' inference rules in type theory, we observed that
transformations performed by some rules are implemented by \emph{general
recursive} functions.

Algorithms based on general recursion can not be translated
directly in type theory since it is not a guarantee they terminate. For that
reason, we follow the technique described in~\cite{Bertot2004} to avoid
termination problems by modifying the recursive functions to be
\emph{structural recursive}.
% (see \cite{Coquand1992,Abel2002,Bove2005} for more details).

This paper adopts the notion of \emph{structurally smaller} from
\citeauthor{Abel2002}~\cite{Abel2002} to say, a recursive function is
structurally recursive if it calls itself with only
structurally smaller arguments.

General recursive functions can be rewrote into structurally recursive
functions by using for instance, the \emph{bounded recursion} technique.
For a yet another methods, we refer
the reader to \cite{Coquand1992,Abel2002,Bove2005}.
The bounded technique defines a new structural recursive function based on
the general recursive function by adding an argument.
The new argument is the \emph{bound}, a natural number given by the
function complexity. In other words, the added argument will represent
the number of times the function needs to call itself to get the
expected outcome.

\begin{notation}
The type of natural numbers is called \Nat, and it is defined as
usual, where $\zero$ and $\suc$ are its data constructors. We use names
and symbols for the arithmetic operations as usual ($+$, $-$, $*$).
We include syntax sugar for $\zero$, $\suc$, $\suc~\zero$,
$\cdots$, with the decimal representation: $0$, $1$, $2$, $\cdots$
as well.
\end{notation}

Hence, one approach to define a structural recursive function based on
a general recursive function $\rm{f}:~\Prop~\to~\Prop$ is to formulate a new
function $\rm{f}^{*}~:~\Prop~\to~\Nat~\to~\Prop$ where all of its recursive
calls are done on smaller arguments.

\begin{myexamplenum}
\label{ex:structural-recursion}

Let us consider the following example to show the bounded recursion technique
for the \fuh function. This function is used for reconstructing
a \Metis inference rule in Section~\ref{sssec:strip-a-goal}.

\begin{equation}
\label{eq:uh-definition}
\begin{aligned}
&\hspace{.495mm}\fuh_{0} : \Prop → \Prop\\
&\begin{array}{lll}
  \fuh_{0} &(φ₁ ⇒ (φ₂ ⇒ φ₃)) &= \fuh_{0}~((φ₁ ∧ φ₂) ⇒ φ₃)\\
  \fuh_{0} &(φ₁ ⇒ (φ₂ ∧ φ₃)) &= \fuh_{0}~(φ₁ ⇒ φ₂) ∧ \fuh_{0}~(φ₁ ⇒ φ₃)\\
  \fuh_{0} &φ                &= φ.
\end{array}
\end{aligned}
\end{equation}

In~\eqref{eq:uh-definition}, the first two equations
call on arguments no structurally smaller.
For instance, on the first call, $φ ≡ (φ₁ ∧ φ₂) ⇒ φ₃$, the recursion
calls on the  $φ₁ ⇒ (φ₂ ⇒ φ₃)$ argument that is not a subformula of φ.
Therefore, one way to translate $\fuh_{0}$ to type
theory is to define a new function using a bounded recursion.

\begin{equation}
\label{eq:uh-structured}
\begin{aligned}
&\hspace{.495mm} \fuh_{1} : \Prop → \Nat \to \Prop\\
&\begin{array}{llll}
\fuh_{1} &(φ₁ ⇒ (φ₂ ⇒ φ₃)) &(\suc~n) &= \fuh_{1}~((φ₁ ∧ φ₂) ⇒ φ₃)~n\\
\fuh_{1} &(φ₁ ⇒ (φ₂ ∧ φ₃)) &(\suc~n) &= \fuh_{1}~(φ₁ ⇒ φ₂)~n ∧ \fuh_{1}~(φ₁ ⇒ φ₃)~n\\
\fuh_{1} &φ &n &= φ.
\end{array}
\end{aligned}
\end{equation}

We bounded the recursion calls in~\eqref{eq:uh-structured} with a \Nat argument. This natural number represents the complexity measure of $\fuh_{0}$
function.

The \emph{complexity measure} defined in \cite{Agudelo-Agudelo2017}
and presented in \cite{VanDalen1994} as \emph{the rank for a
proposition}, is a function $\Prop \to \Nat$ that assigns a natural
number to a formula like we do with the following $\frank$ function.
The symbols $c_{¬}$ and $c_{\square}$ are non-negative integer
numbers called the complexity of the respective connective.


\begin{equation}
% \label{eq:rank-definition}
\begin{aligned}
&\hspace{.495mm}\frank : \Prop → \Nat\\
&\begin{array}{llll}
\frank~(¬~φ)           &= \frank~φ₁~+~c_{¬}\\
\frank~(φ₁~\square~φ₂) &= \fmax~(\frank~φ₁)~(\frank~φ₂) + c_{\square}\\
\frank~φ               &= 0.
\end{array}
\end{aligned}
\end{equation}

We define the $\fuh_{cm}: \Prop → \Nat$ function as
the complexity measure for the $\fuh_0$ function.

\begin{equation}
  \label{eq:uh-complexity}
  \begin{aligned}
    &\hspace{.495mm}\fuh_{cm} : \Prop → \Nat\\
    &\begin{array}{llll}
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ⇒ φ₃)) &= \fuh_{cm}~φ₃ + 2\\
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ∧ φ₃)) &= \fmax~(\fuh_{cm}~φ₂)~(\fuh_{cm}~φ₃) + 1\\
    \fuh_{cm}~φ                &= 0.
    \end{array}
  \end{aligned}
\end{equation}

Following the technique mentioned above, we get the structural
recursive definition of the $\fuh_{0}$ function presented
in~\eqref{eq:uh}.

\begin{align}
  \label{eq:uh}
  \begin{split}
  &\fuh : \Prop → \Prop\\
  &\fuh~φ~ = \fuh_{1}~φ~(\fuh_{cm}~φ).
  \end{split}
\end{align}

\end{myexamplenum}

For a more complete treatment of general recursion, and how to
define well-founded and well-structural recursive functions, we refer
the reader to \citeauthor{Bove2005}~\cite{Bove2005}.

\subsection{Intuitionistic logic}
\label{ssec:intuitionistic-logic}


We follow the same approach presented in~\cite{Altenkirch2015} to work with
propositional logic in type theory. Therefore, we include in the constructors
for theorems, structural rules and formation rules of all connectives in
Fig.~\ref{fig:CPL-inference-rules}.

Since we pretend to reconstruct proofs generated by \Metis, and \Metis works
in classical logic,  we have included as an axiom, the
principle of excluded third (\abbre{PEM}).

Assuming \abbre{PEM}, we can justify refutation proofs.
We derive the \emph{reductio ad absurdum} rule (\abbre{RAA}) as the
formulation of the principle of proof by contradiction, that is, a derivation
of a contradiction, $⊥$, from the hypothesis $(¬ φ)$, is a
derivation of $φ$.

\begin{figure}
\begin{equation*}
  \begin{bprooftree}
    \AxiomC{\,}
    \RightLabel{assume}
    \UnaryInfC{$Γ , φ ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{weaken}
    \UnaryInfC{$Γ , ψ ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{\,}
    \RightLabel{$⊤$-intro}
    \UnaryInfC{$Γ ⊢ ⊤$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ⊥$}
    \RightLabel{$⊥$-elim}
    \UnaryInfC{$Γ ⊢ φ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ ⊥$}
    \RightLabel{$¬$-intro}
    \UnaryInfC{$Γ ⊢ ¬ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ¬ φ$}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{$¬$-elim}
    \BinaryInfC{$Γ ⊢ ⊥$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \AxiomC{$Γ ⊢ ψ$}
    \RightLabel{$\wedge$-intro}
    \BinaryInfC{$Γ ⊢ φ \wedge ψ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ \wedge ψ$}
    \RightLabel{$\wedge$-proj$_1$}
    \UnaryInfC{$Γ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ \wedge ψ$}
    \RightLabel{$\wedge$-proj$_2$}
    \UnaryInfC{$Γ⊢ ψ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{$\vee$-intro$_1$}
    \UnaryInfC{$Γ ⊢ φ \vee ψ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ψ$}
    \RightLabel{$\vee$-intro$_2$}
    \UnaryInfC{$Γ ⊢ φ \vee ψ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ γ $}
    \AxiomC{$Γ , ψ  ⊢ γ$}
    \RightLabel{$\vee$-elim}
    \BinaryInfC{$Γ , φ \vee ψ ⊢ γ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ ψ$}
    \RightLabel{$\Rightarrow$-intro}
    \UnaryInfC{$Γ ⊢ φ \Rightarrow ψ$}
  \end{bprooftree}
\end{equation*}

\[
%\scalebox{0.9}{
\begin{bprooftree}
\AxiomC{$Γ ⊢ φ \Rightarrow ψ$}
\AxiomC{$Γ ⊢ φ$}
\RightLabel{$\Rightarrow$-elim}
\BinaryInfC{$Γ ⊢ ψ$}
\end{bprooftree}\qquad
\begin{bprooftree}
\AxiomC{\,}
\RightLabel{PEM}
\UnaryInfC{$Γ ⊢ φ ∨ ¬ φ$}
\end{bprooftree}
\]

% \[
% \qquad
% \begin{bprooftree}
% \AxiomC{$Γ, ¬ φ ⊢ ⊥$}
% \RightLabel{RAA}
% \UnaryInfC{$Γ ⊢ φ$}
% \end{bprooftree}
% \]


\caption{Inference rules for propositional logic.}
\label{fig:CPL-inference-rules}
\end{figure}


\end{document}
