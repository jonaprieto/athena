\documentclass[../main.tex]{subfiles}
\begin{document}

\section{Type Theory}
\label{sec:type-theory}

% It was proposed in 1902 to avoid Russell's paradox --- (bettter mention BHK)
Type theory is a formalism for the foundation of mathematics,
it has became in a key instrument to study logic and proof theory
that follows the same basis of constructive mathematics where the witness of a statement is \emph{everything}.
In that direction, we could say the main actors in type theory are the statements and their proofs.

By following the Curry-Howard correspondence (see, for
example,~\cite{Wadler-2015}), a formula corresponds to a \emph{type},
and one proof of that formula is a \emph{term} of the correspondent
type. Therefore, inhabitants types are such formulas with proofs, they are theorems.

Since type theory is a formal system, we have a syntax and a set of
derivation rules. These rules enables us to derive a kind of
conclusions called \emph{judgments}. A judgment is another way to say
that a term has a certain type. Each term has associated a derivation,
we refer to this derivation as proof-terms.

\begin{notation}

  We write the type judgments as $a : \type{A}$ to denote that the
  term~$a$ is of type~$\type{A}$.

\end{notation}

We produce derivation trees inside the judgments using the derivation
rules. Since type theory can be seen as typed $λ$-calculus with
dependent function types, evaluation of $λ$-terms also called
\emph{normalization} of the proof-terms, is a process of reductions with the system inference rules.

Therefore, the proof verification task becomes in type theory as
verifying that the proof-term has the correspondent type of the
theorem. We know this process as \emph{type-checking}.
This feature of type theory allow us to verify a proof generated by an \ATP by reconstructing its proof-term to type-check the proof. For such a
purpose, we use a proof-assistant based on type theory like \Agda to
delegate this task. % However, this approach has some weak points
discussed in~\cite{Bezem2002}. Some limitations from the type theory
point of view for proof-reconstruction is described in
Section~\ref{ssec:structural-recursion} and
Section~\ref{ssec:intuitionistic-logic}.

% ...................................................................

% section section_name (end)
\subsection{Terminating functions}
\label{ssec:structural-recursion}

To reconstruct \Metis inference rules in type theory, we observed
that some rules or their inner functions are implemented by
\emph{general recursive} functions (see a definition of these functions in~\cite{Bove2002}).

Functions defined by a general recursion can not be directly
translated in type theory since it is not a guarantee they terminate.
For that reason, we follow the technique described
in~\cite{Bertot2004} to avoid termination problems by modifying the
recursive functions to be \emph{structurally recursive}.

A recursive function is structurally recursive if it calls itself
with only structurally smaller arguments~\cite{Abel2002}.
General recursive functions can be rewrote into structurally
recursive functions by  using for instance, the
\emph{bounded recursion} technique. For a yet another methods, we refer the
reader to \cite{Coquand1992,Abel2002,Bove2005}.

The bounded technique defines a new structural recursive function
based on the general recursive function by adding an argument. The
new argument is the \emph{bound}, a natural number given by the
function complexity.
In other words, the added argument will represent the number of times
the function needs to call itself to get the expected outcome.

\begin{notation}
  We use \Prop for the type of propositions.
  A proposition is an expression of indivisible propositional variables (\eg, symbols $φ₀, φ₁, \dots$), and the logic constants:
  $⊥$, $⊤$, the binary connectives ($∧, ∨, ⇒)$, and the negation
  $(\neg)$. We use the inductive definition for propositions presented in~\cite{VanDalen1994}.

  We write the syntactical equality between two propositions φ and ψ using the symbol (≡) as $φ ≡ ψ$. For this equality, we assume the reflexivity, symmetry and
  transitivity properties.

  The type of natural numbers is called \Nat,
  and it is defined as usual, \ie, $\zero$ and $\suc$ are its data
  constructors. We use names and symbols for the arithmetic
  operations as usual (\eg, $+$, $-$, $*$).
  We use syntax sugar for $\zero$, $\suc$,
  $\suc~\zero$, $\dots$, with the decimal representation~$0$, $1$,
  $2$, $\dots$ as well.
\end{notation}

Hence, one approach to define a structural recursive function based
on a general
recursive function $f₀ : \type{A} \to \type{B}$ is to
formulate a new
function $f₁ : \type{A} \to \Nat \to \type{B}$ where all
of its recursive calls are done on smaller arguments.

\begin{notation}
In the latter definitions and theorems, we  use a common notation in
type theory, pattern-matching~\cite{Coquand1992} to define functions by cases on the inductive definition for the type of the arguments.
\end{notation}

\begin{myexamplenum}
\label{ex:structural-recursion}

Let us consider the following example to show the bounded recursion
technique for defining the \fuh function. This function is used for
reconstructing a \Metis inference rule in
Section~\ref{sssec:strip-a-goal}.

\begin{equation}
\label{eq:uh-definition}
\begin{aligned}
&\hspace{.495mm}\fuh_{0} : \Prop → \Prop\\
&\begin{array}{lll}
  \fuh_{0} &(φ₁ ⇒ (φ₂ ⇒ φ₃)) &= \fuh_{0}~((φ₁ ∧ φ₂) ⇒ φ₃)\\
  \fuh_{0} &(φ₁ ⇒ (φ₂ ∧ φ₃)) &= \fuh_{0}~(φ₁ ⇒ φ₂) ∧ \fuh_{0}~(φ₁ ⇒ φ₃)\\
  \fuh_{0} &φ                &= φ.
\end{array}
\end{aligned}
\end{equation}

In~\eqref{eq:uh-definition}, the first two equations in the $\fuh_{0}$ function definition are no structurally recursive.
Note that the formula used in the recursive calls are not subformulas
of the formula in the function argument.

% TODO
% , the first two equations
% call on arguments no structurally smaller.
% For instance, in the first equation,
% $$\fuh_{0} (φ₁ ⇒ (φ₂ ⇒ φ₃)) = \fuh_{0}~((φ₁ ∧ φ₂) ⇒ φ₃),$$
% the function $\fuh_{0}$ calls on the argument $(φ₁ ∧ φ₂) ⇒ φ₃$ argument. However, this formula is not a subformula of $φ₁ ⇒ (φ₂ ⇒ φ₃)$.


Therefore, one way to define $\fuh_{0}$ in type
theory is to define a new function using a bounded recursion.

\begin{equation}
\label{eq:uh-structured}
\begin{aligned}
&\hspace{.495mm} \fuh_{1} : \Prop → \Nat → \Prop\\
&\begin{array}{llll}
\fuh_{1} &(φ₁ ⇒ (φ₂ ⇒ φ₃)) &(\suc~n) &= \fuh_{1}~((φ₁ ∧ φ₂) ⇒ φ₃)~n\\
\fuh_{1} &(φ₁ ⇒ (φ₂ ∧ φ₃)) &(\suc~n) &= \fuh_{1}~(φ₁ ⇒ φ₂)~n ∧ \fuh_{1}~(φ₁ ⇒ φ₃)~n\\
\fuh_{1} &φ &n &= φ.
\end{array}
\end{aligned}
\end{equation}

We bounded the recursion calls of the $\fuh_{0}$ function using its
\emph{complexity measure}.

The complexity measure of a function is the number of steps the
function takes to finish. Since the $\fuh_{0}$ function is recursive,
we can define its complexity measure by defining a recursive function
instead of a closed formula for such a number. However, this function
must to be structurally recursive as well and can be defined by
following the pattern-matching cases of its definition.

Therefore, we define in~\eqref{eq:uh-complexity} the complexity
measure function of $\fuh_{0}$ by assigning the number of steps to
finish for each pattern-matching case.

% In this particular case,
% as we can see by the definition of the $\fuh_{0}$ function, the pattern-matching cases depend on the formula structure for implications. For example, when φ ≡ in the consequent when the input formula is an implication. For example, when the input formula
% is an implication like φ₁ ⇒ (φ₂ ∧ φ₃) then, the recursive calls
% are using only the consequent φ₂ ∧ φ₃, otherwise, if φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃) based on the cases of the function definition, we only need
% to take care of φ₃.


We have used the complexity measure definition for a formula defined in~\cite{Agudelo-Agudelo2017} to define other complexity measures
in this paper.

\begin{equation}
  \label{eq:uh-complexity}
  \begin{aligned}
    &\hspace{.495mm}\fuh_{cm} : \Prop → \Nat\\
    &\begin{array}{llll}
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ⇒ φ₃)) &= \fuh_{cm}~φ₃ + 2\\
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ∧ φ₃)) &= \fmax~(\fuh_{cm}~φ₂)~(\fuh_{cm}~φ₃) + 1\\
    \fuh_{cm}~φ                &= 0.
    \end{array}
  \end{aligned}
\end{equation}


Following the technique mentioned above, we define the
function~$\fuh$, the structural
recursive definition of the function~$\fuh_{0}$.
\begin{align*}
  \label{eq:uh}
  \begin{split}
  &\fuh : \Prop → \Prop\\
  &\fuh~φ~ = \fuh_{1}~φ~(\fuh_{cm}~φ).
  \end{split}
\end{align*}

\end{myexamplenum}

% For a more complete treatment of general recursion, and how to define
% well-founded and well-structural recursive functions, we refer the
% reader to~\cite{Bove2005}.

\subsection{Intuitionistic logic}
\label{ssec:intuitionistic-logic}

Type theory and intuitionistic logic are accompanying theories since
they are based on the same philosophical basis of constructive
mathematics. Proving propositions in these theories demands a witness
construction for the proof. Nonetheless, classical logic does not
always have constructive proofs since some of the proofs are stated
by refutation.

To reconstruct proofs generated by \Metis, we have formalized in type
theory the classical propositional logic in~\cite{AgdaProp}.  A
briefly description of it is presented in \cite{VanDalen1994}.
In this formalization, we have to assume the principle of excluded
middle (henceforth \abbre{PEM}) as an axiom since \Metis is a prover
for classical logic. Assuming \abbre{PEM}, we can justify refutation
proofs by deriving from it the \emph{reductio ad absurdum} rule
(henceforth \abbre{RAA}). The \abbrev{RAA} rule is the formulation of
the principle of proof by contradiction, that is, a derivation of a
contradiction,~$⊥$, from the hypothesis~$¬ φ$, is a derivation
of~$φ$.

\begin{notation}
  The $\abbre{List}$ type is the usual inductive and parametric type
  for lists.
\end{notation}

We formalize the syntactical consequence relation of \CPL by an
inductive family \verb!_⊢_! with two indexes, a set of propositions (the
premises) and a proposition (the conclusion), that is, $Γ ⊢ φ$
represents that there is derivation with conclusion $φ : \Prop$ from
the set of premises $Γ : \List~\Prop$. We implemented
in~\cite{AgdaProp} the syntactical consequence relation in a similar
way as it was presented in~\cite{Altenkirch2015}. For that reason, we
have included structural rules like \emph{weaken}, formation and
elimination rules for connectives and the PEM axiom as the valid
inference rules in Fig.~\ref{fig:CPL-inference-rules}.

\begin{figure}
\begin{equation*}
  \begin{bprooftree}
    \AxiomC{\,}
    \RightLabel{assume}
    \UnaryInfC{$Γ , φ ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{weaken}
    \UnaryInfC{$Γ , ψ ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{\,}
    \RightLabel{$⊤$-intro}
    \UnaryInfC{$Γ ⊢ ⊤$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ⊥$}
    \RightLabel{$⊥$-elim}
    \UnaryInfC{$Γ ⊢ φ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ ⊥$}
    \RightLabel{$¬$-intro}
    \UnaryInfC{$Γ ⊢ ¬ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ¬ φ$}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{$¬$-elim}
    \BinaryInfC{$Γ ⊢ ⊥$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \AxiomC{$Γ ⊢ ψ$}
    \RightLabel{$\wedge$-intro}
    \BinaryInfC{$Γ ⊢ φ \wedge ψ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ \wedge ψ$}
    \RightLabel{$\wedge$-proj$_1$}
    \UnaryInfC{$Γ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ \wedge ψ$}
    \RightLabel{$\wedge$-proj$_2$}
    \UnaryInfC{$Γ⊢ ψ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{$\vee$-intro$_1$}
    \UnaryInfC{$Γ ⊢ φ \vee ψ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ψ$}
    \RightLabel{$\vee$-intro$_2$}
    \UnaryInfC{$Γ ⊢ φ \vee ψ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ γ $}
    \AxiomC{$Γ , ψ  ⊢ γ$}
    \RightLabel{$\vee$-elim}
    \BinaryInfC{$Γ , φ \vee ψ ⊢ γ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ ψ$}
    \RightLabel{$⇒$-intro}
    \UnaryInfC{$Γ ⊢ φ ⇒ ψ$}
  \end{bprooftree}
\end{equation*}

\[
%\scalebox{0.9}{
\begin{bprooftree}
\AxiomC{$Γ ⊢ φ ⇒ ψ$}
\AxiomC{$Γ ⊢ φ$}
\RightLabel{$⇒$-elim}
\BinaryInfC{$Γ ⊢ ψ$}
\end{bprooftree}\qquad
\begin{bprooftree}
\AxiomC{\,}
\RightLabel{PEM}
\UnaryInfC{$Γ ⊢ φ ∨ ¬ φ$}
\end{bprooftree}
\]

% \[
% \qquad
% \begin{bprooftree}
% \AxiomC{$Γ, ¬ φ ⊢ ⊥$}
% \RightLabel{RAA}
% \UnaryInfC{$Γ ⊢ φ$}
% \end{bprooftree}
% \]


\caption{Inference rules for classical propositional logic.}
\label{fig:CPL-inference-rules}
\end{figure}


\end{document}
