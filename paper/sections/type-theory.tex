\documentclass[../main.tex]{subfiles}
\begin{document}

\section{Type Theory}
\label{sec:type-theory}

Type theory is another formalism for the foundation of mathematics, and it has became in a key instrument to study logic and proof theory.
It was proposed in 1902 to avoid the Russell's paradox and it follows
the same philosophy of constructive mathematics where the witness of
a statement is \emph{everything}. In that direction, we could say
the main actors in type theory are the statements and their proofs.
By following the Curry-Howard correspondence (see, for example,~\cite{Wadler-2015}), we say
\emph{types} are theorems and their \emph{terms} are their proofs.

Since type theory is a formal system, we have a syntax and a set of
derivation rules. These rules enables us to derive a kind of conclusions called
\emph{judgments}. A judgment is another way to say a term has certain type.

\begin{notation}
  Types are written using \abbre{small caps}.  We write the type
  judgments as $m : \abbre{m}$ to denote that~$m$ is of
  type~$\abbre{m}$.
\end{notation}

We produce derivation trees inside the judgments using the derivation
rules.  Since type theory can be seen as typed $λ$-calculus with
dependent products, evaluation of $λ$-terms also called
\emph{normalization} of the proof-terms, are reductions using the
system inference rules.

Therefore, the task to verify a proof that proves a certain theorem is
translated to verify if the associated tree of the proof has the
correspondent type of the theorem. We know this process as
\emph{type-checking}. This feature of type theory allow us to verify a
proof generated by an \ATP by reconstructing its proof-term to
type-check the proof. For such a purpose, we use a proof assistant in
type theory like \Agda to delegate this task.  However, this approach
has some weak points discussed in~\cite{Bezem2002}. Some limitations
from the type theory point of view for proof-reconstruction is
described in the following sections.

% ...................................................................

% section section_name (end)
\subsection{Terminating functions}
\label{ssec:structural-recursion}


To reconstruct \Metis inference rules in type theory, we observed that
transformations performed by some rules are implemented by \emph{general
recursive} functions.

Algorithms based on general recursion can not be translated
directly in type theory since it is not a guarantee they terminate. For that
reason, we follow the technique described in~\cite{Bertot2004} to avoid
termination problems by modifying the recursive functions to be
\emph{structural recursive}.
% (see \cite{Coquand1992,Abel2002,Bove2005} for more details).

This paper adopts the notion of \emph{structurally smaller}
from~\cite{Abel2002}, that is, a recursive function is structurally
recursive if it calls itself with only structurally smaller arguments.

General recursive functions can be rewrote into structurally recursive
functions by using for instance, the \emph{bounded recursion} technique.
For a yet another methods, we refer
the reader to \cite{Coquand1992,Abel2002,Bove2005}.
The bounded technique defines a new structural recursive function based on
the general recursive function by adding an argument.
The new argument is the \emph{bound}, a natural number given by the
function complexity. In other words, the added argument will represent
the number of times the function needs to call itself to get the
expected outcome.

\begin{notation}

We use \Prop for the type of propositions.
For syntactical equivalence, we write the equality as $φ ≡ ψ$
for $φ,~ψ : \Prop$. For this equality, we assume the
reflexivity, symmetry and transitivity properties.

\end{notation}

\begin{notation}

The type of natural numbers is called \Nat, and it is defined as
usual, where $\zero$ and $\suc$ are its data constructors. We use names
and symbols for the arithmetic operations as usual ($+$, $-$, $*$).
We include syntax sugar for $\zero$, $\suc$, $\suc~\zero$,
$\cdots$, with the decimal representation: $0$, $1$, $2$, $\cdots$
as well.

\end{notation}

Hence, one approach to define a structural recursive function based on
a general recursive function $\rm{f}:~\Prop~\to~\Prop$ is to formulate a new
function $\rm{f}^{*}~:~\Prop~\to~\Nat~\to~\Prop$ where all of its recursive
calls are done on smaller arguments.

\begin{myexamplenum}
\label{ex:structural-recursion}

Let us consider the following example to show the bounded recursion technique
for the \fuh function. This function is used for reconstructing
a \Metis inference rule in Section~\ref{sssec:strip-a-goal}.

\begin{equation}
\label{eq:uh-definition}
\begin{aligned}
&\hspace{.495mm}\fuh_{0} : \Prop → \Prop\\
&\begin{array}{lll}
  \fuh_{0} &(φ₁ ⇒ (φ₂ ⇒ φ₃)) &= \fuh_{0}~((φ₁ ∧ φ₂) ⇒ φ₃)\\
  \fuh_{0} &(φ₁ ⇒ (φ₂ ∧ φ₃)) &= \fuh_{0}~(φ₁ ⇒ φ₂) ∧ \fuh_{0}~(φ₁ ⇒ φ₃)\\
  \fuh_{0} &φ                &= φ.
\end{array}
\end{aligned}
\end{equation}

In~\eqref{eq:uh-definition}, the first two equations
call on arguments no structurally smaller.
For instance, on the first call, $φ ≡ (φ₁ ∧ φ₂) ⇒ φ₃$, the recursion
calls on the  $φ₁ ⇒ (φ₂ ⇒ φ₃)$ argument that is not a subformula of φ.
Therefore, one way to translate $\fuh_{0}$ to type
theory is to define a new function using a bounded recursion.

\begin{equation}
\label{eq:uh-structured}
\begin{aligned}
&\hspace{.495mm} \fuh_{1} : \Prop → \Nat \to \Prop\\
&\begin{array}{llll}
\fuh_{1} &(φ₁ ⇒ (φ₂ ⇒ φ₃)) &(\suc~n) &= \fuh_{1}~((φ₁ ∧ φ₂) ⇒ φ₃)~n\\
\fuh_{1} &(φ₁ ⇒ (φ₂ ∧ φ₃)) &(\suc~n) &= \fuh_{1}~(φ₁ ⇒ φ₂)~n ∧ \fuh_{1}~(φ₁ ⇒ φ₃)~n\\
\fuh_{1} &φ &n &= φ.
\end{array}
\end{aligned}
\end{equation}

We bounded the recursion calls in~\eqref{eq:uh-structured} with a \Nat argument. This natural number represents the complexity measure of $\fuh_{0}$
function.

The \emph{complexity measure} defined in \cite{Agudelo-Agudelo2017}
and presented in \cite{VanDalen1994} as \emph{the rank for a
proposition}, is a function $\Prop \to \Nat$ that assigns a natural
number to a formula like we do with the following $\frank$ function.
The symbols $c_{¬}$ and $c_{\square}$ are non-negative integer
numbers called the complexity of the respective connective.


\begin{equation}
% \label{eq:rank-definition}
\begin{aligned}
&\hspace{.495mm}\frank : \Prop → \Nat\\
&\begin{array}{llll}
\frank~(¬~φ)           &= \frank~φ₁~+~c_{¬}\\
\frank~(φ₁~\square~φ₂) &= \fmax~(\frank~φ₁)~(\frank~φ₂) + c_{\square}\\
\frank~φ               &= 0.
\end{array}
\end{aligned}
\end{equation}

We define the $\fuh_{cm}: \Prop → \Nat$ function as
the complexity measure for the $\fuh_0$ function.

\begin{equation}
  \label{eq:uh-complexity}
  \begin{aligned}
    &\hspace{.495mm}\fuh_{cm} : \Prop → \Nat\\
    &\begin{array}{llll}
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ⇒ φ₃)) &= \fuh_{cm}~φ₃ + 2\\
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ∧ φ₃)) &= \fmax~(\fuh_{cm}~φ₂)~(\fuh_{cm}~φ₃) + 1\\
    \fuh_{cm}~φ                &= 0.
    \end{array}
  \end{aligned}
\end{equation}

Following the technique mentioned above, we define the
function~$\fuh$, the structural
recursive definition of the function~$\fuh_{0}$.
\begin{align*}
  \label{eq:uh}
  \begin{split}
  &\fuh : \Prop → \Prop\\
  &\fuh~φ~ = \fuh_{1}~φ~(\fuh_{cm}~φ).
  \end{split}
\end{align*}

\end{myexamplenum}

For a more complete treatment of general recursion, and how to define
well-founded and well-structural recursive functions, we refer the
reader to~\cite{Bove2005}.

\subsection{Intuitionistic logic}
\label{ssec:intuitionistic-logic}

Type theory and intuitionistic logic are accompanying theories since
they are based on the same basis of constructive mathematics. Proving
propositions in these theories demands a witness construction for the
proof. Nonetheless, classical logic does not always have constructive
proofs and some of its proofs are proved by non-constructive methods
like refutation.

To reconstruct proofs generated by \Metis, we have formalized in type theory the
classical propositional logic in~\cite{AgdaProp}.  A briefly description of it
is presented in \cite{VanDalen1994}. In this formalization, we assume the
principle of excluded third (henceforth \abbre{PEM}) as the only axiom since
\Metis is a prover for classical logic. Assuming \abbre{PEM}, we can justify
refutation proofs by deriving from it the \emph{reductio ad absurdum} rule
(henceforth \abbre{RAA}). The \abbrev{RAA} rule is the formulation of the
principle of proof by contradiction, that is, a derivation of a
contradiction,~$⊥$, from the hypothesis~$¬ φ$, is a derivation of~$φ$.

\begin{notation}
  The $\abbre{List}$ type is the usual inductive and parametric type
  for lists. We formalise theorems in \CPL by an inductive family
  $\_⊢\_$ indexed by a list of propositions and a proposition, that
  is, $Γ ⊢ φ$ represents the syntactical consequence relation between
  a list of premises, $Γ : \List~\Prop$ and a conclusion $φ : \Prop$.
\end{notation}

We implemented in~\cite{AgdaProp} the syntactical consequence relation in a
similar way as it was presented in~\cite{Altenkirch2015}. For that reason, we
have included structural rules like \emph{weaken}, formation and elimination
rules for connectives and the PEM axiom as the valid inference rules
in Fig.~\ref{fig:CPL-inference-rules}.


\begin{figure}
\begin{equation*}
  \begin{bprooftree}
    \AxiomC{\,}
    \RightLabel{assume}
    \UnaryInfC{$Γ , φ ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{weaken}
    \UnaryInfC{$Γ , ψ ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{\,}
    \RightLabel{$⊤$-intro}
    \UnaryInfC{$Γ ⊢ ⊤$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ⊥$}
    \RightLabel{$⊥$-elim}
    \UnaryInfC{$Γ ⊢ φ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ ⊥$}
    \RightLabel{$¬$-intro}
    \UnaryInfC{$Γ ⊢ ¬ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ¬ φ$}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{$¬$-elim}
    \BinaryInfC{$Γ ⊢ ⊥$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \AxiomC{$Γ ⊢ ψ$}
    \RightLabel{$\wedge$-intro}
    \BinaryInfC{$Γ ⊢ φ \wedge ψ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ \wedge ψ$}
    \RightLabel{$\wedge$-proj$_1$}
    \UnaryInfC{$Γ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ \wedge ψ$}
    \RightLabel{$\wedge$-proj$_2$}
    \UnaryInfC{$Γ⊢ ψ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{$\vee$-intro$_1$}
    \UnaryInfC{$Γ ⊢ φ \vee ψ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ψ$}
    \RightLabel{$\vee$-intro$_2$}
    \UnaryInfC{$Γ ⊢ φ \vee ψ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ γ $}
    \AxiomC{$Γ , ψ  ⊢ γ$}
    \RightLabel{$\vee$-elim}
    \BinaryInfC{$Γ , φ \vee ψ ⊢ γ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ ψ$}
    \RightLabel{$\Rightarrow$-intro}
    \UnaryInfC{$Γ ⊢ φ \Rightarrow ψ$}
  \end{bprooftree}
\end{equation*}

\[
%\scalebox{0.9}{
\begin{bprooftree}
\AxiomC{$Γ ⊢ φ \Rightarrow ψ$}
\AxiomC{$Γ ⊢ φ$}
\RightLabel{$\Rightarrow$-elim}
\BinaryInfC{$Γ ⊢ ψ$}
\end{bprooftree}\qquad
\begin{bprooftree}
\AxiomC{\,}
\RightLabel{PEM}
\UnaryInfC{$Γ ⊢ φ ∨ ¬ φ$}
\end{bprooftree}
\]

% \[
% \qquad
% \begin{bprooftree}
% \AxiomC{$Γ, ¬ φ ⊢ ⊥$}
% \RightLabel{RAA}
% \UnaryInfC{$Γ ⊢ φ$}
% \end{bprooftree}
% \]


\caption{Inference rules for propositional logic.}
\label{fig:CPL-inference-rules}
\end{figure}


\end{document}
