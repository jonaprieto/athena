\documentclass[../main.tex]{subfiles}
\begin{document}

\section{Type Theory}
\label{sec:type-theory}

% It was proposed in 1902 to avoid Russell's paradox --- (bettter mention BHK)
Type theory is a formalism for the foundation of mathematics,
it has became in a key instrument to study logic and proof theory
that follows the same basis of constructive mathematics where the witness of a statement is \emph{everything}.
In that direction, we could say the main actors in type theory are the statements and their proofs.

By following the Curry-Howard correspondence (see, for
example,~\cite{Wadler-2015}), types are propositions. The inhabitants
of that types, the \emph{terms}, are proofs of that propositions.
Since type theory is a formal system, we have a syntax and a set of
derivation rules. These rules enables us to derive a kind of
conclusions called \emph{judgments}. A judgment is another way to say
that a term has a certain type.

\begin{notation}
  Types are written using \abbre{small caps}.  We write the type
  judgments as $a : \abbre{a}$ to denote that the term~$a$ is of
  type~$\abbre{a}$.
\end{notation}

We produce derivation trees inside the judgments using the derivation
rules. Since type theory can be seen as typed $λ$-calculus with
dependent function types, evaluation of $λ$-terms also called
\emph{normalization} of the proof- terms, are reductions using the
system inference rules.

Therefore, the proof verification task becomes in type theory as
verifying that the proof-term has the correspondent type of the
theorem. We know this process as \emph{type-checking}.
This feature of type theory allow us to verify a proof generated by an \ATP by reconstructing its proof-term to type-check the proof. For such a
purpose, we use a proof assistant based on type theory like \Agda to
delegate this task. % However, this approach has some weak points
discussed in~\cite{Bezem2002}. Some limitations from the type theory
point of view for proof-reconstruction is described in the following
sections.

% ...................................................................

% section section_name (end)
\subsection{Terminating functions}
\label{ssec:structural-recursion}

To reconstruct \Metis inference rules in type theory, we observed
that some rules or their inner functions are implemented by \emph{
general recursive} functions.

Functions defined by a general recursion can not be directly
translated in type theory since it is not a guarantee they terminate.
For that reason, we follow the technique described
in~\cite{Bertot2004} to avoid termination problems by modifying the
recursive functions to be \emph{structurally recursive}.

A recursive function is structurally recursive if it calls itself
with only structurally smaller arguments~\cite{Abel2002}.
General recursive functions can be rewrote into structurally
recursive functions by  using for instance, the \emph{bounded
recursion} technique. For a yet another methods, we refer the reader
to \cite{Coquand1992,Abel2002,Bove2005}.

The bounded technique defines a new structural recursive function
based on the general recursive function by adding an argument. The
new argument is the \emph{bound}, a natural number given by the
function complexity.
In other words, the added argument will represent the number of times
the function needs to call itself to get the expected outcome.

\begin{notation}
  We use \Prop for the type of propositions.
  A proposition is an expression of indivisible propositional variables (\eg, symbols $φ₀, φ₁, \cdots$), the logic constants:
  $⊥$, $⊤$, the binary connectives ($∧, ∨, ⇒, ⇔)$, and the negation
  $(\neg)$.
  We write the equality using the symbol (≡) as $φ ≡ ψ$, for $φ,~ψ :
  \Prop$. For this equality, we assume the reflexivity, symmetry and
  transitivity properties.
  % We say $φ$ and $ψ$ are syntactically equivalent if there is a derivation from $φ$ to $ψ$ and
  % a derivation from $ψ$ to $φ$.
  The type of natural numbers is called \Nat,
  and it is defined as usual, where $\zero$ and $\suc$ are its data
  constructors. We use names and symbols for the arithmetic operations
  as usual (\eg, $+$, $-$, $*$).  We use syntax sugar for $\zero$, $\suc$,
  $\suc~\zero$, $\dots$, with the decimal representation~$0$, $1$,
  $2$, $\dots$ as well.
\end{notation}

Hence, one approach to define a structural recursive function based
on a general
recursive function $\rm{f}:\,\abbre{a}~\to~\abbre{b}$ is to
formulate a new
function $\rm{f}^{*}:\,\abbre{a}~\to~\Nat~\to~\abbre{b}$ where all
of its recursive calls are done on smaller arguments.

\begin{notation}
We define some functions by pattern-matching on \Prop or \Nat.
\end{notation}

\begin{myexamplenum}
\label{ex:structural-recursion}

Let us consider the following example to show the bounded recursion
technique for defining the \fuh function. This function is used for
reconstructing a \Metis inference rule in
Section~\ref{sssec:strip-a-goal}.

\begin{equation}
\label{eq:uh-definition}
\begin{aligned}
&\hspace{.495mm}\fuh_{0} : \Prop → \Prop\\
&\begin{array}{lll}
  \fuh_{0} &(φ₁ ⇒ (φ₂ ⇒ φ₃)) &= \fuh_{0}~((φ₁ ∧ φ₂) ⇒ φ₃)\\
  \fuh_{0} &(φ₁ ⇒ (φ₂ ∧ φ₃)) &= \fuh_{0}~(φ₁ ⇒ φ₂) ∧ \fuh_{0}~(φ₁ ⇒ φ₃)\\
  \fuh_{0} &φ                &= φ.
\end{array}
\end{aligned}
\end{equation}

In~\eqref{eq:uh-definition}, the first two equations
call on arguments no structurally smaller.
For instance, in the first equation,
$$\fuh_{0} (φ₁ ⇒ (φ₂ ⇒ φ₃)) = \fuh_{0}~((φ₁ ∧ φ₂) ⇒ φ₃),$$
the function $\fuh_{0}$ calls on the  $(φ₁ ∧ φ₂) ⇒ φ₃$ argument in the right-hand side but this formula is not a subformula of $φ₁ ⇒ (φ₂ ⇒ φ₃)$.
Therefore, one way to translate $\fuh_{0}$ to type
theory is to define a new function using a bounded recursion.

\begin{equation}
\label{eq:uh-structured}
\begin{aligned}
&\hspace{.495mm} \fuh_{1} : \Prop → \Nat \to \Prop\\
&\begin{array}{llll}
\fuh_{1} &(φ₁ ⇒ (φ₂ ⇒ φ₃)) &(\suc~n) &= \fuh_{1}~((φ₁ ∧ φ₂) ⇒ φ₃)~n\\
\fuh_{1} &(φ₁ ⇒ (φ₂ ∧ φ₃)) &(\suc~n) &= \fuh_{1}~(φ₁ ⇒ φ₂)~n ∧ \fuh_{1}~(φ₁ ⇒ φ₃)~n\\
\fuh_{1} &φ &n &= φ.
\end{array}
\end{aligned}
\end{equation}

We bounded the recursion calls of the $\fuh_{0}$ function using its
\emph{complexity measure}.

The complexity measure of a function is the number of steps the
function takes to finish. Since the $\fuh_{0}$ function is recursive,
we can define its complexity measure by defining a recursive function
instead of a closed formula for such a number. However, this function
must to be structurally recursive as well and can be defined by
following the pattern-matching cases of its definition.

Therefore, we define in~\eqref{eq:uh-complexity} the complexity
measure function of $\fuh_{0}$ by assigning the number of steps to
finish for each pattern-matching case.
We have used the complexity measure definition for a formula defined in~\cite{Agudelo-Agudelo2017} to define other complexity measures
in this paper.

\begin{equation}
  \label{eq:uh-complexity}
  \begin{aligned}
    &\hspace{.495mm}\fuh_{cm} : \Prop → \Nat\\
    &\begin{array}{llll}
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ⇒ φ₃)) &= \fuh_{cm}~φ₃ + 2\\
    \fuh_{cm}~(φ₁ ⇒ (φ₂ ∧ φ₃)) &= \fmax~(\fuh_{cm}~φ₂)~(\fuh_{cm}~φ₃) + 1\\
    \fuh_{cm}~φ                &= 0.
    \end{array}
  \end{aligned}
\end{equation}


Following the technique mentioned above, we define the
function~$\fuh$, the structural
recursive definition of the function~$\fuh_{0}$.
\begin{align*}
  \label{eq:uh}
  \begin{split}
  &\fuh : \Prop → \Prop\\
  &\fuh~φ~ = \fuh_{1}~φ~(\fuh_{cm}~φ).
  \end{split}
\end{align*}

\end{myexamplenum}

% For a more complete treatment of general recursion, and how to define
% well-founded and well-structural recursive functions, we refer the
% reader to~\cite{Bove2005}.

\subsection{Intuitionistic logic}
\label{ssec:intuitionistic-logic}

Type theory and intuitionistic logic are accompanying theories since
they are based on the same philosophical basis of constructive
mathematics. Proving propositions in these theories demands a witness
construction for the proof. Nonetheless, classical logic does not
always have constructive proofs since some of the proofs are stated
by refutation.

To reconstruct proofs generated by \Metis, we have formalized in type
theory the classical propositional logic in~\cite{AgdaProp}.  A
briefly description of it is presented in \cite{VanDalen1994}.
In this formalization, we have to assume the principle of excluded
middle (henceforth \abbre{PEM}) as an axiom since \Metis is a prover
for classical logic. Assuming \abbre{PEM}, we can justify refutation
proofs by deriving from it the \emph{reductio ad absurdum} rule
(henceforth \abbre{RAA}). The \abbrev{RAA} rule is the formulation of
the principle of proof by contradiction, that is, a derivation of a
contradiction,~$⊥$, from the hypothesis~$¬ φ$, is a derivation
of~$φ$.

\begin{notation}
  The $\abbre{List}$ type is the usual inductive and parametric type
  for lists.
\end{notation}

We formalise the syntactical consequence relation of \CPL by an
inductive family $\_⊢\_$ with two indexes, a set of propositions (the
premises) and a proposition (the conclusion), that is, $Γ ⊢ φ$
represents that there is derivation with conclusion $φ : \Prop$ from
the set of premises $Γ : \List~\Prop$. We implemented
in~\cite{AgdaProp} the syntactical consequence relation in a similar
way as it was presented in~\cite{Altenkirch2015}. For that reason, we
have included structural rules like \emph{weaken}, formation and
elimination rules for connectives and the PEM axiom as the valid
inference rules in Fig.~\ref{fig:CPL-inference-rules}.

\begin{figure}
\begin{equation*}
  \begin{bprooftree}
    \AxiomC{\,}
    \RightLabel{assume}
    \UnaryInfC{$Γ , φ ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{weaken}
    \UnaryInfC{$Γ , ψ ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{\,}
    \RightLabel{$⊤$-intro}
    \UnaryInfC{$Γ ⊢ ⊤$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ⊥$}
    \RightLabel{$⊥$-elim}
    \UnaryInfC{$Γ ⊢ φ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ ⊥$}
    \RightLabel{$¬$-intro}
    \UnaryInfC{$Γ ⊢ ¬ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ¬ φ$}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{$¬$-elim}
    \BinaryInfC{$Γ ⊢ ⊥$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \AxiomC{$Γ ⊢ ψ$}
    \RightLabel{$\wedge$-intro}
    \BinaryInfC{$Γ ⊢ φ \wedge ψ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ \wedge ψ$}
    \RightLabel{$\wedge$-proj$_1$}
    \UnaryInfC{$Γ⊢ φ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ \wedge ψ$}
    \RightLabel{$\wedge$-proj$_2$}
    \UnaryInfC{$Γ⊢ ψ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{$\vee$-intro$_1$}
    \UnaryInfC{$Γ ⊢ φ \vee ψ$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ ψ$}
    \RightLabel{$\vee$-intro$_2$}
    \UnaryInfC{$Γ ⊢ φ \vee ψ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ γ $}
    \AxiomC{$Γ , ψ  ⊢ γ$}
    \RightLabel{$\vee$-elim}
    \BinaryInfC{$Γ , φ \vee ψ ⊢ γ$}
  \end{bprooftree}\quad
  \begin{bprooftree}
    \AxiomC{$Γ , φ ⊢ ψ$}
    \RightLabel{$⇒$-intro}
    \UnaryInfC{$Γ ⊢ φ ⇒ ψ$}
  \end{bprooftree}
\end{equation*}

\[
%\scalebox{0.9}{
\begin{bprooftree}
\AxiomC{$Γ ⊢ φ ⇒ ψ$}
\AxiomC{$Γ ⊢ φ$}
\RightLabel{$⇒$-elim}
\BinaryInfC{$Γ ⊢ ψ$}
\end{bprooftree}\qquad
\begin{bprooftree}
\AxiomC{\,}
\RightLabel{PEM}
\UnaryInfC{$Γ ⊢ φ ∨ ¬ φ$}
\end{bprooftree}
\]

% \[
% \qquad
% \begin{bprooftree}
% \AxiomC{$Γ, ¬ φ ⊢ ⊥$}
% \RightLabel{RAA}
% \UnaryInfC{$Γ ⊢ φ$}
% \end{bprooftree}
% \]


\caption{Inference rules for propositional logic.}
\label{fig:CPL-inference-rules}
\end{figure}


\end{document}
