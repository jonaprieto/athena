\documentclass[../../main.tex]{subfiles}
\begin{document}

\subsubsection{Resolution.}
\label{sssec:resolve}

Logic equivalence between propositions is a major issue to justify
prover reasoning steps. Since we left out semantics to treat only the
syntax aspects of propositional logic, our approach shows logic equivalence
by converting propositions to their conjunctive normal form,
and reordering those and the inner disjunctions to match them.
Below, we provide Lemma~\ref{lem:reorder-or}, Lemma~\ref{lem:reorder-and}, Lemma~\ref{lem:reorder-and-or} to perform such reordering tasks,
the omitted proofs can be found in~\cite{AgdaMetis}.

First, we define \fassoc$_{⬓}$ function in~(\ref{eq:fassoc})
to convert a disjunction or a conjunction into its right-associative form.
The square symbol (⬓) can be the conjunction symbol or the disjunction symbol.
We use $\fassoc_{∧}$ to convert conjunctions and $\fassoc_{∨}$ for
disjunctions.

\begin{equation}
\label{eq:fassoc}
  \begin{aligned}
    &\hspace{.495mm}\fassoc_{⬓} : \Prop \to \Prop\\
    &\begin{array}{lll}
    \fassoc_{⬓} &((φ₁~⬓~φ₂)~⬓~φ₃) &= \fassoc_{⬓}~(φ₁~⬓~(φ₂~⬓~φ₃))\\
    \fassoc_{⬓} &(φ₁~⬓~φ₂)        &= φ₁~∨~\fassoc_{⬓}~φ₂\\
    \fassoc_{⬓} &φ                &= φ
    \end{array}
  \end{aligned}
\end{equation}


\begin{mainlemma}
\label{lem:rassoc}
  If $Γ ⊢ φ$ then $Γ ⊢ \fassoc_{⬓}~φ$.
\end{mainlemma}

\begin{myremark}
In \TPTP syntax, the formulas are in left-associative form by default.
Despite of that convention, \Metis understands a formula to be in right-associative form by default. This is a matter to take into account for the proof-reconstruction.
\end{myremark}

The $\fbuild_{∨}$ function defined in~(\ref{eq:build-or})
intends to construct a disjunction from another disjunction, specifically,
this functions will try to rearrange the disjuncts in the source formula to
match with the target disjunction formula.

\begin{mainlemma}
\label{lem:build-or}
  If $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ \fbuild_{∨}~φ~ψ$, where,
\begin{equation}
  \begin{split}
  \label{eq:build-or}
  &\fbuild_{∨} : \Prop → \Prop → \Prop\\
  &\fbuild_{∨}~φ~ψ~ =%\\
  % &\hspace{3mm}
  \begin{cases}
  ψ, &\text{ if } φ ≡ ψ\\
  ψ, &\text{ if } ψ ≡ ψ₁ ∨ ψ₂\text{, } ψᵢ ≡ \fbuild_{∨}~φ~ψᵢ\text{ for some }i=1, 2\\
  φ, &\text{ otherwise.}
  \end{cases}
  \end{split}
\end{equation}
\end{mainlemma}

From now, we assume all propositions to be right-associative unless
otherwise stated.
The $\ffactor$ function in~(\ref{eq:factor-definition})
simplifies a special case of disjunction, the repeated disjuncts
(\eg, $\ffactor~(φ ∨ φ)~=~φ$).
Notice that other cases like $φ~∨~(ψ~∨~φ)$ do no reduce to $ψ~∨~φ$.

\begin{mainlemma}
\label{lem:factor}
 If $Γ ⊢ φ$ then $Γ ⊢ \ffactor~φ$, where,
\begin{align}
\begin{split}
  \label{eq:factor-definition}
  &\ffactor : \Prop → \Prop\\
  &\ffactor~φ~ =
  \begin{cases}
    φ₁,  &\text{ if }φ ≡ φ₁ ∨ φ₂ \text{ and } φ₁ ≡ \ffactor~φ₂\\
    φ,   &\text{ otherwise.}
  \end{cases}
\end{split}
\end{align}
\end{mainlemma}

To construct a disjunction $ψ$ from a disjunction $φ$, we have used ideas
from the description in \citeauthor{bohme2010}~\cite{bohme2010} to prove
equality between nested disjunctions.
We define the $\fsbuild_{∨}$ function in~(\ref{eq:strong-build-or}).
that uses every disjunct from the source formula, $φ$, to build up the
target disjunction $ψ$.

\begin{mainlemma}
\label{lem:sbuild-or}
If $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ \fsbuild_{∨}~φ~ψ$, where,
\begin{equation}
\label{eq:strong-build-or}
 \begin{aligned}
     &\hspace{.495mm}\fsbuild_{∨} : \Prop → \Prop → \Prop\\
    &\begin{array}{lll}
    \fsbuild_{∨}&(φ₁ ∨ φ₂)~ψ &=\ffactor~(\fbuild_{∨}~φ₁~ψ ∨ \fbuild_{∨}~φ₂~ψ)\\
    \fsbuild_{∨}&φ~ψ &= \fbuild_{∨}~φ~ψ
     \end{array}
\end{aligned}
\end{equation}
\end{mainlemma}

\begin{myexample}
We build the disjunction $(p ∨ q) ∨ r$ from the disjunction
$r ∨ (q ∨ p)$ based on the idea of the Lemma~\ref{lem:sbuild-or}.
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ q$}
  \RightLabel{∨-intro₂}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \AxiomC{$Γ ⊢ p$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \RightLabel{∨-elim}
  \BinaryInfC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ r$}
  \RightLabel{∨-intro₂}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \AxiomC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}

  \RightLabel{∨-elim}
  \BinaryInfC{$Γ, r ∨ (q ∨ p) ⊢ (p ∨ q) ∨ r$}

  \RightLabel{⇒-intro}
  \UnaryInfC{$Γ ⊢ r ∨ (q ∨ p) ⇒ (p ∨ q) ∨ r$}

  \end{bprooftree}
\end{equation*}
\end{myexample}

\begin{myremark}
Notice that using $\fsbuild_{∨}$ we can build not only a disjunction
with the same disjuncts of the source formula but also a complete different
disjunction by adding new disjuncts to the source formula.
\end{myremark}

The following lemma tries to reorder nested disjunctions
by forcing the formula to be in right-associative form in order to
apply Lemma~\ref{lem:sbuild-or}.

\begin{mainlemma}
  \label{lem:reorder-or}
  If $Γ ⊢ φ$ and $ψ: \Prop$ then $Γ ⊢ \freorder_{∨}~φ~ψ~$, where,
  \begin{align}
    \begin{split}
    \label{eq:reorder-or}
    &\freorder_{∨} : \Prop \to \Prop \to \Prop\\
    &\freorder_{∨}~φ~ψ~= \fsbuild_{∨}~(\fassoc_{∨}~φ)~ψ.
    \end{split}
  \end{align}
\end{mainlemma}

\begin{proof}
Use Lemma~\ref{lem:rassoc} and Lemma~\ref{lem:sbuild-or}.
\end{proof}

Now, we define function to work with nested conjunctions. This will
help us in the end of this section to reorder conjunctive normal forms.
For instance, the $\freorder_{∧}$ function in~(\ref{eq:reorder-and}),
reorders nested conjunctions.

\begin{mainlemma}
  \label{lem:reorder-and}
  If $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ \freorder_{∧}~φ~ψ$, where,
    \begin{align}
      \begin{split}
      \label{eq:reorder-and}
        &\freorder_{∧} : \Prop → \Prop \to \Prop\\
        &\freorder_{∧}~φ~ψ =
        \begin{cases}
          φ, &\text{ if }φ ≡ ψ\\
          ψ₁ ∧ ψ₂, &\text{ if } ψ ≡ ψ₁ ∧ ψ₂\text{, }ψ₁ ≡ \freorder_{∧}~φ~ψ₁ \\
                   &\text{ and } ψ₂ ≡ \freorder_{∧}~φ~ψ₂\\
          φ,       &\text{ if } ψ ≡ ψ₁ ∧ ψ₂\\
          \fconjunct~φ~ψ, &\text{ otherwise.}
        \end{cases}
      \end{split}
  \end{align}
\end{mainlemma}

\begin{myexample}\hspace{10cm}
\begin{enumerate}
  \item $\freorder_{∧}~(p ∧ q ∧ r)~(r ∧ q ∧ p)~=~(r ∧ q ∧ p).$
  \item $\freorder_{∧}~(p ∧ q ∧ r)~(r ∧ r ∧ p)~=~(r ∧ q ∧ p).$
  \item $\freorder_{∧}~(p ∧ q ∧ r)~(k ∧ q ∧ p)~=~(p ∧ q ∧ r).$
  \item $\freorder_{∧}~((p ∨ q) ∧ r)~(r ∧ (q ∨ p))~=~((p ∨ q) ∧ r).$
\end{enumerate}
\end{myexample}

In the last example, Item~4, we could not build the conjunction
$r ∧ (q ∨ p)$ since $p ∨ q$ is not syntactical equal to $q ∨ p$.
We solve this issue in the Lemma~\ref{lem:reorder-and-or} by
using the $\fconjunct_{∨}$ function defined in~(\ref{eq:conjunct-or}).

\begin{mainlemma}
  \label{lem:conjunct-or}
  If $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ \fconjunct_{∨}~φ~ψ$, where,
  \begin{equation*}
    \begin{split}
    \label{eq:conjunct-or}
      &\fconjunct_{∨} : \Prop → \Prop \to \Prop\\
      &\fconjunct_{∨}~φ~ψ =
      \begin{cases}
        ψ, &\text{ if }φ ≡ ψ\\
        ψ, &\text{ if } ψ ≡ \freorder_{∨}~φ~ψ\\
        ψ, &\text{ if }ψ ≡ ψ₁ ∧ ψ₂,\ ψ₁ ≡ \fconjunct_{∨}~φ~ψ₁,\\
           &\text{ and } ψ₂ ≡ \freorder_{∨}~φ~ψ₂\\
        ψ, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ ψ ≡ \fconjunct_{∨}~φ₁~ψ \\
        ψ, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ ψ ≡ \fconjunct_{∨}~φ₂~ψ \\
        φ, &\text{ otherwise.}
      \end{cases}
    \end{split}
  \end{equation*}
\end{mainlemma}

Now, we are able to reorder conjunctive normal forms using
$\freorder_{∧∨}$ function defined in (\ref{eq:reorder-and-or})
that unifies the previous lemma showed above.

\begin{mainlemma}
  \label{lem:reorder-and-or}
  If $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ \freorder_{∧∨}~φ~ψ$, where,
   \begin{align}
      \begin{split}
      \label{eq:reorder-and-or}
      &\freorder_{∧∨} : \Prop \to \Prop \to \Prop\\
      &\freorder_{∧∨}~φ~ψ=
        \begin{cases}
          ψ, &\text{ if } φ ≡ ψ\\
          ψ, &\text{ if } ψ ≡ ψ₁ ∧ ψ₂,\ ψ₁ ≡ \freorder_{∧∨}~φ~ψ₁\\
             &\text{ and } ψ₂ ≡ \freorder_{∧∨}~φ~ψ₂\\
          φ, &\text{ if } ψ ≡ ψ₁ ∧ ψ₂\\
          \fconjunct_{∨}~φ~ψ &\text{ otherwise.}
        \end{cases}
      \end{split}
  \end{align}
\end{mainlemma}

Now, we are in a position to reconstruct \resolve rule. This is the
first application of the Lemma \ref{lem:reorder-and-or}.
The \resolve rule is a generalization of the resolution theorem showed in
Fig.~\ref{fig:metis-inferences} in the \TSTP derivations.
This rule has three arguments: a positive literal $l$ to apply the
resolution theorem and two derivations.
The positive literal $l$ must occur in
the formula from the first derivation and the
negative literal $¬ l$ must occur in the formula from the second derivation,
see the pattern of \emph{resolve} rule in Fig.~\ref{fig:metis-inferences}.

\begin{myexamplenum}\hspace{10cm}
\label{ex:resolve-tstp}
\begin{verbatim}
cnf(ref4, (~ r | p | q), inf(canonicalize, [norm5])).
cnf(ref5, (p | q | r), inf(canonicalize, [norm6])).
cnf(ref6, (p | q), inf(resolve, [$cnf(r)], [ref5, ref4])).
\end{verbatim}
In the excerpt above, we apply resolution for the first two formulas,
$¬ r ∨ p ∨ q$ and $p ∨ q ∨ r$. The last line tells us the literal mentioned
for resolution is $r$. Syntactically speaking,
we can not derive neither the conclusion $p ∨ q$ in \verb!ref6! nor apply the resolution theorem with \verb!ref4! and \verb!ref5! since the formulas does not fit the pattern required.

If the scenario would have other like replacing \verb!ref5! by
\begin{verbatim}
cnf(ref5, (r | p | q), inf(canonicalize, [norm6])).
\end{verbatim}
We have could derive $(p ∨ q) ∨ (p ∨ q)$ but again, that is not the expected result.
\end{myexamplenum}

Therefore, we perform a sequence of rearrangements inside the
formulas involved to match with the pattern expected by the resolution theorem
described in Fig.~\ref{fig:metis-inferences}. Using reordering after
applying a convenient version of the resolution theorem defined
in~(\ref{eq:rsol}) we get the expect result.

\begin{mainlemma}
  \label{lem:rsol}
  If $Γ ⊢ φ$ then $Γ ⊢ \rm{rsol}~φ$, where,
  \begin{equation}
    \label{eq:rsol}
    \begin{aligned}
    &\rm{rsol} : \Prop \to \Prop\\
    &\begin{array}{ll}
      \rm{rsol}~φ &=
        \begin{cases}
          φ₂,      &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (¬φ₁ ∨ φ₂)\\
          φ₂ ∨ φ₄, &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (¬φ₁ ∨ φ₄)\\\
          φ, &\text{ otherwise.}
        \end{cases}
      \end{array}
      \end{aligned}
\end{equation}
\end{mainlemma}

\begin{mainth}
  \label{thm:resolve}
  If $Γ ⊢ φ₁$, $Γ ⊢ φ₂$, a literal $l : \Prop$, and $ψ : \Prop$ then
  $Γ ⊢ \fresolve~φ₁~φ₂~l~ψ$, where,
  \begin{equation}
  \begin{split}
  \label{eq:resolve}
    &\fresolve : \Prop \to \Prop \to \Prop \to \Prop \to \Prop\\
    &\fresolve~φ₁~φ₂~l~ψ =
      \rm{rsol}~(\freorder_{∨}~φ₁~(l ∨ ψ) ∧ \freorder_{∨}~φ₂~(¬ l ∨ ψ)).
  \end{split}
  \end{equation}
\end{mainth}

\Needspace{3\baselineskip}
\begin{proof}
  \begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ₁$}
    \RightLabel{Lemma~\ref{lem:reorder-and-or}}
    \UnaryInfC{$Γ ⊢ \freorder_{∨}~φ₁~(l ∨ ψ)$}
    \RightLabel{Lemma~\ref{lem:reorder-and-or}}
    \AxiomC{$Γ ⊢ φ₂$}
    \UnaryInfC{$Γ ⊢ \freorder_{∨}~φ₂~(¬ l ∨ ψ)$}
    \RightLabel{∧-intro}
    \BinaryInfC{$Γ ⊢ \freorder_{∨}~φ₁~(l ∨ ψ) ∧ \freorder_{∨}~φ₂~(¬ l ∨ ψ)$}
    \RightLabel{Lemma~\ref{lem:rsol}}
    \UnaryInfC{$Γ ⊢ \rm{rsol}~(\freorder_{∨}~φ₁~(l ∨ ψ) ∧
     \freorder_{∨}~φ₂~(¬ l ∨ ψ))$}
    \RightLabel{by (\ref{eq:resolve})}
    \UnaryInfC{$Γ ⊢ \fresolve~φ₁~φ₂~l~ψ$}
  \end{bprooftree}
  \end{equation*}
\end{proof}

\begin{myexample}
Continuing with the problem presented in the Example~\ref{ex:resolve-tstp},
we can use Theorem \ref{thm:resolve} to derive $Γ ⊢ p ∨ q$.
Let be $φ₁ ≡ p ∨ q ∨ r$ and $φ₂ ≡ ¬ r ∨ p ∨ q$.

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ p ∨ q ∨ r $}
  \AxiomC{$Γ ⊢ ¬ r ∨ p ∨ q$}
  \RightLabel{Theorem \ref{thm:resolve}}
  \BinaryInfC{$Γ ⊢ \fresolve~(p ∨ q ∨ r)~(¬ r ∨ p ∨ q)~r~(p ∨ q)$}
  \RightLabel{by (\ref{eq:resolve})}
  \UnaryInfC{$Γ ⊢ \rm{rsol}~(\freorder_{∨}~φ₁~(r ∨ (p ∨ q))~∧~\freorder_{∨}~φ₂~(¬ r ∨ (p ∨ q))$}
  \RightLabel{by (\ref{eq:reorder-or})}
  \UnaryInfC{$Γ ⊢ \rm{rsol}~((r ∨ (p ∨ q)) ∧ (¬ r ∨ (p ∨ q)))$}
  \RightLabel{by (\ref{eq:rsol})}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \end{bprooftree}
\end{equation*}
\end{myexample}

\end{document}
