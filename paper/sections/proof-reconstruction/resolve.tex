\documentclass[../../main.tex]{subfiles}
\begin{document}

\subsubsection{Resolution.}
\label{sssec:resolve}

Logic equivalence between propositions is a major issue to justify
prover reasoning steps. Since we left out semantics to treat only the
syntax aspects of the propositions, our approach shows equivalence
by converting propositions to their conjunctive normal forms,
and reordering those and the inner disjunctions to match them.
Below, we provide some lemmas to perform such reordering tasks,
we omit the proofs but they can found in~\cite{AgdaMetis}.

% \begin{itemize}
%   \item Reorder a disjunction $φ = φ₁ ∨ φ₂ ∨ \cdots ∨ φₙ$ to match with
% $ψ = ψ₁ ∨ ψ₂ ∨ \cdots ∨ ψₙ$. For all $i$, there exists at least one $j$ such
% that $φᵢ ≡ ψⱼ$.
%   \item Reorder a CNF formula, $φ = φ₁ ∧ φ₂ ∧ \cdots$, to match with another
% CNF formula $ψ = ψ₁ ∧ ψ₂ ∧ \cdots$. For all $i$, there exists at least one $j$
% such that $φᵢ ≡ ψⱼ$.
% \end{itemize}

First, we define \rm{rassoc}$_{⬓}$ function in~(\ref{def:right-square})
to convert a disjunctions or a conjunction into its right-associative form.
We use $\rm{rassoc}_{∧}$ to convert conjunctions and $\rm{rassoc}_{∨}$ for
disjunctions.

\begin{equation}
\label{def:right-square}
  \begin{aligned}
    &\hspace{.495mm}\rm{rassoc}_{⬓} : \Prop \to \Prop\\
    &\begin{array}{lll}
    \rm{rassoc}_{⬓} &((φ₁ ⬓ φ₂) ⬓ φ₃) &= \rm{rassoc}_{⬓}~(φ₁~⬓~(φ₂ ⬓ φ₃))\\
    \rm{rassoc}_{⬓} &(φ₁ ⬓ φ₂)        &= φ₁~∨~\rm{rassoc}_{⬓}~φ₂\\
    \rm{rassoc}_{⬓} &φ                &= φ
    \end{array}
  \end{aligned}
\end{equation}

\begin{example}\hspace{5mm}\\
\begin{enumerate}
\item $\rm{rassoc}_{∨}~(((p ∨ ((q ∨ r) ∨ s)) ∨ t) = p ∨ (q ∨ (r ∨ (s ∨ t)))$.
\item $\rm{rassoc}_{∧}~((((p ∧ q) ∧ r) ∧ s) ∧ t) = p ∧ (q ∧ (r ∧ (s ∧ t)))$.
\end{enumerate}
\end{example}

\begin{remark}
In \TPTP syntax, the formulas are in left-associative form by default.
Despite of that convention, \Metis understands a formula to be in right-associative form by default. As we mentioned above, this is a matter to take into account for
the proof-reconstruction. We opted to work as far as possible with right-associative formulas in~\cite{AgdaMetis}.
\end{remark}

\begin{mainlemma}
\label{lem:rassoc}
  If $Γ ⊢ φ$ then $Γ ⊢ \rm{rassoc}_{⬓}~φ$.
\end{mainlemma}

\begin{equation*}
 \label{eq:build-or}
  \begin{aligned}
  &\hspace{.495mm}\rm{build}_{∨} : \Prop → \Prop → \Prop\\
  &\begin{array}{llll}
    \rm{build}_{∨}&ψ~ψ &= ψ\\
    \rm{build}_{∨}&φ~(ψ₁ ∨ ψ₂)&=ψ &\text{ if }\rm{build}_{∨}~φ~ψ_{1} ≡ ψ_{1}\\
    \rm{build}_{∨}&φ~(ψ₁ ∨ ψ₂)&=ψ &\text{ if }\rm{build}_{∨}~φ~ψ_{2} ≡ ψ_{2}\\
    \rm{build}_{∨}&φ~ψ&=φ&\text{ otherwise.}
   \end{array}
  \end{aligned}
\end{equation*}

\begin{equation}
  \label{eq:ndisj-or}
  \begin{aligned}
  &\hspace{.495mm}\rm{ndisj}_{∨} : \NProp \to \NProp\\
  &\begin{array}{lll}
    \rm{ndisj}_{∨} &(¬ φ₁ ∨ φ₂) &=
        \begin{cases}
         ⊤, &\text{ if } φ₁ ∈_{∨} φ₂\\
         ⊤, &\text{ if } \rm{ndisj}_{∨}~φ₂≡ ⊤\\
         ¬ φ₁ ∨ \rm{ndisj}_{∨}~φ₂, &\text{ otherwise.}
        \end{cases}\\

  \rm{ndisj}_{∨} &(φ₁ ∨ φ₂)&=
        \begin{cases}
         ⊤, &\,\,\,\,\,\,\text{ if } ¬φ₁ ∈_{∨} φ₂ \\
         ⊤, &\,\,\,\,\,\,\text{ if } \rm{ndisj}_{∨}(φ₂) ≡ ⊤\\
         φ₁ ∨ \rm{ndisj}_{∨}~φ₂, &\,\,\,\,\,\,\text{ otherwise.}
        \end{cases}\\
    \rm{ndisj}_{∨}&φ &=φ
    \end{array}
  \end{aligned}
\end{equation}

The $\rm{build}_{∨}$ function defined above intends to construct a
disjunction from another disjunction, specifically, this functions will
try to rearrange the disjuncts in the source formula to match with the
target disjunction formula, similar as we describe above.

\begin{mainlemma}
\label{lem:build-or}
  If $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ \rm{build}_{∨}~φ~ψ$.
\end{mainlemma}

From now, we assume all propositions to be right-associative unless
otherwise stated.
The $\ffactor$ function in~(\ref{eq:factor-definition})
simplifies a special case of disjunction, the repeated disjuncts
(\eg, $\ffactor(φ ∨ φ) = φ$).
Notice that other cases like $φ ∨ (ψ ∨ φ)$ do no reduce to $ψ ∨ φ$.

\begin{mainlemma}
\label{lem:factor}
  $Γ ⊢ φ$ then $Γ ⊢ \ffactor~φ$, where,
  \begin{equation}
  \label{eq:factor-definition}
   \begin{aligned}
   &\hspace{.495mm}\ffactor : \Prop → \Prop\\
    &\begin{array}{llll}
     \ffactor&(φ₁ ∨ φ₂) &=φ₁,  &\text{ if } φ₁ ≡ \ffactor~φ₂\\
     \ffactor&φ &= φ, &\text{ otherwise.}
  \end{array}
\end{aligned}
\end{equation}
\end{mainlemma}

To construct a disjunction $ψ$ from a disjunction $φ$, we have used ideas
from the description in \citeauthor{bohme2010}~\cite{bohme2010} to prove
equality between nested disjunctions.
We define the $\rm{sbuild}_{∨}$ function in~(\ref{eq:strong-build-or}).
that uses every disjunct from the source formula, $φ$, to build up the
target disjunction $ψ$.

\begin{mainlemma}
\label{lem:sbuild-or}
If $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ \rm{sbuild}_{∨}~φ~ψ$, where,
\begin{equation}
\label{eq:strong-build-or}
 \begin{aligned}
     &\hspace{.495mm}\rm{sbuild}_{∨} : \Prop → \Prop → \Prop\\
    &\begin{array}{llll}
    \rm{sbuild}_{∨}&(φ₁ ∨ φ₂)~ψ &=\ffactor(\rm{build}_{∨}~φ₁~ψ ∨ \rm{build}_{∨}~φ₂~ψ)&\\
    \rm{build}_{∨}&φ~ψ &= \rm{build}_{∨}~φ~ψ& \text{ otherwise.}
     \end{array}
\end{aligned}
\end{equation}
\end{mainlemma}

\begin{example}
Let see the main idea behind the lem-sbuild$_{∨}$ lemma.
We build the disjunction $((p ∨ q) ∨ r)$ from the disjunction
$(r ∨ (q ∨ p))$.
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ q$}
  \RightLabel{∨-intro₂}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \AxiomC{$Γ ⊢ p$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \RightLabel{∨-elim}
  \BinaryInfC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ r$}
  \RightLabel{∨-intro₂}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \AxiomC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}

  \RightLabel{∨-elim}
  \BinaryInfC{$Γ, r ∨ (q ∨ p) ⊢ (p ∨ q) ∨ r$}

  \RightLabel{⇒-intro}
  \UnaryInfC{$Γ ⊢ r ∨ (q ∨ p) ⇒ (p ∨ q) ∨ r$}

  \end{bprooftree}
\end{equation*}
\end{example}

Notice that using $\rm{sbuild}_{∨}$ we can build not only a disjunction
with the same disjuncts of the source formula but also a complete different
formula by adding new disjuncts to the source formula.

\begin{mainlemma}
  \label{lem:reorder-or}
  If $Γ ⊢ φ$ and $ψ: \Prop$ then $Γ ⊢ \freorder_{∨}~φ~ψ~$, where,
  \begin{align*}
    \label{eq:reorder-or}
    \begin{split}
    &\freorder_{∨} : \Prop \to \Prop \to \Prop\\
    &\freorder_{∨}~φ~ψ~= \rm{sbuild}_{∨}~(rassoc_{∨}~φ)~ψ.
    \end{split}
  \end{align*}
\end{mainlemma}

\begin{proof}
Use Lemma~\ref{lem:rassoc} and Lemma~\ref{lem:sbuild-or}.
\end{proof}

We define similar functions and state some theorems as we previously did
for disjunctions, but instead, we treat only with conjunctive normal forms.

\begin{definition}[reorder$_{\boldsymbol{∧}}$]
  \begin{align*}
      \begin{split}
        &\freorder_{∧} : \Prop → \Prop \to \Prop\\
        &\freorder_{∧}~φ~ψ =
        \begin{cases}
          φ, &\text{ if }φ ≡ ψ\\
          ψ₁ ∧ ψ₂, &\text{ if } ψ ≡ ψ₁ ∧ ψ₂\text{, }\freorder_{∧}~φ~ψ₁ ≡ ψ₁\\
                  &\text{and }\freorder_{∧}~φ~ψ₂≡ ψ₂\\
          φ,       &\text{ if } ψ ≡ ψ₁ ∧ ψ₂\\
          \fconjunct~φ~ψ, &\text{ otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
\end{definition}

\begin{mainlemma}
  \label{lem:reorder-and}
  If $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ \freorder_{∧}~φ~ψ$.
\end{mainlemma}

\begin{definition}[conjunct$_{\boldsymbol{∨}}$]
  \label{eq:conjunct-or-definition}
\begin{align*}
  \begin{split}
    &\fconjunct_{∨} : \Prop → \Prop \to \Prop\\
    &\fconjunct_{∨}~φ~ψ =
    \begin{cases}
      ψ, &\text{ if }φ ≡ ψ\\
      ψ, &\text{ if }\freorder_{∨}~φ~ψ ≡ ψ\\
      ψ, &\text{ if }ψ ≡ ψ₁ ∧ ψ₂,\ \fconjunct_{∨}~φ~ψ₁ ≡ ψ₁,\\
        &\text{and } \freorder_{∨}~φ~ψ₂ ≡ ψ₂\\
      ψ, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ \fconjunct_{∨}~φ₁~ψ ≡ ψ\\
      ψ, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ \fconjunct_{∨}~φ₂~ψ ≡ ψ\\
      φ, &\text{ otherwise.}
    \end{cases}
  \end{split}
  \end{align*}
\end{definition}

\begin{mainlemma}
  \label{lem:conjunct-or}
  If $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ \fconjunct_{∨}~φ~ψ$.
\end{mainlemma}



\begin{mainlemma}
  \label{lem:reorder-and-or}
  If $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ \freorder_{∧∨}~φ~ψ$, where
   \begin{align*}
      \begin{split}
      &\freorder_{∧∨} : \Prop \to \Prop \to \Prop\\
      &\freorder_{∧∨}~φ~ψ~=
        \begin{cases}
          ψ, &\text{ if } φ≡ψ\\
          ψ, &\text{ if } ψ ≡ ψ₁ ∧ ψ₂,\ ψ₁ ≡ \freorder_{∧∨}~φ~ψ₁~\\
             &\text{and } ψ₂ ≡ \freorder_{∧∨}~φ~ψ₂~\\
          φ, &\text{ if }ψ ≡ ψ₁ ∧ ψ₂\\
          \fconjunct_{∨}~φ~ψ~ &\text{ otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
\end{mainlemma}

The \resolve rule incorporates the resolution theorem showed in
Fig.~\ref{fig:metis-inferences} for the \TSTP derivations.
This rule posses three arguments: a positive literal $l$ to apply the
resolution theorem, and two derivations.
The positive literal $l$ must occur in
the formula from the first derivation and the
negative literal must occur in the formula from the second derivation,
see the pattern of \emph{resolve} rule in Fig.~\ref{fig:metis-inferences}.

% \begin{figure}
\label{fig:resolve-tstp-example}
\begin{verbatim}
cnf(refute_0_4, plain, (~ r | p | q),
    inference(canonicalize, [], [normalize_0_5])).
cnf(refute_0_5, plain, (p | q | r),
    inference(canonicalize, [], [normalize_0_6])).
cnf(refute_0_6, plain, (p | q),
    inference(resolve, [$cnf(r)], [refute_0_5, refute_0_4])).
\end{verbatim}
% \caption{Excerpt of a \Metis \TSTP example for the \resolve rule.}
% \end{figure}

To emulate this rule, we perform a sequence of rearrangements inside the
formulas involved to match with the pattern expected by the resolution theorem
described above. We begin by defining a convenient version of
the binary resolution in Def.~\ref{eq:rsol}.

% \begin{equation}
% \label{eq:rsol}
% \begin{aligned}
% &\rm{rsol} : \Prop \to \Prop\\
%       \begin{split}
%         &\rm{rsol} : \Prop \to \Prop\\
%         &\rm{rsol}~φ =
%         \begin{cases}
%           φ₂, &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (φ₃ ∨ φ₄), φ₃ ≡ ¬ φ₁, φ₂ ≡ φ₄\\
%           φ₂ ∨ φ₄, &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (φ₃ ∨ φ₄), φ₃ ≡ ¬ φ₁\\
%           φ, &\text{ otherwise.}
%         \end{cases}
%       \end{split}
%   \end{align*}
% \end{definition}

\begin{mainlemma}
  \label{lem:rsol}
  If $Γ ⊢ φ$ then $Γ ⊢ \rm{rsol}~φ$.
\end{mainlemma}

In Def.~\ref{def:resolve}, the proposed rule for $resolve$
has four arguments. The first three were described
above, the last one, ψ, represents the expected conclusion in the \Metis
derivation.

\begin{mainth}
  \label{thm:resolve}
  If $Γ ⊢ φ₁$, $Γ ⊢ φ₂$, a literal $l : \Prop$, and $ψ : \Prop$ then
  $Γ ⊢ \fresolve~φ₁~φ₂~l~ψ$, where,
  \begin{equation}
  \begin{split}
  \label{eq:resolve}
    &\fresolve : \Prop \to \Prop \to \Prop \to \Prop \to \Prop\\
    &\fresolve~φ₁~φ₂~l~ψ =
      \rm{rsol}~(\freorder_{∨}~φ₁~(l ∨ ψ) ∧ \freorder_{∨}~φ₂~(¬ l ∨ ψ)).
  \end{split}
  \end{equation}
\end{mainth}

\Needspace{3\baselineskip}
\begin{proof}
  \begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ₁$}
    \RightLabel{Lemma~\ref{lem:reorder-and-or}}
    \UnaryInfC{$Γ ⊢ \freorder_{∨}~φ₁~(l ∨ ψ)$}
    \RightLabel{Lemma~\ref{lem:reorder-and-or}}
    \AxiomC{$Γ ⊢ φ₂$}
    \UnaryInfC{$Γ ⊢ \freorder_{∨}~φ₂~(¬ l ∨ ψ)$}
    \RightLabel{∧-intro}
    \BinaryInfC{$Γ ⊢ \freorder_{∨}~φ₁~(l ∨ ψ) ∧ \freorder_{∨}~φ₂~(¬ l ∨ ψ)$}
    \RightLabel{Lemma~\ref{lem:rsol}}
    \UnaryInfC{$Γ ⊢ \rm{rsol}~(\freorder_{∨}~φ₁~(l ∨ ψ) ∧
     \freorder_{∨}~φ₂~(¬ l ∨ ψ))$}
    \RightLabel{by (\ref{eq:resolve})}
    \UnaryInfC{$Γ ⊢ \fresolve~φ₁~φ₂~l~ψ$}
  \end{bprooftree}
  \end{equation*}
\end{proof}

\begin{example}COMPLETAR ESTE EJEMPLO AL FINAL
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ ¬ r ∨ p ∨ q$}
  \AxiomC{$Γ ⊢ p ∨ q ∨ r $}
  \RightLabel{Theorem \ref{thm:resolve}}
  \BinaryInfC{$Γ ⊢ \fresolve~(¬ r ∨ p ∨ q)~(p ∨ q ∨ r)~r~(p ∨ q)$}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \end{bprooftree}
\end{equation*}
\end{example}

\end{document}
