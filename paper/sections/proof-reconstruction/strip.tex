\documentclass[../../main.tex]{subfiles}
\begin{document}

\subsubsection{Stripping a goal.}
\label{sssec:strip-a-goal}

To prove a goal, \Metis splits the goal into
disjoint cases. This process produces a list of new subgoals, the
conjunction of these subgoals implies the goal. Then, a proof of the
goal becomes, in smaller proofs, one refutation for each subgoal.

\begin{myexample}
The subgoals mentioned above are introduced in the \TSTP derivation
with the \strip inference rule.

\begin{verbatim}
fof(goal, conjecture, (p & r) & q)).
fof(sg0, p, inf(strip, [goal])).
fof(sg1, p => r, inf(strip, [goal])).
fof(sg2, (p & r) => q, inf(strip, [goal])).
\end{verbatim}

In the script above, the conjecture $(p ∧ r) ∧ q$ is stripped in
tree subgoals: $p$, $p ⇒ r$ and $(p ∧ r) ⇒ q$.

\begin{equation}
\label{eq:strip-example}
(p ∧ (p ⇒ r) ∧ ((p ∧ r) ⇒ q)) ⇒ ((p ∧ r) ∧ q)
\end{equation}

\Metis proves each subgoal in the same order above from left to right
in (\ref{eq:strip-example}).
Besides the fact \Metis does not explicit in \TSTP derivation
how it uses the proofs of subgoals, we know using the elimination
of the implication, we get the proof of the conjecture.
\end{myexample}

We prove the correctness of the process mentioned above in
Theorem~\ref{thm:strip}. To show that theorem, we need to prove
Lemma~\ref{lem:inv-uh-lem} and Lemma~\ref{lem:lem-inv-strip}.

\begin{mainlemma}
  \label{lem:inv-uh-lem}
Let $\text{n} : \Nat$ be the complexity measure of the $\fuh_0$ function
in~(\ref{eq:uh-definition}).
If $Γ ⊢ \fuh₁~φ~n$ then $Γ ⊢ φ$, where $\fuh₁$ is the function defined
in (\ref{eq:uh-structured}).
\end{mainlemma}

\begin{proof}
The proof is by induction on the cases defined by the outcome of the
$\fuh_{1}$ function.
\begin{itemize}
  \item If $n = 0$, by definition in~(\ref{eq:uh-structured})
        we conclude $Γ ⊢ φ$.
  \item If $n = 1$, we apply the following theorem proved in~\cite{AgdaProp},
    \begin{equation*}
    \texttt{∧⇒\rm{-to-}⇒⇒}\ :\  Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃ → Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃).
    \end{equation*}
  \item For $n > 1$, we use induction on the structure of the second
        argument.
\vskip 2mm
\begin{itemize}

\item Case $φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)$.
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ \fuh_1~(φ₁ ⇒ (φ₂ ⇒ φ₃))~(\suc~n)$}
  \RightLabel{by~(\ref{eq:uh-structured})}
  \UnaryInfC{$Γ ⊢ \fuh_1~((φ₁ ∧ φ₂) ⇒ φ₃)~n$}
  \RightLabel{by hyp.}
  \UnaryInfC{Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃}
  \RightLabel{∧⇒\rm{-to-}⇒⇒}
  \UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃)}
  \end{bprooftree}
\end{equation*}

\item Case $φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃)$.
\begin{equation*}
  \scalebox{0.95}{
  ($\mathcal{D}_1$)
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ \fuh_1~(φ₁ ⇒ (φ₂ ∧ φ₃))~(\suc~n)$}
    \RightLabel{by~(\ref{eq:uh-structured})}
    \UnaryInfC{$Γ ⊢ \fuh_1~(φ₁ ⇒ φ₂)~n ∧ \fuh_1~(φ₁ ⇒ φ₃)~n$}
    \RightLabel{∧-proj₁}
    \UnaryInfC{$Γ ⊢ \fuh_1~(φ₁ ⇒ φ₂)~n$}
    \RightLabel{by hyp.}
    \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
  \end{bprooftree}
  }
\end{equation*}

\begin{equation*}
  (\mathcal{D}_2)
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ \fuh_1~(φ₁ ⇒ (φ₂ ∧ φ₃))~(\suc~n)$}
    \RightLabel{by~(\ref{eq:uh-structured})}
    \UnaryInfC{$Γ ⊢ \fuh_1~(φ₁ ⇒ φ₂)~n ∧ \fuh_1~(φ₁ ⇒ φ₃)~n$}
    \RightLabel{∧-proj₂}
    \UnaryInfC{$Γ ⊢ \fuh_1~(φ₁ ⇒ φ₃)~n$}
    \RightLabel{by hyp.}
    \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₃$}
    \end{bprooftree}
\end{equation*}

Now, using the theorem \texttt{⇒∧⇒\rm{-to-}⇒∧} from~\cite{AgdaProp},
\begin{equation*}
  \texttt{⇒∧⇒\rm{-to-}⇒∧}\ :\ Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃) → Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃),
\end{equation*}
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}_1$}
  \AxiomC{$\mathcal{D}_2$}
  \RightLabel{∧-intro}
  \BinaryInfC{$Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃)$}
  \RightLabel{\tt ⇒∧⇒\rm{-to-}⇒∧}
  \UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃)}
  \end{bprooftree}
\end{equation*}
\item Other cases are proved in a similar way.
\end{itemize}
\end{itemize}
\end{proof}

We now define the $\fstripp$ function in~(\ref{eq:strip-unfixed}) that
yields the conjunction of subgoals that implies the goal of the problem in
the \Metis \TSTP derivations. Its definition is based on the source code
of \Metis for the strip goal functions.

\begin{equation}
\label{eq:strip-unfixed}
\begin{aligned}
&\hspace{.495mm}\fstripp : \Prop → \Prop\\
&\begin{array}{lll}
\fstripp &(φ₁ ∧ φ₂)     &= \fuh~(\fstripp~φ₁) ∧ \fuh~(φ₁ ⇒ \fstripp~φ₂)\\
\fstripp &(φ₁ ∨ φ₂)     &= \fuh~(¬ φ₁ ⇒ \fstripp~φ₂)\\
\fstripp &(φ₁ ⇒ φ₂)     &= \fuh~(φ₁ ⇒ \fstripp~φ₂)\\
\fstripp &(¬ (φ₁ ∧ φ₂)) &= \fuh~(φ₁ ⇒ \fstripp~¬ φ₂)\\
\fstripp &(¬ (φ₁ ∨ φ₂)) &= \fuh~(\fstripp~¬ φ₁) ∧ \fuh~(¬ φ₁ ⇒ \fstripp~¬ φ₂)\\
\fstripp &(¬ (φ₁ ⇒ φ₂)) &= \fuh~(\fstripp~φ₁) ∧ \fuh~(φ₁ ⇒ \fstripp~¬ φ₂)\\
\fstripp &(¬ ¬ φ₁)      &= \fuh~(\fstripp~φ₁)\\
\fstripp &(¬ ⊥)         &= ⊤\\
\fstripp &(¬ ⊤)         &= ⊥\\
\fstripp &φ             &= φ
\end{array}
\end{aligned}
\end{equation}

The function defined above is not a structural recursion function. Therefore, we have reformulated it in~(\ref{eq:strip-fixed}) in order to solve such an issue following the technique described in
Section~\ref{ssec:structural-recursion}.

%  1137  git add .
%  1138  git commit -am "[ paper ] strip proof."
%  1139  git pull origin paper
%  1140  git push origin paper

\begin{equation}
\label{eq:strip-fixed}
\begin{aligned}
&\hspace{.495mm}\fstrip : \Prop → \Nat → \Prop\\
&\begin{array}{llll}
\fstrip &(φ₁ ∧ φ₂)     &(\suc~n) &= \fuh~(\fstrip~φ₁~n) ∧ \fuh~(φ₁ ⇒ \fstrip~φ₂~n)\\
\fstrip &(φ₁ ∨ φ₂)     &(\suc~n) &= \fuh~(¬ φ₁ ⇒ \fstrip~φ₂~n)\\
\fstrip &(φ₁ ⇒ φ₂)     &(\suc~n) &= \fuh~(φ₁ ⇒ \fstrip~φ₂~n)\\
\fstrip &(¬ (φ₁ ∧ φ₂)) &(\suc~n) &= \fuh~(φ₁ ⇒ \fstrip~¬ φ₂~n)\\
\fstrip &(¬ (φ₁ ∨ φ₂)) &(\suc~n) &= \fuh~(\fstrip~¬ φ₁~n) ∧ \fuh~(¬ φ₁ ⇒ \fstrip~¬ φ₂~n)\\
\fstrip &(¬ (φ₁ ⇒ φ₂)) &(\suc~n) &= \fuh~(\fstrip~φ₁~n) ∧ \fuh~(φ₁ ⇒ \fstrip~¬ φ₂~n)\\
\fstrip &(¬ ¬ φ₁)      &(\suc~n) &= \fuh~(\fstrip~φ₁~n)\\
\fstrip &(¬ ⊥)         &(\suc~n) &= ⊤\\
\fstrip &(¬ ⊤)         &(\suc~n) &= ⊥\\
\fstrip &φ             &\text{n} &= φ
\end{array}
\end{aligned}
\end{equation}

\begin{mainlemma}
\label{lem:lem-inv-strip}
Let $\text{n} : \Nat$ be the complexity measure of the strip function defined
in~(\ref{eq:strip-fixed}).
If $Γ ⊢ \fstrip~φ~n$ then $Γ ⊢ φ$.
\end{mainlemma}

\begin{proof}
The proof is by induction on the structure of the
formula~$φ$ by following the cases in~(\ref{eq:strip-fixed}).
We present a straightforward case with double negation, a case with
conjunction connective, and last, the case with a negated disjunction.
We refer the reader to~\cite{AgdaMetis} for the complete proof in \Agda.

$\bullet$~Case $φ ≡ ¬ ¬ φ₁$.
\begin{equation*}
  \begin{bprooftree}
 \AxiomC{$Γ ⊢ \fstrip~(¬¬φ₁)~(\suc~n)$}
  \RightLabel{by~(\ref{eq:strip-fixed})}
  \UnaryInfC{$Γ ⊢ \fuh~(\fstrip~φ₁~n)$}
  \RightLabel{Lemma~\ref{lem:inv-uh-lem}}
  \UnaryInfC{$Γ ⊢ \fstrip~φ₁~n$}
  \RightLabel{by hyp.}
  \UnaryInfC{$Γ ⊢ φ₁$}
  \end{bprooftree}
\end{equation*}

$\bullet$~Case $φ ≡ φ₁ ∧ φ₂$. We get a proof for each conjunct and using the
introduction rule for conjunction connective, the expected result follows.

\begin{equation*}
(\mathcal{D})\hspace{3mm}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ \fstrip~(φ₁ ∧ φ₂)~(\suc~n)$}
  \RightLabel{by~(\ref{eq:strip-fixed})}
  \UnaryInfC{$Γ ⊢ \fuh~(\fstrip~φ₁~n) ∧ \fuh~(φ₁ ⇒ \fstrip~φ₂~n)$}
  \RightLabel{∧-proj₁}
  \UnaryInfC{$Γ ⊢ \fuh~(\fstrip~φ₁~n)$}
  \RightLabel{Lemma~\ref{lem:inv-uh-lem}}
  \UnaryInfC{$Γ ⊢ \fstrip~φ₁~n$}
  \RightLabel{by hyp.}
  \UnaryInfC{$Γ ⊢ φ₁$}
    \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}$}
  \UnaryInfC{Γ ⊢ φ₁}
  \AxiomC{$Γ ⊢ \fstrip~(φ₁ ∧ φ₂)~(\suc~n)$}
  \RightLabel{by~(\ref{eq:strip-fixed})}
  \UnaryInfC{$Γ ⊢ \fuh~(\fstrip~φ₁~n) ∧ \fuh~(φ₁ ⇒ \fstrip~φ₂~n)$}
  \RightLabel{$∧$-proj$₂$}
  \UnaryInfC{$Γ ⊢ \fuh~(φ₁ ⇒ \fstrip~φ₂~n)$}
  \RightLabel{Lemma~\ref{lem:inv-uh-lem}}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ \fstrip~φ₂~n$}
  \RightLabel{$⇒$-elim}
  \BinaryInfC{$Γ ⊢ \fstrip~φ₂~n$}
  \RightLabel{by hyp.}
  \UnaryInfC{$Γ ⊢ φ₂$}
  \end{bprooftree}
\end{equation*}

$\bullet$~Case $φ ≡ ¬ (φ₁ ∨ φ₂)$.
We show the theorems $Γ ⊢ ¬ φ₁$ and $Γ ⊢ ¬ φ₂$.
With the conjunction of $¬ φ₁$ and $¬ φ₂$ by applying De Morgan Law, the
result follows.

\begin{equation*}
(\mathcal{D})\hspace{3mm}
\begin{bprooftree}
\AxiomC{$Γ ⊢ \fstrip~(¬ (φ₁ ∨ φ₂))~(\suc~n)$}
\RightLabel{by~(\ref{eq:strip-fixed})}
\UnaryInfC{$Γ ⊢ \fuh~(\fstrip~¬ φ₁~n) ∧ \fuh~(¬ φ₁ ⇒ \fstrip~¬ φ₂~n)$}
\RightLabel{∧-proj₁}
\UnaryInfC{$Γ ⊢ \fuh~(\fstrip~¬ φ₁~n)$}
\RightLabel{Lemma~\ref{lem:inv-uh-lem}}
\UnaryInfC{$Γ ⊢ \fstrip~¬ φ₁~n$}
\RightLabel{by hyp.}
  \UnaryInfC{$Γ ⊢ ¬φ₁$}
\end{bprooftree}
\end{equation*}
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}$}
  \UnaryInfC{$Γ ⊢ ¬ φ₁$}
  \AxiomC{$Γ ⊢ \fstrip~(¬ (φ₁ ∨ φ₂))~(\suc~n)$}
  \RightLabel{by~(\ref{eq:strip-fixed})}
  \UnaryInfC{$Γ ⊢ \fuh~(\fstrip~¬ φ₁~n) ∧ \fuh~(¬ φ₁ ⇒ \fstrip~¬ φ₂~n)$}
  \RightLabel{∧-proj₂}
  \UnaryInfC{$Γ ⊢ \fuh~(¬ φ₁ ⇒ \fstrip~¬ φ₂~n)$}
  \RightLabel{Lemma~\ref{lem:inv-uh-lem}}
  \UnaryInfC{$Γ ⊢ ¬ φ₁ ⇒ \fstrip~¬ φ₂~n$}
  \RightLabel{⇒-elim}
  \BinaryInfC{$Γ ⊢ \fstrip~¬ φ₂~n$}
  \RightLabel{by hyp.}
  \UnaryInfC{$Γ ⊢ ¬ φ₂$}
  \end{bprooftree}
\end{equation*}
\end{proof} % the proof continue...

The following theorem is convenient to substitute equals by equals in
a theorem. Recall the equality is symmetric and transitive as well.
We use such properties without any mention.

\begin{mainlemma}[subst]
  \label{lem:subst}
  Substitution theorem.
\begin{equation*}
  \label{eq:substitution-theorem}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ φ$}   \AxiomC{$ψ ≡ φ$}
  \RightLabel{subst}
  \BinaryInfC{$Γ ⊢ ψ$}
  \end{bprooftree}
\end{equation*}
\end{mainlemma}

We can now formulate the result that justifies the stripping strategy
of \Metis to prove goals.
For the sake of brevity, we state the following theorem for the
\strip function when the goal has only two subgoals. In other cases,
we extend that theorem in the natural way.

\begin{mainth}
\label{thm:strip}
Let $\text{n} : \Nat$ be the complexity measure of the strip function defined
in~(\ref{eq:strip-fixed}).
If $s_1$ and $s_2$ are the subgoals of the goal $φ$, that is,
$$\fstrip~φ~n~≡~s_1∧~s_2,$$
if $Γ ⊢ s_1$ and $Γ ⊢ s_2$ then $Γ ⊢ φ$.
\end{mainth}

\begin{proof}
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$ Γ ⊢ s_1 $}
  \AxiomC{$ Γ ⊢ s_2 $}
  \RightLabel{∧-intro}
  \BinaryInfC{$Γ ⊢ s_1\wedge s_2$}
  \AxiomC{$\fstrip~φ~n ≡ s_1\wedge s_2 $}
  \RightLabel{subst}
  \BinaryInfC{$Γ ⊢ \fstrip~φ~n$}
  \RightLabel{Lemma~\ref{lem:lem-inv-strip}}
  \UnaryInfC{$Γ ⊢ φ$}
\end{bprooftree}
\end{equation*}
\end{proof}


% -------------------------------------------------------------------

\end{document}
