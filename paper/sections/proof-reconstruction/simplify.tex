\documentclass[../../main.tex]{subfiles}
\begin{document}

\subsubsection{Simplification.}
\label{sssec:simplify}

The \simplify rule is an inference that performs simplification of definitions
and tautologies. This rule transverses a list of previous derivations by
applying the theorems for $\fsimplify_{∧}$ and $\fsimplify_{∨}$ functions among
others to get a contradiction in the first place, or a
new formula to use later in the derivation.

We observe based on the analysis of different
cases in the \TSTP derivations that \simplify can be modeled by a
function with three arguments: two source formulas and the target formula.

Since the main purpose of the \simplify rule is simplification, we first describe
in \eqref{def:remove-literal}, the auxiliary function $\freduce_{ℓ}$ to remove a
a negated literal from an formula.

\begin{equation}
\label{def:remove-literal}
  \begin{aligned}
  &\hspace{.495mm}\freduce : \Prop → \Lit → \Prop\hspace*{3.5cm}\\
  &\begin{array}{llll}
\freduce_{ℓ} &(φ₁~∧~φ₂)~&ℓ~=~\fsimplify_{∧}~(\freduce_{ℓ}~φ₁~ℓ~∧~\freduce_{ℓ}~φ₂~ℓ)\\
\freduce_{ℓ} &(φ₁~∨~φ₂)~&ℓ~=~\fsimplify_{∨}~(\freduce_{ℓ}~φ₁~ℓ~∨~\freduce_{ℓ}~φ₂~ℓ) \\[2mm]
\freduce_{ℓ} &φ &ℓ = \begin{cases}
⊥,  &\text{ if }φ\text{ is a literal and }ℓ ≡ \fnnf(¬ φ);\\
φ,  &\text{ otherwise.}
\end{cases}
   \end{array}
  \end{aligned}
\end{equation}

As we see in~\eqref{eq:simplify-1}, if \fsimplify gets ⊥
from its input derivations, it derives ⊥. When the target formula, the expected conclusion is ⊤, we derive immediately ⊤.
Otherwise, the \fsimplify rule performs an analysis by following the cases to determine which case should apply.

 \begin{equation}
  \label{eq:simplify-1}
  \begin{aligned}
  &\hspace{.495mm}\fsimplify : \Source → \Source → \Target → \Prop\hspace*{3.5cm}\\
  &\begin{array}{ll}
   \fsimplify~⊥~φ~ψ  &=ψ\\
   \fsimplify~φ~⊥~ψ  &=ψ\\
%   \fsimplify~φ₁~φ₂~⊤ &=⊤.
  \end{array}
  \end{aligned}
  \end{equation}

\begin{equation}
\label{def:simplify}
  \begin{aligned}
  &\begin{array}{llll}
\fsimplify~&φ₁~&(φ₂₁ ∧ φ₂₂)~&ψ=~\fsimplify_{∧}~(\fsimplify~φ₁~φ₂₁~ψ)~φ₂₂~ψ\\
\fsimplify~&φ₁~&(φ₂₁ ∨ φ₂₂)~&ψ=~\fsimplify_{∨}~(\fsimplify~φ₁~φ₂₁~∨~\fsimplify~φ₁~φ₂₂~ψ) \\[2mm]
\fsimplify~&φ₁~&φ₂~&ψ =
\begin{cases}
\freduce_{ℓ}~φ₁~φ₂,
&\text{ if }φ₂\text{ is a literal;}\\
φ₁,  &\text{ otherwise.}
\end{cases}
   \end{array}
  \end{aligned}
\end{equation}


\begin{mainth}
  \label{thm:simplify}
  Let $ψ : \Target$ and for $i=1,\dots, n$ $Γ ⊢ φᵢ$. If $n > 2$
  then $Γ ⊢ \fsimplify~γ_{n-2}~φ_{n}~ψ$, where
  $γ_{i} = \fsimplify~φ_{i}~φ_{i+1}~ψ$, else $Γ ⊢ \fsimplify~φ₁~φ₂~ψ$.
\end{mainth}

\begin{myremark}
Besides the fact that $\List\ \Prop \to \Prop$ is the type that most
fit with the \simplify rule, we choose a different
option. In the translation from \TSTP to \Agda, we take the list of
derivations and we apply the rule by using a left folding ($\rm{foldl}$) with the
$\fsimplify$ function over the list of $φ₁, φ₂, \cdots, φₙ$
that avoids us to define a new theorem type to
support \List \Prop type in the conclusion side.
\end{myremark}


\begin{myexamplenum}
Let us review the following \TSTP excerpt where \simplify was used two times.

\begin{verbatim}
  fof(n0, (¬ p ∨ q) ∧ ¬ r ∧ ¬ q ∧ (p ∨ (¬ s ∨ r)), ...
  fof(n1, p ∨ (¬ s ∨ r), inf(conjunct, n0)).
  fof(n2, ¬ p ∨ q, inf(conjunct, n0)).
  fof(n3, ¬ q, inf(conjunct, n0)).
  fof(n4, ¬ p, inf(simplify, [n2, n3])).
  fof(n5, ¬ r, inf(conjunct, n0)).
  fof(n6, ⊥, inf(simplify, [n1, n4, n5])).
\end{verbatim}

\begin{enumerate}
\item The \simplify rule derives $¬ p$ in \verb!n4!
from \verb!n2! and \verb!n3! derivations.

$$\fsimplify~(¬ p ∨ q)~(¬ q)~(¬ p) = ¬ p.$$
% \begin{verbatim}
% fof(norm2, ¬ p ∨ q, inf(conjunct, [norm0])).
% fof(norm3, ¬ q, inf(conjunct, [norm0])).
% fof(norm4, ¬ p, inf(simplify, [norm2, norm3])).
% \end{verbatim}
\item To derive ⊥ in \verb!n6! we use
Theorem~\ref{thm:simplify} and we get the following proof.

\begin{equation*}
\begin{bprooftree}
\AxiomC{$Γ ⊢ p ∨ (¬ s ∧ r)$}
\AxiomC{$Γ ⊢ ¬ p$}
\RightLabel{Theorem~\ref{thm:simplify}}
\BinaryInfC{$Γ ⊢ ¬ s ∧ r$}
\AxiomC{$Γ ⊢ ¬ r$}
\RightLabel{Theorem~\ref{thm:simplify}}
\BinaryInfC{$Γ ⊢ ⊥$}
\end{bprooftree}
\end{equation*}

% \begin{verbatim}
% fof(n1, g ∨ (¬ s ∧ r), inf(conjunct, [n0])).
% fof(n4, ¬ p, inf(simplify, [n2, n3])).
% fof(n5, ¬ r, inf(conjunct, [n0])).
% fof(n6, ⊥, inf(simplify, [n1, n4, n5])).
% \end{verbatim}
\end{enumerate}
\end{myexamplenum}


% subsubsection simplify (end)
% -------------------------------------------------------------------

\end{document}
