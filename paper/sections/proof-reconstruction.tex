
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Proof-Reconstruction}
\label{sec:proof-reconstruction}

\subsection{Workflow}
\label{ssec:workflow}

\input{sections/diagram.tex}

The proof-reconstruction approach proposed here consists of a series
of steps similar to the workflow presented by \citeauthor{sultana2015} in
\cite{sultana2015}. This process is a translation from a source
system to a target system. In our case, the system of origin, the
automatic theorem prover, is \Metis; the target system is a proof
assistant, \Agda. We choose \Agda, but another proof assistant with the same support of type theory and inductive types is valid (see a description of \Agda for its main features in
Section~\ref{sec:implementation}).
The overview of the proof-reconstruction is presented in
Fig.~\ref{fig:proof-reconstruction-workflow}, the process begin with
a \TPTP file that encodes a problem in \CPL. We use this file as the
input of the \Metis prover and if the problem is a theorem, \Metis can reply with a derivation in \TSTP format of the proof.

With the \TSTP  derivation from the Step~2, we process the derivation with the \Athena translator tool~\cite{Athena}.
\Athena parses the \TSTP format, analyzes the
derivation and generates a representation of the natural deduction
proof using a tree data structure (see the properties
of this tree in Section~\ref{sssec:metis-proofs}).
We perform an analysis of the proof-tree to remove some
unnecessary steps that introduce redundancies or unused input for
\Athena.

As a result of using \Athena, we get an \Agda file, the proof-term. To generate this file, \Athena has used names of functions and theorems from \Agda libraries:
\texttt{agda-prop}~\cite{AgdaProp}, and \texttt{agda-metis}~\cite{AgdaMetis}.


Finally, we type-check the \Agda proof-term. If type-checking
succeed, the \TSTP derivation delivered by \Metis was correct.
In that case \Agda outputs an interface file.
Otherwise, when type-checking fails, the failure must be
investigated by the user, checking for the error in \Metis, \Athena,
or in \Agda.

In the rest of this section, we provide a formal description using
type theory to build definitions and theorems for functions
necessary to emulate \Metis' inference rules. For this description,
we will write the type judgments with ``$a : A$'' to denote that $a$
has $\abbre{A}$ type. Types are written using small caps.
We use \Prop type for propositions and a the dependent type, $Γ ⊢ φ$ for theorems. In the latter type, $Γ$ has $\abbre{List}~\Prop$ type
and $φ$ has type $\Prop$. $\abbre{List}$ is the usual inductive type
for lists. Finally, we will denote by $φ ≡ ψ$, the syntactic
equivalence between propositions.

% ...................................................................

% section section_name (end)
\subsection{Structural Recursion}
\label{ssec:structural-recursion}

To emulate \Metis' inference rules in type theory,
we observed that transformations performed by some rules were given by \emph{general recursive} functions.
But algorithms based on general recursions can not be translated
directly in type theory since it is not a guarantee they terminate.
For that reason, we present in this section, a technique to avoid
such termination problems by modifying the recursive functions
to be \emph{structural recursive}.
% (see \cite{Coquand1992,Abel2002,Bove2005} for more details).

We adopt the notion of \emph{structurally smaller} from
\citeauthor{Abel2002}~\cite{Abel2002} to say, a recursive function is
structurally recursive if it calls itself with only
\emph{structurally smaller}
arguments.

General recursive calls can be translated into structurally recursive
calls by using for instance, the \emph{Bounded Recursion} technique
presented in~\cite{Bertot2004}. For a yet another method, we refer
the reader to \cite{Coquand1992,Abel2002,Bove2005}.
The former technique defines a new function based on the original
recursive function by adding an additional argument to the function.
The new argument is the \emph{bound}, a natural number given by the
function complexity. In other words, the added argument will store
the number of times the function needs to call itself to get the
expected outcome.

Henceforth, a natural number has \Nat type, and it is defined as
usual. That is, \zero and \suc are the data constructors and some
arithmetic operations are defined: ($+,\,-,\,*$). We include syntax
sugar for $\zero$, $\suc$, $\suc(\zero)$, $\cdots$, with the
classical representation: $1$, $2$, $\cdots$ as well.

Therefore, for a general recursive function $f: \Prop \to \Prop$
with termination problems, we states a new function $f^{*} : \Prop \to \Nat \to \Prop$ where all recursive calls must done by
using induction on the \Nat type structure.

\subsubsection{A practical Example.}
Let us consider the following example to exhibit the technique
mentioned above for an inner function present in the emulated version
of the \strip inference.

\begin{align}
\begin{split}
\label{eq:unshunt-definition}
&unshunt_{0}(φ) =\\
&\hspace{3mm}\begin{cases}
unshunt_{0}((φ₁ ∧ φ₂) ⇒ φ₃),
  & \text{if }φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\
unshunt_{0}(φ₁ ⇒ φ₂) ∧ unshunt_{0}(φ₁ ⇒ φ₃),
  & \text{if }φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃)\\
φ, &\text{otherwise.}
\end{cases}
\end{split}
\end{align}

From the definition above, the size of the argument, ((φ₁ ∧ φ₂) ⇒ φ₃),
is not structurally smaller than the input formula, (φ₁ ⇒ (φ₂ ⇒ φ₃)),
since ((φ₁ ∧ φ₂) ⇒ φ₃) is not a subformula of (φ₁ ⇒ (φ₂ ⇒ φ₃)).

Thus, we define the function
$unshunt_{1} : \Prop \to \Nat \to \Prop$
by structural recursion in its second argument in
Eq.~(\ref{eq:unshunt-structured}).

\begin{align}
\label{eq:unshunt-structured}
\begin{split}
&unshunt_{1}(φ, \zero)\hspace{3mm}= φ\\
&unshunt_{1}(φ, \suc(n)) =\\
&\hspace{3mm}\begin{cases}
unshunt_{1}((φ₁ ∧ φ₂) ⇒ φ₃, n),
  &\text{if } φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\[2mm]
unshunt_{1}(φ₁ ⇒ φ₂, n)\\
∧\ unshunt_{1}(φ₁ ⇒ φ₃, n),
   &\text{if } φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃).
\end{cases}
\end{split}
\end{align}

As we mentioned above, the natural number in the second argument of
the function used in Eq.~(\ref{eq:unshunt-structured}) stands for a
complexity measure of the function, in this case $unshunt_{1}$ function.

Recall, the \emph{complexity measure} defined in \cite{Agudelo-Agudelo2017}
and presented in \cite{VanDalen1994} as \emph{the rank for a
proposition}, is a function $\Prop \to \Nat$ that assigns a natural
number for a proposition $φ$ like the following $rank$ function.
The symbols, $c_{¬}$ and $c_{\square}$ is a non-negative integer
number called the complexity of the connective.

\begin{equation*}
\label{eq:rank-definition}
rank(φ)=
\begin{cases}
0, &\text{for atomic }φ \\
rank(φ₁) + c_{¬},  &\text{if } φ ≡ \neg φ₁ \\
\max{(rank(φ₁),rank(φ₂))} + c_{\square},
  &\text{if } φ ≡ φ₁\,\square\, φ₂.
\end{cases}
\end{equation*}

In the case of the $unshunt_0$ function in
Eq.~(\ref{eq:unshunt-definition}), we define the complexity function
$unshunt_{cm}: \Prop → \NN$ for our $unshunt_{1}$
presented in Eq.~(\ref{eq:unshunt-rank-definition}).

\begin{align}
\begin{split}
\label{eq:unshunt-rank-definition}
&unshunt_{cm}(φ) =\\
&\hspace{3mm}
\begin{cases}
unshunt_{cm}(φ₃) + 2, &\text{if }φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\
\max(unshunt_{cm}(φ₂),unshunt_{cm}(φ₃)) + 1,
  &\text{if }  φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃)\\
0, &\text{otherwise.}
\end{cases}
\end{split}
\end{align}

Finally, following the technique mentioned, we get a curated version of
$unshunt_{0}$ function presented in Eq.~(\ref{eq:unshunt-fixed}).

\begin{definition}[unshunt]
\begin{equation}
\label{eq:unshunt-fixed}
unshunt(\varphi) := unshunt_{1}(\varphi, unshunt_{cm}(\varphi)).
\end{equation}
\end{definition}

For a more complete treatment of general recursion, and how to
define well-founded and well-structural recursive functions, we refer
the reader to Ref.~\cite{Bove2005}, where Bove and Capettra described
not only general recursion, but they also treat mutual recursive
function, among other kinds.

% % ................................................

\subsection{Emulating \Metis' Inference Rules}
\label{ssec:emulating-inferences}


\subsubsection{Splitting a Goal.}
\label{sssec:splitting-goal}

 To prove a goal, \Metis splits the goal into
disjoint cases. This process produces a list of new subgoals, the
conjunction of these subgoals implies the goal. Then, a proof of the
goal becomes in smaller proofs, one refutation for each subgoal.
These subgoals are introduced in the \TSTP derivation with the \strip
inference rule.

\begin{verbatim}
fof(goal, conjecture, p & r & q).
fof(subgoal_0, plain, p, inference(strip, [], [goal])).
fof(subgoal_1, plain, p => r, inference(strip, [], [goal])).
fof(subgoal_2, plain, (p & r) => q, inference(strip, [], [goal])).
\end{verbatim}

In the following, we show how Theorem~\ref{thm:thm-strip} proves the
correctness of the process mentioned above. But first, let us prove some
lemmas for $unshunt$ function presented in Eq.~(\ref{eq:unshunt-fixed}),
and $split$ function from the definition in Eq.~(\ref{eq:split-definition}).

\begin{lemma}[lem-unshunt]
  \label{lem:unshunt}
  $Γ ⊢ unshunt(φ)$, then $Γ ⊢ φ$.
\end{lemma}

\begin{proof} Use induction on the cases defined by the outcome of the
$unshunt$ function in Eq.~(\ref{eq:unshunt-structured}).
\begin{itemize}
	\item When $n = 0$, by definition, $Γ ⊢ φ$.
	\item When $n = 1$, we apply the following theorem from~\cite{AgdaProp}
		\begin{equation*}
		\texttt{∧⇒-to-⇒⇒}\ :\  Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃ → Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃).
		\end{equation*}
  \item For $n > 1$, we will use induction on the structure of the second
			  argument.

\begin{itemize}
\item $(φ₁ ⇒ (φ₂ ⇒ φ₃))$
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n)$}
  \RightLabel{By def.}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n-1)$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃}
  \RightLabel{∧⇒-to-⇒⇒}
  \UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃).}
  \end{bprooftree}
\end{equation*}

\item $(φ₁ ⇒ (φ₂ ∧ φ₃))$
\begin{equation*}
\scalebox{0.95}{
($\mathcal{D}_1$)
\begin{bprooftree}
\AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n) ∧ unshunt(φ₁ ⇒ φ₃, n)$}
\RightLabel{∧-proj₁}
\UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n-1)$}
\RightLabel{lem-unshunt}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$,}
\end{bprooftree}
}
\end{equation*}

\begin{equation*}
(\mathcal{D}_2)
\begin{bprooftree}
\AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂) ∧ unshunt(φ₁ ⇒ φ₃)$}
\RightLabel{∧-proj₂}
\UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₃, n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₃, n-1)$}
\RightLabel{lem-unshunt,}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₃$}
\end{bprooftree}
\end{equation*}
Finally, using the theorem, \texttt{⇒∧⇒-to-⇒∧} from~\cite{AgdaProp},
\begin{equation*}
  \texttt{⇒∧⇒-to-⇒∧}\ :\ Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃) → Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃).
\end{equation*}
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}_1$}
  \AxiomC{$\mathcal{D}_2$}
  \RightLabel{∧-intro}
  \BinaryInfC{$Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃)$}
  \RightLabel{\tt ⇒∧⇒-to-⇒∧.}
  \UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃)}
  \end{bprooftree}
\end{equation*}

\end{itemize}
\end{itemize}

\end{proof}

Let us now consider the $split$ function presented in
Eq.~(\ref{eq:split-definition}) that yields the conjunction of subgoals that implies the goal in a \Metis \TSTP derivation.

\begin{definition}[split]
\begin{equation}
\label{eq:split-definition}
\mysplit(φ) =
\begin{cases}
unshunt(\mysplit(φ₁)) &\text{if }φ ≡ φ₁ ∧ φ₂\\
∧\ unshunt(φ₁ ⇒ \mysplit(φ₂)), &\\[2.5mm]
unshunt(¬ φ₁ ⇒ \mysplit(φ₂)),
  & \text{if }φ ≡ φ₁ ∨ φ₂\\[2.5mm]
unshunt(φ₁ ⇒ \mysplit(φ₂)),
  & \text{if }φ ≡ φ₁ ⇒ φ₂\\[2.5mm]
unshunt(φ₁ ⇒ \mysplit(φ₂))
  & \text{if }φ ≡ φ₁ ⇔ φ₂\\
∧\ unshunt(φ₂ ⇒ \mysplit(φ₁)),
  &\\[2.5mm]
unshunt(φ₁ ⇒ \mysplit(¬ φ₂)),
  & \text{if }φ ≡ ¬ (φ₁ ∧ φ₂)\\[2.5mm]
unshunt(\mysplit(¬ φ₁))
  & \text{if }φ ≡ ¬ (φ₁ ∨ φ₂)\\
∧\ unshunt(¬ φ₁ ⇒ \mysplit(¬ φ₂)),
  &\\[2.5mm]
unshunt(\mysplit(φ₁))
  & \text{if }φ ≡ ¬ (φ₁ ⇒ φ₂)\\
∧\ unshunt(φ₁ ⇒ \mysplit(¬ φ₂)),
  &\\[2.5mm]
unshunt(φ₁ ⇒ \mysplit(¬ φ₂))
  & \text{if }φ ≡ ¬ (φ₁ ⇔ φ₂)\\
∧\ unshunt(¬ φ₂ ⇒ \mysplit(φ₁)),
  &\\[2.5mm]
unshunt(\mysplit(φ₁)),
  & \text{if }φ ≡ ¬ ¬ φ₁\\
⊤,
  & \text{if }φ ≡ ¬ ⊥\\
⊥,
  & \text{if }φ ≡ ¬ ⊤.
\end{cases}
\end{equation}
\end{definition}

The definition above suffers termination problems since it is not
a structural recursion. Therefore, we have reformulated the equation above to solve such a issue following the technique
described in Section~\ref{ssec:structural-recursion}.

Here and below, we refer to $split$ as the function after applying
the process mentioned above.

\begin{lemma}[\thmsplit] $Γ ⊢ \mysplit(φ)$ then $Γ ⊢ φ$.
\label{lem:lem-split}
\end{lemma}

\begin{proof} We now proceed by induction on the structure of the
formula φ in the definition of Eq.~(\ref{eq:split-definition}).
For a complete proof, we refer the reader to~\cite{AgdaMetis}.\\[3mm]

($φ ≡ φ₁ ∧ φ₂$). We get a proof for each conjunct and using the introduction rule for conjunction, the result follows.

\begin{equation*}
(\mathcal{D})\hspace{3mm}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ \mysplit(φ,n)$}
  \RightLabel{By def.}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁) ∧ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{∧-proj₁}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁)$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢ φ₁$.}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}$}
  \UnaryInfC{Γ ⊢ φ₁}
  \AxiomC{$Γ ⊢ \mysplit(φ,n)$}
  \RightLabel{By def.}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁) ∧ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{$∧$-proj$₂$}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{$⇒$-elim}
  \BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
  \RightLabel{\thmsplit}
  \UnaryInfC{$Γ ⊢ φ₂.$}
  \end{bprooftree}
\end{equation*}

\vskip 3mm

($φ ≡ φ₁ ⇒ φ₂$).
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{}
  \RightLabel{assume φ₁}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁$}
  \AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
  \RightLabel{By def.}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{weaken φ₁}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{⇒-elim}
  \BinaryInfC{$Γ , φ₁ ⊢ \mysplit(φ₂,n-1)$}
  \RightLabel{\thmsplit}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₂$}
  \RightLabel{⇒-intro}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$.}
  \end{bprooftree}
\end{equation*}
\vskip 3mm

(φ ≡ ¬ (φ₁ ∨ φ₂)). We show $Γ ⊢ ¬ φ₁$ and $Γ ⊢ ¬ φ₂$. Using their conjunction by the introduction rule, and De Morgan Law, the results follows.

\begin{equation*}
(\mathcal{D})\hspace{3mm}
\begin{bprooftree}
\AxiomC{$Γ ⊢ \mysplit(φ, n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ unshunt(¬ φ₁) ∧ unshunt(¬ φ₁ ⇒ \mysplit(φ₂, n))$}
\RightLabel{∧-proj₁}
\UnaryInfC{$Γ ⊢ unshunt(¬ φ₁)$}
\RightLabel{lem-unshunt}
\UnaryInfC{$Γ ⊢ ¬ φ₁$,}
\end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}$}
  \UnaryInfC{$Γ ⊢ ¬ φ₁$}

  \AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
  \RightLabel{By def.}
  \UnaryInfC{$Γ ⊢ unshunt(¬ φ₁) ∧ unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{∧-proj₂}
  \UnaryInfC{$Γ ⊢ unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢ ¬ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{⇒-elim}
  \BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
  \RightLabel{\thmsplit}
  \UnaryInfC{$Γ ⊢ ¬ φ₂.$}
  \end{bprooftree}
\end{equation*}
\end{proof}

\begin{theorem}[thm-strip]
\label{thm:thm-strip}
 If $s_i$ are the subgoals for the goal φ, and
$\{ Γ ⊢ s_i \}_{i}$, then $Γ ⊢ φ$.
\end{theorem}

\begin{proof}
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\left\{ Γ ⊢ s_i \right\}_{i}$}
  \RightLabel{∧-intro}
  \UnaryInfC{$Γ ⊢ \bigwedge_i s_i$}

  \AxiomC{$\mysplit(φ) ≡ \bigwedge_i s_i $}
  \RightLabel{subst}
  \BinaryInfC{$Γ ⊢ \mysplit(φ) $}

  \RightLabel{\thmsplit}
  \UnaryInfC{$Γ ⊢ φ$.}
\end{bprooftree}
\end{equation*}
Where, the $subst$ theorem is,
\begin{equation}
  \label{eq:substitution-theorem}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ φ$}   \AxiomC{$ψ ≡ φ$}
  \RightLabel{subst}
  \BinaryInfC{$Γ ⊢ ψ$.}
  \end{bprooftree}
\end{equation}
\end{proof}

% % -------------------------------------------------------------------
% \subsubsection{splitting a Conjunct}
% \label{sssec:splitting-a-conjunct}

% The \conjunct rule extracts from a conjunction, one of its conjunct.
% To achieve this, we use projections repeatedly until we finally find
% the conjunct required.

% \begin{align}
%   \begin{split}
%   conjunct(φ, ψ) =
%     \begin{cases}
%       ψ, &\text{if }φ ≡ ψ\\
%       ψ, &\text{if }φ ≡ φ₁ ∧ φ₁\text{ and }conjunct(φ₁, ψ)≡ ψ\\
%       ψ, &\text{if }φ ≡ φ₁ ∧ φ₁\text{ and }conjunct(φ₂, ψ)≡ ψ\\
%       φ, &\text{otherwise.}
%     \end{cases}
%   \end{split}
% \end{align}

% \begin{theorem}[thm-conjunct]
%   \label{thm:thm-conjunct}
%   $Γ ⊢ φ$, and $ψ \in \Prop$ , then $Γ ⊢ conjunct(φ, ψ)$.
% \end{theorem}

% \begin{proof}
% When φ ≡ ψ, from $Γ ⊢ conjunct(φ, ψ)$ by normalization, we get $Γ ⊢ ψ$.
% By using $subst$ theorem Eq.~(\ref{eq:substitution-theorem}), we get the desire conclusion. If the proposition φ is a conjunction, and $ψ ≡ conjunct(φ_{i}, ψ)$
% for some $i = 1,\ 2$, then,

% \begin{equation}
%   \begin{bprooftree}
%   \AxiomC{$Γ ⊢ φ₁ ∧ φ₂$}
%   \RightLabel{∧-proj$_{i}$}
%   \UnaryInfC{$Γ ⊢ φ_{i}$}
%   \UnaryInfC{$Γ ⊢ conjunct(φ_{i}, ψ)$}
%   \AxiomC{$conjunct(φ_{i}, ψ) ≡ ψ$}
%   \RightLabel{subst}
%   \BinaryInfC{$Γ ⊢ ψ$.}
%   \end{bprooftree}
% \end{equation}

% The last statement follows by using the hypothesis and the proof is complete.
% \end{proof}

% % subsubsection splitting-a-conjunct (end)
% % -------------------------------------------------------------------

% % ------------------------------------------------------------------------

% \subsubsection{Reordering.}

% Syntactically speaking, showing the logic equivalence between two conjunctive normal forms is a matter of rearrangements of the conjunctions
% but also of the inner disjunctions inside the propositions involved.
% \improvement{Make clear: we are dealing with CNFs, and prove equivalence between two formulas is equivalent to show two trees are  isomorphic.
% And that problem is NP-hard, and for that, we mostly do brute force.}

% We provide some useful theorems to perform the following tasks.

% \begin{itemize}
%   \item Reorder a disjunction like $φ = φ₁ ∨ φ₂ ∨ \cdots$ to match with another disjunction $ψ = ψ₁ ∨ ψ₂ ∨ \cdots$, when $φ$ is a disjunct of $ψ$.
%   \item Reorder a conjunction of disjuncts (CNF), $φ = φ₁ ∧ φ₂ ∧ \cdots$, to match with another CNF formula equivalent $ψ = ψ₁ ∧ ψ₂ ∧ \cdots$.
% \end{itemize}

% First, we define the $rdisj$ function in Eq.~(\ref{eq:rdisj-def}) to convert a disjunction to be a right-associative disjunction, and following
% a similar approach we define the $rconj$ function for conjunctions.

% \begin{align}
%   \begin{split}
%     \label{eq:rdisj-def}
%     rdisj(φ) =
%     \begin{cases}
%     rdisj(φ₁ ∨ (φ₂ ∨ φ₃)),  & \text{if } φ ≡ (φ₁ ∨ φ₂) ∨ φ₃\\
%     φ₁ ∨ rdisj(φ₂),         & \text{if } φ ≡ φ₁ ∨ φ₂\\
%     φ,                      & \text{otherwise.}
%     \end{cases}
%   \end{split}
% \end{align}

% \begin{lemma}[lem-rdisj]
% \label{lem:lem-rdisj}
%   $Γ ⊢ φ$ then $Γ ⊢ rdisj(φ)$.
% \end{lemma}

% The following function, $build_{∨} : \Prop → \Prop → \Prop$ in Eq.~(\ref{eq:build-or}), intends to construct a disjunction from another disjunction, specifically, we want to rearrange the disjuncts in the source formula to match with the target disjunction for syntactic
% equivalence.

% \begin{equation}
%   \begin{split}
%   \label{eq:build-or}
%   &build_{∨}(φ, ψ) =\\
%   &\hspace{3mm}
%   \begin{cases}
%   ψ, &\text{if } φ ≡ ψ\\
%   ψ, &\text{if } ψ ≡ ψ₁ ∨ ψ₂\text{ and } build_{∨}(φ, ψ_{i}) ≡ ψ_{i}\text{ for some }i=1, 2\\
%   φ, &\text{otherwise.}
%   \end{cases}
%   \end{split}
% \end{equation}

% \begin{lemma}[lem-build$_{∨}$]
% \label{lem:lem-build-or}
% $Γ ⊢ φ$, and $ψ\in \Prop$ then $Γ ⊢ build_{∨}(φ)$.
% \end{lemma}

% The function $factor : \Prop → \Prop$  in Eq.~(\ref{eq:factor-definition}) is intended to work only for right-associative disjunctions, and reduces a disjunction of the same disjunct (e.g., $factor(φ ∨ (φ ∨ \cdots)) \mapsto\ φ$).

% \begin{align}
% \begin{split}
%   \label{eq:factor-definition}
%   factor(φ) =
%   \begin{cases}
%     φ₁,  &\text{if }φ ≡ φ₁ ∨ φ₂ \text{ and } φ₁ ≡ factor(φ₂)\\
%     φ,   &\text{otherwise.}
%   \end{cases}
% \end{split}
% \end{align}

% \begin{lemma}[lem-factor]
% \label{lem:lem-factor}
%   $Γ ⊢ φ$ then $Γ ⊢ factor(φ)$.
% \end{lemma}

% Now, with a right-associative disjunction by applying $rdisj$ function to
% a proposition $φ$, $sbuild_{∨}: \Prop → \Prop → \Prop$ in
% Eq.~(\ref{eq:strong-build-or-definition}) aims to construct the disjunction
% ψ by using each of its disjuncts from the proposition φ. This approach to
% build a disjunction from another is inspired on the description in
% \citeauthor{bohme2010}~\cite{bohme2010} to prove equality between nested
% disjunctions. \change{Make clear this, It's not clear the difference with build-or and sbuild-or.}

% \begin{align}
%   \begin{split}
%   \label{eq:strong-build-or-definition}
%     sbuild_{∨}(φ, ψ) =
%     \begin{cases}
%       factor(build_{∨}(φ₁, ψ) ∨ build_{∨}(φ₂,ψ)),  &\text{if }φ≡ φ₁ ∨ φ₂\\
%       build_{∨}(φ, ψ),  & \text{otherwise.}
%     \end{cases}
%   \end{split}
% \end{align}

% \begin{lemma}[lem-sbuild$_{∨}$]
% \label{lem:lem-sbuild-or}
% $Γ ⊢ φ$, and $ψ \in\Prop$ then $Γ ⊢ sbuild_{∨}(φ, ψ)$.
% \end{lemma}

% Let see the following example of the idea behind $sbuild_{∨}$
% function; from the disjunction $(r ∨ (q ∨ p))$, we build the disjunction
% $((p ∨ q) ∨ r)$.

% \begin{equation*}
%   \begin{bprooftree}
%   \AxiomC{$Γ ⊢ q$}
%   \RightLabel{∨-intro₂}
%   \UnaryInfC{$Γ ⊢ p ∨ q$}
%   \RightLabel{∨-intro₁}
%   \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

%   \AxiomC{$Γ ⊢ p$}
%   \RightLabel{∨-intro₁}
%   \UnaryInfC{$Γ ⊢ p ∨ q$}
%   \RightLabel{∨-intro₁}
%   \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

%   \RightLabel{∨-elim}
%   \BinaryInfC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}
%   \end{bprooftree}
% \end{equation*}

% \begin{equation*}
%   \begin{bprooftree}
%   \AxiomC{$Γ ⊢ r$}
%   \RightLabel{∨-intro₂}
%   \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

%   \AxiomC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}

%   \RightLabel{∨-elim}
%   \BinaryInfC{$Γ, r ∨ (q ∨ p) ⊢ (p ∨ q) ∨ r$}

%   \RightLabel{⇒-intro}
%   \UnaryInfC{$Γ ⊢ r ∨ (q ∨ p) ⇒ (p ∨ q) ∨ r$}

%   \end{bprooftree}
% \end{equation*}

% \begin{theorem}[thm-reorder$_{∨}$]
%   \label{thm-reorder-or}
%   $Γ ⊢ φ$, and $ψ\in\Prop$ then $Γ ⊢ reorder_{∨}(φ, ψ)$, where,
%   \begin{equation*}
%     \label{eq:reorder-or}
%     reorder_{∨} (φ, ψ) = sbuild_{∨}(rdisj(φ), ψ).
%   \end{equation*}
% \end{theorem}

% \begin{proof} Use Lemma~\ref{lem:lem-rdisj} and Lemma~\ref{lem:lem-sbuild-or}.
% \end{proof}

% To work with nest conjunctions of disjunctions (CNFs), we define similar
% functions and theorems as we previously did for disjunctions.

% \begin{lemma}[lem-reorder$_{∧}$]
%   \label{lem:lem-reorder-and}
%   $Γ ⊢ φ$, and $ψ \in\Prop$ then $Γ ⊢ reorder(φ, ψ)$, where,
%   \begin{align*}
%       \begin{split}
%         reorder_{∧}(φ, ψ) =
%         \begin{cases}
%           φ, &\text{if }φ ≡ ψ\\
%           ψ₁ ∧ ψ₂, &\text{if } ψ ≡ ψ₁ ∧ ψ₂\text{, }reorder_{∧}(φ, ψ₁) ≡ ψ₁\\
%                   &\text{and }reorder_{∧}(φ, ψ₂)≡ ψ₂\\
%           φ,       &\text{if } ψ ≡ ψ₁ ∧ ψ₂\\
%           conjunct(φ, ψ) &\text{otherwise.}
%         \end{cases}
%       \end{split}
%   \end{align*}
% \end{lemma}

% \begin{lemma}[lem-conjunct$_{∨}$]
%   \label{lem:lem-conjunct-or}
%   $Γ ⊢ φ$, and $ψ \in\Prop$ then $Γ ⊢ conjunct_{∨}(φ, ψ)$, where,
%   \improvement{The first case is not implemented in Agda}
%   \begin{align*}
%   \begin{split}
%     \label{eq:conjunct-or-definition}
%     conjunct_{∨}(φ, ψ) =
%     \begin{cases}
%       ψ, &\text{if }φ ≡ ψ\\
%       ψ, &\text{if }reorder_{∨}(φ, ψ) ≡ ψ\\
%       ψ, &\text{if }ψ ≡ ψ₁ ∧ ψ₂, conjunct_{∨}(φ, ψ₁) ≡ ψ₁\\
%         &\text{and } reorder_{∨}(φ, ψ₂) ≡ ψ₂\\
%       ψ, &\text{if }φ ≡ φ₁ ∧ φ₂, conjunct_{∨}(φ₁, ψ) ≡ ψ\\
%       ψ, &\text{if }φ ≡ φ₁ ∧ φ₂, conjunct_{∨}(φ₂, ψ) ≡ ψ\\
%       φ, &\text{otherwise.}
%     \end{cases}
%   \end{split}
%   \end{align*}
% \end{lemma}

% \begin{theorem}[thm-reorder$_{∧∨}$]
%   \label{thm:thm-reorder-and-or}

%   $Γ ⊢ φ$, and $ψ \in\Prop$ then $Γ ⊢ reorder_{∧∨}(φ, ψ)$, where,

%   \begin{align}
%       \begin{split}
%       reorder_{∧∨}(φ, ψ)=
%         \begin{cases}
%           ψ, &\text{if } φ≡ψ\\
%           ψ, &\text{if } ψ ≡ ψ₁ ∧ ψ₂, reorder_{∧∨}(φ,ψ₁) ≡ ψ₁\\
%              &\text{and }reorder_{∧∨}(φ, ψ₂) ≡ ψ₂\\
%           φ, &\text{if }ψ ≡ ψ₁ ∧ ψ₂\\
%           conjunct_{∨}(φ, ψ) &\text{otherwise.}
%         \end{cases}
%       \end{split}
%   \end{align}
% \end{theorem}

% % --------------------------------------------------------------------

% \subsubsection{Resolve.}
% \label{sssec:resolve}

% The \resolve rule is a generalization version for resolution in propositional logic since the formulas are not shaped always as the aforementioned theorem expects (see Fig.~\ref{fig:metis-inferences}).

% Since our approach is mere syntactic, in order to apply such a
% theorem, we perform rearrangements inside the formulas to match with
% the pattern expected by the resolution theorem.

% \begin{lemma}[lem-rsol]
%   \label{lem:lem-rsol}
%   $Γ ⊢ φ$ then $Γ ⊢ rsol(φ)$, where,
%   \begin{align*}
%       \begin{split}
%         rsol(φ) =
%         \begin{cases}
%           φ₂, &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (φ₃ ∨ φ₄), φ₃ ≡ ¬ φ₁, φ₂ ≡ φ₄\\
%           φ₂ ∨ φ₄, &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (φ₃ ∨ φ₄), φ₃ ≡ ¬ φ₁\\
%           φ, &\text{otherwise.}
%         \end{cases}
%       \end{split}
%   \end{align*}
% \end{lemma}

% \begin{theorem}[thm-resolve]
%   \label{thm:thm-resolve}
%   $Γ ⊢ φ₁$, $Γ ⊢ φ₂$, a literal $l$, and $ψ\in\Prop$ then $Γ ⊢ resolve(φ₁, φ₂, l, ψ)$, where,
%   \begin{equation*}
%     resolve(φ₁, φ₂, l, ψ) =
%       rsol(reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨} (φ₂, ¬ l ∨ ψ)).
%   \end{equation*}
% \end{theorem}

% \begin{proof}
% \begin{equation*}
%   \begin{bprooftree}
%     \AxiomC{$Γ ⊢ φ₁$}
%     \RightLabel{thm-reorder$_{∨}$}
%     \UnaryInfC{$Γ ⊢ reorder_{∨}(φ₁, l ∨ ψ)$}

%     \AxiomC{$Γ ⊢ φ₂$}
%     \RightLabel{thm-reorder$_{∨}$}
%     \UnaryInfC{$Γ ⊢ reorder_{∨}(φ₂, ¬ l ∨ ψ)$}

%     \RightLabel{∧-intro}
%     \BinaryInfC{$Γ ⊢ reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨}(φ₂, ¬ l ∨ ψ)$}
%     \RightLabel{lem-rsol}
%     \UnaryInfC{$Γ ⊢ rsol(reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨}(φ₂, ¬ l ∨ ψ))$}
%   \end{bprooftree}
%   \end{equation*}
% \end{proof}

% % subsubsection resolve (end)
% % --------------------------------------------------------------------


% % --------------------------------------------------------------------

% \subsubsection{Normal Forms.}
% \label{sssec:normal_forms}
% \change{Here lacks of an introduction!}
% A negative normal form for the formula φ is one in which negations
% appear only in the literals and the expression is in terms only of
% the boolean operators (¬, ∧, ∨).

% To transform a formula φ to its equivalent \abbre{NNF} form, we
% apply recursively the following equations. The function type for
% \name{nnf} is $\Prop \to \Prop$.

% \begin{lemma}[lem-nnf]
%   \label{lem:lem-nnf}
%   $Γ ⊢ φ$ then $Γ ⊢ nnf(φ)$, where,
%   \begin{align*}
%     \begin{split}
%     \label{eq:nnf-definition}
%     nnf(φ) =
%       \begin{cases}
%       nnf(φ₁) ∧ nnf(φ₂),
%          &\text{if }φ ≡ φ₁ ∧ φ₂ \\
%       nnf(φ₁) ∨ nnf(φ₂),
%          &\text{if }φ ≡ φ₁ ∨ φ₂ \\
%       nnf(¬ φ₁ ∨ φ₂),
%          &\text{if }φ ≡ φ₁ ⇒ φ₂ \\
%       nnf(φ₁ ⇒ φ₂ ∧ φ₂ ⇒ φ₁),
%          &\text{if }φ ≡ φ₁ ⇔ φ₂ \\
%       nnf(¬ φ₁ ∨ ¬ φ₂),
%          &\text{if }φ ≡ ¬ (φ₁ ∧ φ₂) \\
%       nnf(¬ φ₁ ∧ ¬ φ₂),
%          &\text{if }φ ≡ ¬ (φ₁ ∨ φ₂) \\
%       nnf(φ₁),
%          &\text{if }φ ≡ ¬ ¬ φ₁ \\
%       nnf(¬ (φ₂ ∨ ¬ φ₁)),
%          &\text{if }φ ≡ ¬ (φ₁ ⇒ φ₂) \\
%       nnf(¬ (φ₁ ⇒ φ₂ ∧ φ₂ ⇒ φ₁)),
%          &\text{if }φ ≡ ¬ (φ₁ ⇔ φ₂) \\
%       ⊥,  &\text{if }φ ≡ ¬ ⊤ \\
%       ⊤,  &\text{if }φ ≡ ¬ ⊥ \\
%       φ,  & \text{otherwise}.
%       \end{cases}
%     \end{split}
%   \end{align*}
% \end{lemma}

% \begin{lemma}[lem-dist$_{∨}$]
%   \label{lem:lem-dist-or}
%   $Γ ⊢ φ$ then $Γ ⊢ dist_{∨}(φ)$, where,
%   \begin{align*}
%       \begin{split}
%       dist_{∨}(φ) =
%         \begin{cases}
%           dist_{∨}(φ₁ ∨ φ₂) ∧ dist_{∨}(φ₂ ∨ φ₃),
%             &\text{if }φ ≡ (φ₁ ∧ φ₂) ∨ φ₃\\
%           dist_{∨}(φ₁ ∨ φ₃) ∧ dist_{∨}(φ₁ ∨ φ₃),
%             &\text{if }φ ≡ φ₁ ∨ (φ₂ ∧ φ₃)\\
%           φ, &\text{otherwise.}
%         \end{cases}
%       \end{split}
%   \end{align*}
% \end{lemma}

% \begin{lemma}[lem-dist]
%   \label{lem:lem-dist}
%   $Γ ⊢ φ$ then $Γ ⊢ dist(φ)$, where,
%   \begin{align*}
%       \begin{split}
%       dist(φ) =
%         \begin{cases}
%           dist(φ₁) ∧ dist(φ₂),
%             &\text{if }φ ≡ φ₁ ∧ φ₂\\
%           dist_{∨}(dist(φ₁) ∨ dist(φ₂)),
%             &\text{if }φ ≡ φ₁ ∨ φ₂\\
%           φ, &\text{otherwise.}
%         \end{cases}
%       \end{split}
%   \end{align*}
% \end{lemma}

% \begin{sketchproof}
% Case when $φ ≡ φ₁ ∨ φ₂$.\\
% For $i = 1, 2$,
% \begin{equation}
%   \begin{bprooftree}
%     \RightLabel{assume}
%     \AxiomC{$Γ, φ_{i} ⊢ φ_{i}$}
%     \RightLabel{lem-dist}
%     \UnaryInfC{$Γ ⊢ dist(φ_{i})$}
%     \RightLabel{∨-intro$_{1,2}$}
%     \UnaryInfC{$Γ, φ_{i} ⊢ dist(φ₁) ∨ dist(φ₂)$}
%     \RightLabel{lem-dist$_{∨}$}
%     \UnaryInfC{$Γ, φ_{i} ⊢ dist_{∨}(dist(φ₁) ∨ dist(φ₂))$.}
%     \end{bprooftree}
% \end{equation}
% Then, by using the ∨-elim rule, from the last derivation above we derive
% $Γ, φ₁ ∨ φ₂ ⊢ dist_{∨}(dist(φ₁) ∨ dist(φ₂))$, and the lemma follows.
% \end{sketchproof}

% \begin{theorem}[thm-cnf]
% \label{thm:thm-cnf}
%   $Γ ⊢ φ$ then $Γ ⊢ cnf(φ)$, where,
%   \begin{equation}
%     cnf(φ) = (dist \circ nnf) (\varphi).
%   \end{equation}
% \end{theorem}

% \begin{proof}
%   Composition of the Lemma \ref{lem:lem-dist} and Lemma \ref{lem:lem-nnf}.
% \end{proof}
% % subsubsection normal_forms (end)
% % --------------------------------------------------------------------

% % --------------------------------------------------------------------

% \subsubsection{Clausification.}
% \label{sssec:clausification}

% \begin{theorem}[thm-clausify]
% \label{thm:thm-clausify}
%   $Γ ⊢ φ$ and $ψ \in\Prop$ then $Γ ⊢ clausify(φ, ψ)$, where,
%   \begin{align}
%       clausify(φ,ψ) =
%       \begin{cases}
%         ψ, &\text{ if }φ≡ψ\\
%         reorder_{∧∨}(cnf(φ), ψ), &\text{otherwise.}
%       \end{cases}
%   \end{align}
% \end{theorem}

% \begin{proof} When $φ ≡ ψ$, we use the $subs$ theorem Eq.~(\ref{eq:substitution-theorem}). Otherwise, we use Theorem \ref{thm:thm-reorder-and-or} and Theorem \ref{thm:thm-cnf}.
% \end{proof}

% % subsubsection clausification (end)
% % --------------------------------------------------------------------

% % --------------------------------------------------------------------
% \subsubsection{Normalization.}
% \label{sssec:normalization}

% In a disjunction, $φ = φ₁ ∨ φ₂ ∨ \cdots ∨ φₙ$, we say $ψ ∈_{∨} φ$,
% if there is some $i = 1, \cdots, n$ such that $ψ = φᵢ$.
% Then, we define the $rm_{∨}$ function to remove in a right-associative disjunction φ, those propositions ψ repeated in the formula.

% \begin{equation*}
% \label{eq:rm-or}
%   rm_{∨}(φ) =
%   \begin{cases}
%     rm_{∨}(φ₂), &\text{if }φ ≡ φ₁ ∨ φ₂, φ₁ ∈_{∨} φ₂\\
%     φ₁ ∨ rm_{∨}(φ₂), &\text{if }φ ≡ φ₁ ∨ φ₂\\
%     φ,  &\text{otherwise.}
%   \end{cases}
% \end{equation*}

% Since, our goal consists of normalizing prepositions in \abbre{CNF}, we also need to generalize $rm_{∨}$ to work with conjunctions. We define $rm_{∧∨}$ function for that purpose.

% \begin{equation*}
% \label{eq:rm-and-or}
%   rm_{∧∨}(φ) =
%   \begin{cases}
%     rm_{∧∨}(φ₁) ∧ rm_{∧∨}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂\\
%     rm_{∨}(rdisj(φ)),  &\text{otherwise.}
%   \end{cases}
% \end{equation*}

% Now, we have removed redundancies in the disjunctions, we move forward and we remove redundancies at the level of the conjunction of the CNFs by applying the $rm_{∧}$ function. We define $ψ ∈_{∧} φ$ similar as we described above for disjunction. In a conjunction, $φ = φ₁ ∧ φ₂ ∧ \cdots ∧ φₙ$, we say
% $ψ ∈_{∧} φ$, if there is some $i = 1, \cdots, n$ such that $ψ = φᵢ$.

% \begin{equation*}
% \label{eq:rm-and}
%   rm_{∧}(φ) =
%   \begin{cases}
%     rm_{∧}(φ₁) ∧ rm_{∧}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂, φ₁ ∈_{∧} φ₂\\
%     φ₁ ∧ rm_{∧}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂\\
%     φ,  &\text{otherwise.}
%   \end{cases}
% \end{equation*}

% Finally, we remove redundancies in a proposition assuming that it is given in conjunctive normal form and right-associative, by composing the functions described above in the Eq.~(\ref{eq:redun-ast})
% for the function $redun^{*}$.

% \begin{equation*}
%   \label{eq:redun-ast}
%   redun^{*} = rm_{∧} ∘ rm_{∧∨}.
% \end{equation*}

% Then, performing rearrangements to match with the expected output
% by $redon^{*}$ function.

% \begin{equation*}
%   \label{eq:redun}
%   redun(φ) = reorder_{∧∨}(φ, redun^{*}(φ)).
% \end{equation*}

% \begin{theorem}[thm-redun]
%   \label{thm:thm_redun}
%   $Γ ⊢ φ$ then $Γ ⊢ redun(φ)$.
% \end{theorem}

% \begin{proof}
% Use in Theorem~\ref{thm:thm-reorder-and-or} with $ψ$ equals to
% $redun^{*}(φ)$.
% \end{proof}

% \improvement{We need here a text, or a comment about what
% is going next.}

% % subsection normalization (end)
% % --------------------------------------------------------------------
% \begin{lemma}[lem-rmPEM$_{∨}$]
%   \label{lem:lem-rmPEM-or}
%   \begin{align*}
%   \label{eq:rmPEM-or}
%     \begin{split}
%     rmPEM_{∨}(φ) =
%       \begin{cases}
%         ⊤, &\text{if }φ ≡ ¬ φ₁ ∨ φ₂,\ φ₁ ∈_{∨} φ₂\\
%         ⊤, &\text{if}φ ≡ ¬ φ₁ ∨ φ₂,\ rmPEM_{∨}(φ₂) ≡ ⊤\\
%         ¬ φ₁ ∨ rmPEM_{∨}(φ₂), &\text{if }φ ≡ ¬ φ₁ ∨ φ₂\\
%         ⊤, &\text{if }φ ≡ φ₁ ∨ φ₂,\ ¬φ₁ ∈_{∨} φ₂ \\
%         ⊤, &\text{if }φ ≡ φ₁ ∨ φ₂,\ rmPEM_{∨}(φ₂) ≡ ⊤\\
%         φ₁ ∨ rmPEM_{∨}(φ₂), &\text{if }φ ≡ φ₁ ∨ φ₂\\
%         φ, &\text{otherwise.}
%       \end{cases}
%     \end{split}
%   \end{align*}
% \end{lemma}

% \begin{lemma}[lem-rmPEM$_{∧∨}$]
%   \label{lem:lem-rmPEM-and-or}
%   \begin{equation*}
%     \label{eq:rmPEM-and-or}
%     rmPEM_{∧∨}(φ) =
%     \begin{cases}
%       rmPEM_{∨}(φ₁) ∧ rmPEM_{∨∧}(φ₂), &\text{ if }φ ≡ φ₁ ∧ φ₂\\
%       rmPEM_{∨}(φ), &\text{otherwise.}
%     \end{cases}
%   \end{equation*}
% \end{lemma}

% \begin{lemma}[lem-rmBot$_{∧}$]
%   \label{lem:lem-rmbot-and}
%    $Γ ⊢ φ$ then $Γ ⊢ rmBot_{∧}(φ)$, where,
%   \begin{equation*}
%     \label{eq:rmBot-and}
%     rmBot_{∧}(φ) =
%     \begin{cases}
%       ⊥, &\text{ if }φ ≡ ¬ φ₁ ∧ φ₂,\ φ₁ ∈_{∧} φ₂\\
%       ⊥, &\text{ if }φ ≡ ¬ φ₁ ∧ φ₂,\ rmBot_{∧}(φ₂) ≡ ⊥\\
%       ¬ φ₁ ∧ rmBot_{∧}(φ₂), &\text{if }φ ≡ ¬ φ₁ ∧ φ₂\\
%       ⊥, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ φ₁ ∈_{∧} φ₂\\
%       ⊥, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ rmBot_{∧}(φ₂) ≡ ⊥\\
%       φ₁ ∧ rmBot_{∧}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂\\
%       φ, &\text{otherwise.}
%     \end{cases}
%   \end{equation*}
% \end{lemma}

% \begin{lemma}[lem-canon]
%   \label{lem:lem-canon}
%   \begin{align*}
%   \begin{split}
%   &canon(φ) =\\
%   &\hspace{3mm}
%   \begin{cases}
%       canon(φⱼ), &\text{if } φ ≡ φ₁ ∧ φ₂,\ canon(φᵢ) ≡ ⊤,\\
%                  &\text{for same } i,j = 1,2, i≠j\\
%      ⊥, &\text{if } φ ≡ φ₁ ∧ φ₂,\ canon(φᵢ) ≡ ⊥, i = 1,2\\
%      canon(φ₁) ∧ canon(φ₂), &\text{if } φ ≡ φ₁ ∧ φ₂\\
%      ⊤, &\text{if } φ ≡ φ₁ ∨ φ₂,\ canon(φᵢ) ≡ ⊤, i = 1,2\\
%      canon(φⱼ), &\text{if } φ ≡ φ₁ ∨ φ₂,\ canon(φᵢ) ≡ ⊥,\\
%                 &\text{for same } i,j = 1,2, i≠j\\
%      canon(φ₁) ∨ canon(φ₂), &\text{if } φ ≡ φ₁ ∨ φ₂\\
%      φ, &\text{otherwise.}
%     \end{cases}
%   \end{split}
%   \end{align*}
% \end{lemma}

% \begin{theorem}[thm-canonicalize] % (fold)
%   \label{thm:thm-canonicalize}
%   $Γ ⊢ φ$ then $Γ ⊢ canonicalize(φ)$, where,
%   \begin{equation*}
%     canonicalize =
%      canon ∘ rmBot_{∧} ∘ rmPEM_{∧∨} ∘ redun ∘ rconj ∘ cnf.
%   \end{equation*}
% \end{theorem}

% The \canonicalize rule acts in \Metis' \TSTP derivations in three main cases. First, introducing the
% negation of a subgoal. Second, to simplify an intermediate derivation.
% Third, introducing an axiom or a definition of the.
% To justify the two first cases, we use the Theorem~\ref{thm:thm-canonicalize}. For the last case, we use the Lemma~\ref{lem:lem-nnf}.

% % -------------------------------------------------------------------
% \subsubsection{Simplify}
% \label{sssec:simplify}

% The \simplify rule is the application of the the lemma showed above,
% but also the following lemmas that intend to reduce a list of derivations,
% a conjunction of their formulas into a one smaller.

% \improvement{Missing theorems here.}


% % subsubsection simplify (end)
% % -------------------------------------------------------------------

\end{document}
