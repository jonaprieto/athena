
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Proof-Reconstruction}
\label{sec:proof-reconstruction}

\subsection{Workflow}
\label{ssec:workflow}

\input{sections/diagram.tex}

The proof-reconstruction approach proposed here consists of a series
of steps similar to the workflow presented by \citeauthor{sultana2015} in
\cite{sultana2015}. This process is a translation from a source
system to a target system. In our case, the system of origin, the
automatic theorem prover, is \Metis; the target system is a proof
assistant, \Agda. We choose \Agda, but another proof assistant with the same
support of type theory and inductive types is valid.
%  (see a description of \Agda for its main features in
% Section~\ref{sec:implementation}).
The overview of the proof-reconstruction is presented in
Fig.~\ref{fig:proof-reconstruction-workflow}, the process begin with
a \TPTP file that encodes a problem in \CPL. We use this file as the
input of the \Metis prover and if the problem is a theorem, \Metis can reply
with a derivation in \TSTP format of the proof.

With the \TSTP  derivation from Step~2, we process the derivation with the
\Athena translator tool~\cite{Athena}.
\Athena parses the \TSTP format, analyzes the
derivation and generates a representation of the natural deduction
proof using a tree data structure (see the properties
of this tree in Section~\ref{sssec:metis-proofs}).
We perform an analysis of the proof-tree to remove some
unnecessary steps that introduce redundancies or unused input for
\Athena.

As a result of using \Athena, we get an \Agda file, the proof-term. To
generate this file, \Athena uses names of functions and theorems from
\Agda libraries:
\texttt{agda-prop}~\cite{AgdaProp}, and \texttt{agda-metis}~\cite{AgdaMetis}.


Finally, we type-check the \Agda proof-term. If the type-checking
success, the \TSTP derivation delivered by \Metis is correct.
In that case \Agda outputs an interface file.
Otherwise, when type-checking fails, the failure must be
investigated by the user, checking for the error in \Metis, \Athena,
or in \Agda.

In the remainder part of this section, a formal description using
type theory is presented to build definitions and theorems of functions
necessary to emulate \Metis' inference rules. As a convention,
We write the type judgments as ``$a : A$'' to denote that $a$
has $\abbre{A}$ type. Types are written using small caps.
We use \Prop type for propositions and the dependent type, $Γ ⊢ φ$ for
theorems where $Γ$ has $\abbre{List}~\Prop$ type, and $φ$ has type $\Prop$.
$\abbre{List}$ type is the usual inductive type for lists. For syntactical
equivalence, we write $φ ≡ ψ$ for $φ : \Prop$ and $ψ : \Prop$.

% ...................................................................

% section section_name (end)
\subsection{Structural Recursion}
\label{ssec:structural-recursion}

To emulate \Metis' inference rules in type theory,
we observed that transformations performed by some rules are given
by \emph{general recursive} functions.
Algorithms based on general recursions can not be translated
directly in type theory since it is not a guarantee they terminate.
For that reason, we follow the technique described
in~\cite{Bertot2004} to avoid termination problems by modifying the
recursive
functions to be \emph{structural recursive}.
% (see \cite{Coquand1992,Abel2002,Bove2005} for more details).

This paper adopts the notion of \emph{structurally smaller} from
\citeauthor{Abel2002}~\cite{Abel2002} to say, a recursive function is
structurally recursive if it calls itself with only
\emph{structurally smaller}
arguments.

General recursive calls can be translated into structurally recursive
calls by using for instance, the \emph{Bounded Recursion} technique
presented in~\cite{Bertot2004}. For a yet another method, we refer
the reader to \cite{Coquand1992,Abel2002,Bove2005}.
The former technique defines a new function based on the original
recursive function by adding an argument to the function.
The new argument is the \emph{bound}, a natural number given by the
function complexity. In other words, the added argument will store
the number of times the function needs to call itself to get the
expected outcome.

Henceforth, a natural number has \Nat type, and it is defined as
usual, i.e., \zero and \suc are the data constructors and some
arithmetic operations are defined: ($+,\ -,\ *$). We include syntax
sugar for $\zero$, $\suc$, $\suc(\zero)$, $\cdots$, with the
classical representation: $1$, $2$, $\cdots$ as well.

Therefore, for a general recursive function $f: \Prop \to \Prop$
with termination problems, we state a new function
$f^{*} : \Prop \to \Nat \to \Prop$ where all recursive calls must be
done by using induction on the \Nat type structure.

\subsubsection*{A Practical Example.}
Let us consider the following example to exhibit the technique
mentioned above for an inner function present in the emulated version
of the \strip inference.

\begin{align}
  \label{eq:unshunt-definition}
  \begin{split}
    &unshunt_{0} : \Prop → \Prop\\
    &unshunt_{0}(φ) =\\
    &\hspace{3mm}\begin{cases}
    unshunt_{0}((φ₁ ∧ φ₂) ⇒ φ₃),
      & \text{ if }φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\
    unshunt_{0}(φ₁ ⇒ φ₂) ∧ unshunt_{0}(φ₁ ⇒ φ₃),
      & \text{ if }φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃)\\
    φ, &\text{ otherwise.}
    \end{cases}
  \end{split}
\end{align}

From the definition above, the size of the argument, $((φ₁ ∧ φ₂) ⇒ φ₃)$,
is not structurally smaller than the input formula, $(φ₁ ⇒ (φ₂ ⇒ φ₃))$,
since $((φ₁ ∧ φ₂) ⇒ φ₃)$ is not a subformula of $(φ₁ ⇒ (φ₂ ⇒ φ₃))$.

Thus, we define the function
$unshunt_{1}$ by structural recursion in its second argument in
Eq.~(\ref{eq:unshunt-structured}).

\begin{align}
  \label{eq:unshunt-structured}
  \begin{split}
    &unshunt_{1} : \Prop → \Nat \to \Prop\\
    &unshunt_{1}(φ, \zero)\hspace{3mm}= φ\\%\hspace{10cm}\\
    &unshunt_{1}(φ, \suc(n)) =\\
    &\hspace{3mm}\begin{cases}
    unshunt_{1}((φ₁ ∧ φ₂) ⇒ φ₃, n),
      &\text{ if } φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\[2mm]
    unshunt_{1}(φ₁ ⇒ φ₂, n)\\
    ∧\ unshunt_{1}(φ₁ ⇒ φ₃, n),
       &\text{ if } φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃).
  \end{cases}
  \end{split}
\end{align}

As we mentioned above, the natural number in the second argument of
the function used in Eq.~(\ref{eq:unshunt-structured}) stands for a
complexity measure of the function, in this case $unshunt_{1}$ function.

Recall the \emph{complexity measure} defined in \cite{Agudelo-Agudelo2017}
and presented in \cite{VanDalen1994} as \emph{the rank for a
proposition}, is a function $\Prop \to \Nat$ that assigns a natural
number for a proposition $φ$ like the following $rank$ function.
The symbols $c_{¬}$ and $c_{\square}$ are non-negative integer
numbers called the complexity of the respective connective.

\begin{align*}
  \begin{split}
  % \label{eq:rank-definition}
    &rank : \Prop → \Nat\\
    &rank(φ) =
    \begin{cases}
    0, &\text{for atomic }φ \\
    rank(φ₁) + c_{¬},  &\text{ if } φ ≡ \neg φ₁ \\
    \max{(rank(φ₁),\ rank(φ₂))} + c_{\square},
      &\text{ if } φ ≡ φ₁\,\square\, φ₂.
    \end{cases}
  \end{split}
\end{align*}

We define the $unshunt_{cm}: \Prop → \NN$ function as
the complexity measure for the $unshunt_0$ function.

\begin{align*}
  \label{eq:unshunt-rank-definition}
  \begin{split}
      &unshunt_{cm} : \Prop → \Nat\\
      &unshunt_{cm}(φ) =\\
      &\hspace{3mm}
        \begin{cases}
        unshunt_{cm}(φ₃) + 2, &\text{ if }φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\
        \max(unshunt_{cm}(φ₂),\ unshunt_{cm}(φ₃)) + 1,
          &\text{ if }  φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃)\\
        0, &\text{ otherwise.}
        \end{cases}
  \end{split}
\end{align*}

Finally, following the technique mentioned, we get a curated version of
$unshunt_{0}$ function presented in Def.~\ref{def:unshunt}.

\begin{definition}[unshunt]
  \label{def:unshunt}
    \begin{align*}
      \begin{split}
      &unshunt : \Prop → \Prop\\
      &unshunt(\varphi) = unshunt_{1}(\varphi, unshunt_{cm}(\varphi)).
      \end{split}
    \end{align*}
\end{definition}

For a more complete treatment of general recursion, and how to
define well-founded and well-structural recursive functions, we refer
the reader to Ref.~\cite{Bove2005}, where Bove and Capettra described
not only general recursion, but they also treat mutual recursive
function, among others.

% % ................................................

\subsection{Emulating \Metis' Inference Rules}
\label{ssec:emulating-inferences}

In this section, we emulate each \Metis inference rule by proving a
function with the same name, and a associated theorem.
The following pattern is used to present the formalization.
The function name written in bold print
is a \Metis inference rule in \TSTP derivations.
The same function name written in italics refers to its emulated
version.
Each emulated rule states a respective theorem that proves its soundness.
This theorem is named by using the prefix \emph{thm}
and the name of the rule.

\begin{itemize}
\item \texttt{rule} is a $n$-ary \Metis inference rule
\item $rule$ is the emulated version function  for
the \texttt{rule} inference.
\begin{align*}
  \begin{split}
    &rule : \Prop → \Prop → \cdots → \Prop\\
    &rule(φ₁,\ \cdots, φₙ, ψ) =
      \begin{cases}
      ψ, &\text{ if }rule\text{ built }ψ\text{ by applying valid}\\
         &\text{ transformations or other rules to }φ\\
      φ, &\text{ otherwise.}
      \end{cases}
  \end{split}
\end{align*}

\begin{itemize}
  \item $φᵢ$ are \emph{source} formulas from previous deducted derivations.
  \item $ψ$ is the \emph{target} formula. The excepted result of \texttt{rule}.
\end{itemize}
\end{itemize}

\subsubsection{Stripping a Goal.}
\label{sssec:strip-a-goal}

To prove a goal, \Metis splits the goal into
disjoint cases. This process produces a list of new subgoals, the
conjunction of these subgoals implies the goal. Then, a proof of the
goal becomes, in smaller proofs, one refutation for each subgoal.
These subgoals are introduced in the \TSTP derivation with the \strip
inference rule as we show with the following excerpt.

\begin{verbatim}
fof(goal, conjecture, p & r & q).
fof(subgoal_0, plain, p,
    inference(strip, [], [goal])).
fof(subgoal_1, plain, p => r,
    inference(strip, [], [goal])).
fof(subgoal_2, plain, (p & r) => q,
    inference(strip, [], [goal])).
\end{verbatim}

To prove the correctness of the process mentioned above,
we need to establish some lemmas before introduce our main goal of this part,
Theorem~\ref{thm:thm-strip}.

\begin{lemma}[lem-unshunt]
  \label{lem:unshunt}
  $Γ ⊢ unshunt(φ)$, then $Γ ⊢ φ$.
\end{lemma}

\begin{sketchproof} Use induction on the cases defined by the outcome of the
$unshunt$ function in Eq.~(\ref{eq:unshunt-structured}).
\begin{itemize}
	\item If $n = 0$, by definition we conclude $Γ ⊢ φ$.
	\item If $n = 1$, we apply the following theorem proved in~\cite{AgdaProp},
		\begin{equation*}
		\texttt{∧⇒-to-⇒⇒}\ :\  Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃ → Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃).
		\end{equation*}
  \item For $n > 1$, we use induction on the structure of the second
			  argument.
\begin{itemize}
\item $(φ₁ ⇒ (φ₂ ⇒ φ₃))$
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n-1)$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃}
  \RightLabel{∧⇒-to-⇒⇒.}
  \UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃)}
  \end{bprooftree}
\end{equation*}

\item $(φ₁ ⇒ (φ₂ ∧ φ₃))$
\begin{equation*}
  \scalebox{0.95}{
  ($\mathcal{D}_1$)
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n) ∧ unshunt(φ₁ ⇒ φ₃, n)$}
    \RightLabel{∧-proj₁}
    \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n)$}
    \RightLabel{axiom}
    \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n-1)$}
    \RightLabel{lem-unshunt,}
    \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
  \end{bprooftree}
  }
\end{equation*}

\begin{equation*}
  (\mathcal{D}_2)
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂) ∧ unshunt(φ₁ ⇒ φ₃)$}
    \RightLabel{∧-proj₂}
    \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₃, n)$}
    \RightLabel{axiom}
    \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₃, n-1)$}
    \RightLabel{lem-unshunt.}
    \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₃$}
    \end{bprooftree}
\end{equation*}

Finally, using the theorem \texttt{⇒∧⇒-to-⇒∧} from~\cite{AgdaProp},
\begin{equation*}
  \texttt{⇒∧⇒-to-⇒∧}\ :\ Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃) → Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃),
\end{equation*}
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}_1$}
  \AxiomC{$\mathcal{D}_2$}
  \RightLabel{∧-intro}
  \BinaryInfC{$Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃)$}
  \RightLabel{\tt ⇒∧⇒-to-⇒∧.}
  \UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃)}
  \end{bprooftree}
\end{equation*}
\item Other cases are proved in a similar way.
\end{itemize}
\end{itemize}
\end{sketchproof}

We now define the $split$ function that yields the conjunction of subgoals
that implies the goal of the problem in the \Metis \TSTP derivations.

\begin{definition}[split]
\label{def:split}
  \begin{equation*}
    \begin{split}
    &split : \Prop → \Prop\\
    &\mysplit(φ) =
      \begin{cases}
      unshunt(\mysplit(φ₁)) &\text{ if }φ ≡ φ₁ ∧ φ₂\\
      ∧\ unshunt(φ₁ ⇒ \mysplit(φ₂)), &\\[2.5mm]
      unshunt(¬ φ₁ ⇒ \mysplit(φ₂)),
        & \text{ if }φ ≡ φ₁ ∨ φ₂\\[2.5mm]
      unshunt(φ₁ ⇒ \mysplit(φ₂)),
        & \text{ if }φ ≡ φ₁ ⇒ φ₂\\[2.5mm]
      unshunt(φ₁ ⇒ \mysplit(φ₂))
        & \text{ if }φ ≡ φ₁ ⇔ φ₂\\
      ∧\ unshunt(φ₂ ⇒ \mysplit(φ₁)),
        &\\[2.5mm]
      unshunt(φ₁ ⇒ \mysplit(¬ φ₂)),
        & \text{ if }φ ≡ ¬ (φ₁ ∧ φ₂)\\[2.5mm]
      unshunt(\mysplit(¬ φ₁))
        & \text{ if }φ ≡ ¬ (φ₁ ∨ φ₂)\\
      ∧\ unshunt(¬ φ₁ ⇒ \mysplit(¬ φ₂)),
        &\\[2.5mm]
      unshunt(\mysplit(φ₁))
        & \text{ if }φ ≡ ¬ (φ₁ ⇒ φ₂)\\
      ∧\ unshunt(φ₁ ⇒ \mysplit(¬ φ₂)),
        &\\[2.5mm]
      unshunt(φ₁ ⇒ \mysplit(¬ φ₂))
        & \text{ if }φ ≡ ¬ (φ₁ ⇔ φ₂)\\
      ∧\ unshunt(¬ φ₂ ⇒ \mysplit(φ₁)),
        &\\[2.5mm]
      unshunt(\mysplit(φ₁)),
        & \text{ if }φ ≡ ¬ ¬ φ₁\\
      ⊤,
        & \text{ if }φ ≡ ¬ ⊥\\
      ⊥,
        & \text{ if }φ ≡ ¬ ⊤.
      \end{cases}
    \end{split}
  \end{equation*}
\end{definition}

The definition above has termination problems since it is not
a structural recursion. Therefore, we have reformulated the equation
above to solve such an issue following the technique
described in Section~\ref{ssec:structural-recursion}. We refer to $split$
as the function after applying the process mentioned above here and below
unless otherwise stated.

\begin{lemma}[\thmsplit] $Γ ⊢ \mysplit(φ)$ then $Γ ⊢ φ$.
\label{lem:lem-split}
\end{lemma}

\begin{sketchproof}
The proof is by induction on the structure of the
formula $φ$ by following the cases in Def.~\ref{def:split}.
We present some cases but for a complete proof, we refer the reader to~\cite{AgdaMetis}.
\begin{itemize}
\item $(φ ≡ ¬ ¬ φ₁)$
\begin{equation*}
  \begin{bprooftree}
 \AxiomC{$Γ ⊢ \mysplit(φ,n)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(split(¬¬φ₁,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢split(¬¬φ₁,n-1)$}
  \RightLabel{\thmsplit}
  \UnaryInfC{$Γ ⊢ ¬¬φ₁$}
  \RightLabel{axiom.}
  \UnaryInfC{$Γ ⊢ φ$}
  \end{bprooftree}
\end{equation*}

\item $(φ ≡ φ₁ ∧ φ₂)$. We get a proof for each conjunct and using the introduction rule for conjunction connective, the result follows.

\begin{equation*}
(\mathcal{D})\hspace{3mm}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ \mysplit(φ,n)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁) ∧ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{∧-proj₁}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁)$}
  \RightLabel{lem-unshunt.}
  \UnaryInfC{$Γ ⊢ φ₁$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}$}
  \UnaryInfC{Γ ⊢ φ₁}
  \AxiomC{$Γ ⊢ \mysplit(φ,n)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁) ∧ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{$∧$-proj$₂$}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{$⇒$-elim}
  \BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
  \RightLabel{\thmsplit.}
  \UnaryInfC{$Γ ⊢ φ₂$}
  \end{bprooftree}
\end{equation*}

\item $(φ ≡ φ₁ ⇒ φ₂)$
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{}
  \RightLabel{assume φ₁}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁$}
  \AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{weaken φ₁}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{⇒-elim}
  \BinaryInfC{$Γ , φ₁ ⊢ \mysplit(φ₂,n-1)$}
  \RightLabel{\thmsplit}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₂$}
  \RightLabel{⇒-intro.}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
  \end{bprooftree}
\end{equation*}

\item $(φ ≡ ¬ (φ₁ ∨ φ₂))$. We show that $Γ ⊢ ¬ φ₁$ and $Γ ⊢ ¬ φ₂$.
The result follows by introducing the conjunction and applying
De Morgan Laws.

\begin{equation*}
(\mathcal{D})\hspace{3mm}
\begin{bprooftree}
\AxiomC{$Γ ⊢ \mysplit(φ, n)$}
\RightLabel{axiom}
\UnaryInfC{$Γ ⊢ unshunt(¬ φ₁) ∧ unshunt(¬ φ₁ ⇒ \mysplit(φ₂, n))$}
\RightLabel{∧-proj₁}
\UnaryInfC{$Γ ⊢ unshunt(¬ φ₁)$}
\RightLabel{lem-unshunt,}
\UnaryInfC{$Γ ⊢ ¬ φ₁$}
\end{bprooftree}
\end{equation*}
\end{itemize}
\end{sketchproof}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}$}
  \UnaryInfC{$Γ ⊢ ¬ φ₁$}

  \AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(¬ φ₁) ∧ unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{∧-proj₂}
  \UnaryInfC{$Γ ⊢ unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢ ¬ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{⇒-elim}
  \BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
  \RightLabel{\thmsplit.}
  \UnaryInfC{$Γ ⊢ ¬ φ₂$}
  \end{bprooftree}
\end{equation*}

\begin{lemma}[subst]
  \label{lem:subst}
  Substitution theorem.
\begin{equation*}
  \label{eq:substitution-theorem}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ φ$}   \AxiomC{$ψ ≡ φ$}
  \RightLabel{subst.}
  \BinaryInfC{$Γ ⊢ ψ$}
  \end{bprooftree}
\end{equation*}
\end{lemma}

We can now formulate our main result of this part that
justifies the stripping strategy of \Metis to prove goals.

\begin{theorem}[thm-strip]
\label{thm:thm-strip}
 If $s_i$ are the subgoals of the goal $φ$ for $i=1,\cdots,n$ and
 $\{ Γ ⊢ s_i \}_{i =1}^n$, then $Γ ⊢ φ$.
\end{theorem}

\begin{proof}
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\left\{ Γ ⊢ s_i \right\}_{i=1}^n$}
  \RightLabel{∧-intro}
  \UnaryInfC{$Γ ⊢ \bigwedge_{i=1}^n s_i$}

  \AxiomC{$\mysplit(φ) ≡ \bigwedge_{i=1}^n s_i $}
  \RightLabel{subst}
  \BinaryInfC{$Γ ⊢ \mysplit(φ)$}
  \RightLabel{\thmsplit.}
  \UnaryInfC{$Γ ⊢ φ$}
\end{bprooftree}
\end{equation*}
\end{proof}

% -------------------------------------------------------------------

\subsubsection{Negating Subgoals.}

Each proof of a subgoal is a refutation, thereby each proof assumes
the negation of its subgoal. The \negate rule
assumes the negation of such subgoals, and
appears after applying the \strip inference to the goal.

\begin{verbatim}
fof(goal, conjecture, (p & q)).
fof(subgoal_0, plain, (p), inference(strip, [], [goal])).
fof(subgoal_1, plain, (p => q), inference(strip, [], [goal])).
fof(negate_0_0, plain, (~ p), inference(negate, [], [subgoal_0])).
\end{verbatim}

To emulate this rule, we introduce the negation
of the subgoal by using $assume$ rule from the inferences in
Fig.~\ref{fig:CPL-inference-rules}.

% -------------------------------------------------------------------

\subsubsection{Splitting a Conjunct.}
\label{sssec:splitting-a-conjunct}

The \conjunct rule extracts from a
conjunction one of its conjuncts. This rule is a generalization of the
projection rules for the conjunction connective as the
following \TSTP excerpt shows.

\begin{verbatim}
fof(normalize_1, plain, p & q & (r | ~ p),
  inference(canonicalize, [], [x])).
fof(normalize_2, plain, q,
  inference(conjunct, [], [normalize_1])).
fof(normalize_2, plain, (r | ~ p),
  inference(conjunct, [], [normalize_1])).
\end{verbatim}

\begin{definition}[conjunct]
\begin{align*}
  \begin{split}
  &conjunct : \Prop \to \Prop \to \Prop\\
  &conjunct(φ, ψ) =
    \begin{cases}
        ψ, &\text{ if }φ ≡ ψ\\
        ψ, &\text{ if }φ ≡ φ₁ ∧ φ₂\text{ , }ψ ≡ conjunct(φ₁, ψ)\\
        ψ, &\text{ if }φ ≡ φ₁ ∧ φ₂\text{ , }ψ ≡ conjunct(φ₂, ψ)\\
        φ, &\text{ otherwise.}
      \end{cases}
  \end{split}
\end{align*}
\end{definition}

\begin{theorem}[thm-conjunct]
  \label{thm:thm-conjunct}
  $Γ ⊢ φ$, and $ψ  : \Prop$ , then $Γ ⊢ conjunct(φ, ψ)$.
\end{theorem}
\begin{proof}\hspace{2cm}
\begin{itemize}
  \item For the case $φ ≡ ψ$, $Γ ⊢ conjunct(φ, ψ)$ normalizes to $Γ ⊢ ψ$.
Then, we get the desire conclusion by applying the $subst$ theorem.
  \item If the proposition $φ$ is a conjunction, and we can get $ψ ≡ conjunct(φ_{i}, ψ)$ for some $i = 1,\ 2$, then,

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ φ₁ ∧ φ₂$}
  \RightLabel{∧-proj$_{i}$}
  \UnaryInfC{$Γ ⊢ φ_{i}$}
  \UnaryInfC{$Γ ⊢ conjunct(φ_{i}, ψ)$}
  \AxiomC{$ψ ≡ conjunct(φ_{i}, ψ)$}
  \RightLabel{subst.}
  \BinaryInfC{$Γ ⊢ ψ$}
  \end{bprooftree}
\end{equation*}
\item The last case follows trivially by using the same hypothesis.
\end{itemize}
\end{proof}

% subsubsection splitting-a-conjunct (end)
% -------------------------------------------------------------------

% ------------------------------------------------------------------------

\subsubsection{Reordering.}
\label{sssec:reordering}

Logic equivalence between propositions is a major issue to justify
prover reasoning steps. Since we left out semantics to treat only the
syntax aspects of the propositions, our approach shows equivalence
by converting propositions to their conjunctive normal forms,
and reordering those and the inner disjunctions  to match them
In this section, we provide some theorems to perform such reordering tasks,
the goals are the following.

\begin{itemize}
  \item Reorder a disjunction $φ = φ₁ ∨ φ₂ ∨ \cdots ∨ φₙ$ to match with
$ψ = ψ₁ ∨ ψ₂ ∨ \cdots ∨ ψₙ$. For all $i$, there exists at least one $j$ such
that $φᵢ ≡ ψⱼ$.
  \item Reorder a CNF formula, $φ = φ₁ ∧ φ₂ ∧ \cdots$, to match with another
CNF formula $ψ = ψ₁ ∧ ψ₂ ∧ \cdots$. For all $i$, there exists at least one $j$
such that $φᵢ ≡ ψⱼ$.
\end{itemize}

First, we define the $rdisj$ function to convert
a disjunction in its right-associative form.
The $rconj$ function that converts conjunction to its right-associative form
is not presented here, but is defined in a similar way (see its implementation
in~\cite{AgdaMetis}).

\begin{definition}[rdisj]
\label{def:rdisj}
  \begin{align*}
    \begin{split}
    \label{eq:rdisj-def}
      &rdisj(φ) : \Prop \to \Prop\\
      &rdisj(φ) =
      \begin{cases}
      rdisj(φ₁ ∨ (φ₂ ∨ φ₃)),  & \text{ if } φ ≡ (φ₁ ∨ φ₂) ∨ φ₃\\
      φ₁ ∨ rdisj(φ₂),         & \text{ if } φ ≡ φ₁ ∨ φ₂\\
      φ,                      & \text{ otherwise.}
      \end{cases}
    \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-rdisj]
\label{lem:lem-rdisj}
  $Γ ⊢ φ$ then $Γ ⊢ rdisj(φ)$.
\end{lemma}

The $build_{∨}$ function in Eq.~(\ref{eq:build-or}) intends to construct a
disjunction from another disjunction, specifically, this functions will try
to rearrange the disjuncts in the source formula to match with the target
disjunction formula, similar as we describe above.

\begin{definition}[build$_{∨}$]
\begin{equation}
  \begin{split}
  \label{eq:build-or}
  &build_{∨} : \Prop → \Prop → \Prop\\
  &build_{∨}(φ, ψ) =\\
  &\hspace{3mm}
  \begin{cases}
  ψ, &\text{ if } φ ≡ ψ\\
  ψ, &\text{ if } ψ ≡ ψ₁ ∨ ψ₂\text{, } build_{∨}(φ, ψ_{i}) ≡ ψ_{i}\text{ for some }i=1, 2\\
  φ, &\text{ otherwise.}
  \end{cases}
  \end{split}
\end{equation}
\end{definition}

\begin{lemma}[lem-build$_{∨}$]
\label{lem:lem-build-or}
$Γ ⊢ φ$, and $ψ : \Prop$ then $Γ ⊢ build_{∨}(φ)$.
\end{lemma}

From now, we assume all propositions to be right-associative unless otherwise stated.
The $factor$ function in Eq.~(\ref{eq:factor-definition}) intends to simplify a
special case of disjunction, the repeated disjuncts (e.g., $factor(φ ∨ φ) \mapsto\ φ$).
Notice that other cases like $φ ∨ (ψ ∨ φ)$ do no reduce to $(ψ ∨ φ)$.

\begin{definition}[factor]
\begin{align}
\begin{split}
  \label{eq:factor-definition}
  &factor : \Prop → \Prop\\
  &factor(φ) =
  \begin{cases}
    φ₁,  &\text{ if }φ ≡ φ₁ ∨ φ₂ \text{, } φ₁ ≡ factor(φ₂)\\
    φ,   &\text{ otherwise.}
  \end{cases}
\end{split}
\end{align}
\end{definition}

\begin{lemma}[lem-factor]
\label{lem:lem-factor}
  $Γ ⊢ φ$ then $Γ ⊢ factor(φ)$.
\end{lemma}

To construct a disjunction $ψ$ from a disjunction $φ$, we have used ideas
from the description in \citeauthor{bohme2010}~\cite{bohme2010} to prove equality
between nested disjunctions. The result is the $sbuild_{∨}$ function that uses
every disjunct from the source formula, $φ$, to build up the target disjunction $ψ$.

\begin{definition}[sbuild$_{∨}$]
\begin{align*}
  \begin{split}
  \label{eq:strong-build-or-definition}
    &sbuild_{∨} : \Prop → \Prop → \Prop\\
    &sbuild_{∨}(φ, ψ) =\\
    &\hspace{3mm}
    \begin{cases}
      factor(build_{∨}(φ₁, ψ) ∨ build_{∨}(φ₂,ψ)),  &\text{ if }φ≡ φ₁ ∨ φ₂\\
      build_{∨}(φ, ψ),  & \text{ otherwise.}
    \end{cases}
  \end{split}
\end{align*}
\end{definition}

\begin{lemma}[lem-sbuild$_{∨}$]
\label{lem:lem-sbuild-or}
$Γ ⊢ φ$, and $ψ : \Prop$ then $Γ ⊢ sbuild_{∨}(φ, ψ)$.
\end{lemma}

\begin{example}
Let see the main idea behind the lem-sbuild$_{∨}$ lemma.
We build the disjunction $((p ∨ q) ∨ r)$ from the disjunction
$(r ∨ (q ∨ p))$.
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ q$}
  \RightLabel{∨-intro₂}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \AxiomC{$Γ ⊢ p$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \RightLabel{∨-elim}
  \BinaryInfC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ r$}
  \RightLabel{∨-intro₂}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \AxiomC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}

  \RightLabel{∨-elim}
  \BinaryInfC{$Γ, r ∨ (q ∨ p) ⊢ (p ∨ q) ∨ r$}

  \RightLabel{⇒-intro}
  \UnaryInfC{$Γ ⊢ r ∨ (q ∨ p) ⇒ (p ∨ q) ∨ r$}

  \end{bprooftree}
\end{equation*}
\end{example}

Notice that using $sbuild_{∨}$ we can build not only a disjunction with the same disjuncts of the source formula but also a complete different formula by adding new disjuncts to the source formula.

\begin{definition}[reorder$_{∨}$]
\begin{align*}
    \label{eq:reorder-or}
    \begin{split}
    &reorder_{∨} : \Prop \to \Prop \to \Prop\\
    &reorder_{∨} (φ, ψ) = sbuild_{∨}(rdisj(φ), ψ).
    \end{split}
  \end{align*}
\end{definition}

\begin{theorem}[thm-reorder$_{∨}$]
  \label{thm-reorder-or}
  $Γ ⊢ φ$, and $ψ: \Prop$ then $Γ ⊢ reorder_{∨}(φ, ψ)$.
\end{theorem}

\begin{proof}
Use Lemma~\ref{lem:lem-rdisj} and Lemma~\ref{lem:lem-sbuild-or}.
\end{proof}

We define similar functions and state some theorems as we previously did for disjunctions, but instead, we treat only with conjunctive normal forms.

\begin{definition}[reorder$_{∧}$]
  \begin{align*}
      \begin{split}
        &reorder_{∧} : \Prop → \Prop \to \Prop\\
        &reorder_{∧}(φ, ψ) =
        \begin{cases}
          φ, &\text{ if }φ ≡ ψ\\
          ψ₁ ∧ ψ₂, &\text{ if } ψ ≡ ψ₁ ∧ ψ₂\text{, }reorder_{∧}(φ, ψ₁) ≡ ψ₁\\
                  &\text{and }reorder_{∧}(φ, ψ₂)≡ ψ₂\\
          φ,       &\text{ if } ψ ≡ ψ₁ ∧ ψ₂\\
          conjunct(φ, ψ), &\text{ otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-reorder$_{∧}$]
  \label{lem:lem-reorder-and}
  $Γ ⊢ φ$, and $ψ : \Prop$ then $Γ ⊢ reorder_{∧}(φ, ψ)$.
\end{lemma}

\begin{definition}[conjunct$_{∨}$]
  \label{eq:conjunct-or-definition}
\begin{align*}
  \begin{split}
    &conjunct_{∨} : \Prop → \Prop \to \Prop\\
    &conjunct_{∨}(φ, ψ) =
    \begin{cases}
      ψ, &\text{ if }φ ≡ ψ\\
      ψ, &\text{ if }reorder_{∨}(φ, ψ) ≡ ψ\\
      ψ, &\text{ if }ψ ≡ ψ₁ ∧ ψ₂,\ conjunct_{∨}(φ, ψ₁) ≡ ψ₁,\\
        &\text{and } reorder_{∨}(φ, ψ₂) ≡ ψ₂\\
      ψ, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ conjunct_{∨}(φ₁, ψ) ≡ ψ\\
      ψ, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ conjunct_{∨}(φ₂, ψ) ≡ ψ\\
      φ, &\text{ otherwise.}
    \end{cases}
  \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-conjunct$_{∨}$]
  \label{lem:lem-conjunct-or}
  $Γ ⊢ φ$, and $ψ : \Prop$ then $Γ ⊢ conjunct_{∨}(φ, ψ)$.
\end{lemma}

\begin{definition}[reorder$_{∧∨}$]
 \begin{align*}
      \begin{split}
      &reorder : \Prop \to \Prop \to \Prop\\
      &reorder_{∧∨}(φ, ψ)=
        \begin{cases}
          ψ, &\text{ if } φ≡ψ\\
          ψ, &\text{ if } ψ ≡ ψ₁ ∧ ψ₂,\ reorder_{∧∨}(φ,ψ₁) ≡ ψ₁\\
             &\text{and }reorder_{∧∨}(φ, ψ₂) ≡ ψ₂\\
          φ, &\text{ if }ψ ≡ ψ₁ ∧ ψ₂\\
          conjunct_{∨}(φ, ψ) &\text{ otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
  \end{definition}

\begin{theorem}[thm-reorder$_{∧∨}$]
  \label{thm:thm-reorder-and-or}
  $Γ ⊢ φ$, and $ψ : \Prop$ then $Γ ⊢ reorder_{∧∨}(φ, ψ)$.
\end{theorem}

% % --------------------------------------------------------------------

\subsubsection{Resolution.}
\label{sssec:resolve}

The \resolve rule incorporates the resolution theorem showed in
Fig.~\ref{fig:metis-inferences} for the \TSTP derivations.
This rule posses three arguments: a positive literal $l$ to apply the
resolution theorem, and two derivations.
The positive literal $l$ must occur in
the formula from the first derivation and the
negative literal must occur in the formula from the second derivation,
see the pattern of \emph{resolve} rule in Fig.~\ref{fig:metis-inferences}.

% \begin{figure}
\label{fig:resolve-tstp-example}
\begin{verbatim}
cnf(refute_0_4, plain, (~ r | p | q),
    inference(canonicalize, [], [normalize_0_5])).
cnf(refute_0_5, plain, (p | q | r),
    inference(canonicalize, [], [normalize_0_6])).
cnf(refute_0_6, plain, (p | q),
    inference(resolve, [$cnf(r)], [refute_0_5, refute_0_4])).
\end{verbatim}
% \caption{Excerpt of a \Metis \TSTP example for the \resolve rule.}
% \end{figure}

To emulate this rule, we perform a sequence of rearrangements inside the
formulas involved to match with the pattern expected by the resolution theorem
described above. We begin by defining a convenient version of
the binary resolution in Def.~\ref{def:rsol}.

\begin{definition}[rsol]
\label{def:rsol}
\begin{align*}
      \begin{split}
        &rsol : \Prop \to \Prop\\
        &rsol(φ) =
        \begin{cases}
          φ₂, &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (φ₃ ∨ φ₄), φ₃ ≡ ¬ φ₁, φ₂ ≡ φ₄\\
          φ₂ ∨ φ₄, &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (φ₃ ∨ φ₄), φ₃ ≡ ¬ φ₁\\
          φ, &\text{ otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-rsol]
  \label{lem:lem-rsol}
  $Γ ⊢ φ$ then $Γ ⊢ rsol(φ)$.
\end{lemma}

In Def.~\ref{def:resolve}, the emulated rule for $resolve$
has four arguments. The first three were described
above, the last one, ψ, represents the expected conclusion in the \Metis
derivation.

\begin{definition}[resolve]
\label{def:resolve}
 \begin{align*}
 \begin{split}
    &resolve : \Prop \to \Prop \to \Prop \to \Prop \to \Prop\\
    &resolve(φ₁, φ₂, l, ψ) =
      rsol(reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨} (φ₂, ¬ l ∨ ψ)).
  \end{split}
  \end{align*}
\end{definition}

\begin{theorem}[thm-resolve]
  \label{thm:thm-resolve}
  $Γ ⊢ φ₁$, $Γ ⊢ φ₂$, a literal $l$, and $ψ: \Prop$ then $Γ ⊢ resolve(φ₁, φ₂, l, ψ)$.
\end{theorem}
\Needspace{3\baselineskip}
\begin{proof}
 \begin{equation*}
    \begin{bprooftree}
      \AxiomC{$Γ ⊢ φ₁$}
      \RightLabel{thm-reorder$_{∨}$,}
      \UnaryInfC{$Γ ⊢ reorder_{∨}(φ₁, l ∨ ψ)$}
   \end{bprooftree}
  \end{equation*}
    \vskip 1.5mm
 \begin{equation*}
    \begin{bprooftree}
      \AxiomC{$Γ ⊢ φ₂$}
      \RightLabel{thm-reorder$_{∨}$,}
      \UnaryInfC{$Γ ⊢ reorder_{∨}(φ₂, ¬ l ∨ ψ)$}
   \end{bprooftree}
  \end{equation*}
  \vskip 1.5mm
  \begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ reorder_{∨}(φ₁, l ∨ ψ)$}
    \AxiomC{$Γ ⊢ reorder_{∨}(φ₂, ¬ l ∨ ψ)$}
    \RightLabel{∧-intro}
    \BinaryInfC{$Γ ⊢ reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨}(φ₂, ¬ l ∨ ψ)$}
    \RightLabel{lem-rsol.}
    \UnaryInfC{$Γ ⊢ rsol(reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨}(φ₂, ¬ l ∨ ψ))$}
  \end{bprooftree}
  \end{equation*}
\end{proof}

\begin{figure}
\label{fig:resolve-example}
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ ¬ r ∨ p ∨ q$}
  \AxiomC{$Γ ⊢ p ∨ q ∨ r $}
  \RightLabel{thm-resolve}
  \BinaryInfC{$Γ ⊢ resolve(¬ r ∨ p ∨ q, p ∨ q ∨ r, r, p ∨ q)$}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \end{bprooftree}
\end{equation*}
\caption{Example of a resolution in \Metis using
Thm.~\ref{thm:thm-resolve}.}
%Application of Thm.~\ref{thm:thm-resolve} for the \TSTP excerpt Fig.~\ref{fig:resolve-tstp-example}.}
\end{figure}

% subsubsection resolve (end)
% --------------------------------------------------------------------


% % --------------------------------------------------------------------

\subsubsection{Normalization.}
\label{sssec:normalization}
The normalization module in \Metis is the responsible for
\canonicalize, \clausify, \conjunct and \simplify.
One of the main purposes of the module consists of adding the axioms
to the problem. In this process, some transformations are carried
out by convert a \verb!fof! formula to their clausal normal form.
The process mainly consists of removing redundancies (tautologies or
definitions) and converting the proposition to its normalized
negative normal form, conjunctive normal form, or
definitional normal form.

\begin{definition}[\abbre{NProp}]
  \NProp is the type for a formula in normalized negative normal form
  in which negations appear only in the literals and the expression is in terms only of ($⊥$, $⊤$, $¬$, $∧$, $∨$, $⊻$) connectives. The $⊻$ connective is the exclusive disjunction.
  We define the \NProp type in a similar way as we did for \Prop type.
\end{definition}

A sequent $Γ ⟝ φ$ represents a theorem where
$Γ$ is a set of \Prop propositions premises, and $φ : \NProp$ is the
conclusion of the theorem. These theorems have a subset of rules from
the classical inference rules in Fig.~\ref{fig:CPL-inference-rules}
that apply for the connectives that coincides with \NProp type.

% φ ⊻ ψ if and only if ¬ (φ ⇔ ψ).

\begin{figure}
  \[
    \begin{bprooftree}
      \AxiomC{$φ ∧ ⊥$}
      \UnaryInfC{$⊥$}
    \end{bprooftree}
    \qquad
    \begin{bprooftree}
      \AxiomC{$φ ∧ ⊤$}
      \UnaryInfC{$φ$}
    \end{bprooftree}
    \qquad
    \begin{bprooftree}
      \AxiomC{$φ ∧ ¬ φ$}
      \UnaryInfC{$⊥$}
    \end{bprooftree}
    \qquad
    \begin{bprooftree}
      \AxiomC{$φ ∧ φ$}
      \UnaryInfC{$φ$}
    \end{bprooftree}
  \]

  \[
    \begin{bprooftree}
      \AxiomC{$φ ∨ ⊥$}
      \UnaryInfC{$φ$}
    \end{bprooftree}
    \qquad
    \begin{bprooftree}
      \AxiomC{$φ ∨ ⊤$}
      \UnaryInfC{$⊤$}
    \end{bprooftree}
    \qquad
    \begin{bprooftree}
      \AxiomC{$φ ∨ ¬ φ$}
      \UnaryInfC{$⊤$}
    \end{bprooftree}
    \qquad
    \begin{bprooftree}
      \AxiomC{$φ ∨ φ$}
      \UnaryInfC{$φ$}
    \end{bprooftree}
  \]
\caption{Some definitions applied to translate a formula into its
normalized normal form.}
\label{fig:conjunctive-disjunctive-simpl}
\end{figure}

% -------------------------------------------------------------------
\subsubsection{Redundancy.}
\label{sssec:redundancy}

In this section we provide functions and theorems to remove, inside a normalized formula, the definitions showed in
Fig.~\ref{fig:conjunctive-disjunctive-simpl}.

\begin{remark}
We assume all formulas are in right-associative form in
the input of the functions by applying a version of $rdisj$ or $rconj$
functions for normalized propositions (see Def.~\ref{def:rdisj}).
\end{remark}

In a disjunction, $φ = φ₁ ∨ φ₂ ∨ \cdots ∨ φₙ$, we say $ψ ∈_{∨} φ$,
if there is some $i = 1, \cdots, n$ such that $ψ = φᵢ$.
$ψ ∈_{∨} φ$ is another name for the equality
$ψ ≡ conjunct_{∨}(φ, ψ)$.

\begin{definition}[rm$_∨$]
  \label{def:rm-or}
  \begin{align*}
    \begin{split}
      &rm_{∨} :  \NProp \to \NProp\\
      &rm_{∨}(φ) =
      \begin{cases}
        rm_{∨}(φ₂), &\text{ if }φ ≡ φ₁ ∨ φ₂,\ φ₁ ∈_{∨} φ₂\\
        φ₁ ∨ rm_{∨}(φ₂), &\text{ if }φ ≡ φ₁ ∨ φ₂\\
        φ,  &\text{ otherwise.}
      \end{cases}
    \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-rm$_{∨}$]
  \label{lem:lem_rm-or}
  $Γ ⟝ φ$ then $Γ ⟝ rm_{∨}(φ)$.
\end{lemma}

Now, we have removed redundancies in the disjunctions by applying
$rm_{∨}$ function, we can define a similar function to work with
conjunctions, i.e., $rm_{∧}$.

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∨ φ$}
  \RightLabel{lem-rm$_∨$,}
  \UnaryInfC{$Γ ⟝ φ$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∧ φ$}
  \RightLabel{lem-rm$_∧$.}
  \UnaryInfC{$Γ ⟝ φ$}
  \end{bprooftree}
\end{equation*}

In a conjunction, $φ = φ₁ ∧ φ₂ ∧ \cdots ∧ φₙ$, we say
$ψ ∈_{∧} φ$, if there is some $i = 1, \cdots, n$ such that $ψ = φᵢ$.
We define $ψ ∈_{∧} φ$ as the equality $ψ ≡ conjunct(φ, ψ)$.

\begin{definition}[rm$_∧$]
\label{eq:rm-and}
  \begin{align*}
    \begin{split}
    &rm_{∧} : \NProp \to \NProp\\
    &rm_{∧}(φ) =
    \begin{cases}
      rm_{∧}(φ₂),      &\text{ if }φ ≡ φ₁ ∧ φ₂, φ₁ ∈_{∧} φ₂\\
      φ₁ ∧ rm_{∧}(φ₂), &\text{ if }φ ≡ φ₁ ∧ φ₂\\
      φ,               &\text{ otherwise.}
    \end{cases}
    \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-rm$_{∧}$] % (fold)
  \label{lem:lem_rm-and}
  $Γ ⟝ φ$ then $Γ ⟝ rm_{∧}(φ)$.
\end{lemma}

Continuing with the rest of tautologies from
Fig.~\ref{fig:conjunctive-disjunctive-simpl}, we define the
$ndisj_{∨}$ function and $ndisj_{∨}$ function that
take into account the following cases.

\begin{equation*}
\begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∨ ¬~φ$}
  \RightLabel{lem-ndisj$_{∨}$,}
  \UnaryInfC{$Γ ⟝ ⊤$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∨ ⊤$}
  \RightLabel{lem-ndisj$_{∨}$,}
  \UnaryInfC{$Γ ⟝ ⊤$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∨ ⊥$}
  \RightLabel{lem-ndisj$_{∨}$.}
  \UnaryInfC{$Γ ⟝ φ$}
\end{bprooftree}
\end{equation*}

\begin{equation*}
\begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∧ ¬~φ$}
  \RightLabel{lem-ndisj$_{∧}$,}
  \UnaryInfC{$Γ ⟝ ⊥$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∧ ⊤$}
  \RightLabel{lem-ndisj$_{∧}$,}
  \UnaryInfC{$Γ ⟝ φ$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∧ ⊥$}
  \RightLabel{lem-ndisj$_{∧}$.}
  \UnaryInfC{$Γ ⟝ ⊥$}
\end{bprooftree}
\end{equation*}


\begin{definition}[ndisj$_{∨}$]
  \label{def:ndisj-or}
  \begin{align*}
    \begin{split}
    &ndisj_{∨} : \NProp \to \NProp\\
    &ndisj_{∨}(φ) =
      \begin{cases}
        ⊤, &\text{ if }φ ≡ ¬ φ₁ ∨ φ₂,\ φ₁ ∈_{∨} φ₂\\
        ⊤, &\text{ if }φ ≡ ¬ φ₁ ∨ φ₂,\ ndisj_{∨}(φ₂) ≡ ⊤\\
        ¬ φ₁ ∨ ndisj_{∨}(φ₂), &\text{ if }φ ≡ ¬ φ₁ ∨ φ₂\\
        ⊤, &\text{ if }φ ≡ φ₁ ∨ φ₂,\ ¬φ₁ ∈_{∨} φ₂ \\
        ⊤, &\text{ if }φ ≡ φ₁ ∨ φ₂,\ ndisj_{∨}(φ₂) ≡ ⊤\\
        φ₁ ∨ ndisj_{∨}(φ₂),  &\text{ if }φ ≡ φ₁ ∨ φ₂\\
        φ, &\text{ otherwise.}
      \end{cases}
    \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-ndisj$_{∨}$] % (fold)
  \label{lem:lem_ndisj-or}
  $Γ ⟝ φ$ then $Γ ⟝ ndisj_{∨}(φ)$.
\end{lemma}

\begin{definition}[ndisj$_{∧}$]
  \label{def:ndisj-and}
  \begin{align*}
    \begin{split}
    &ndisj_{∧} : \NProp \to \NProp\\
    &ndisj_{∧}(φ) =
      \begin{cases}
        ⊥, &\text{ if }φ ≡ ¬ φ₁ ∧ φ₂,\ φ₁ ∈_{∧} φ₂\\
        ⊥, &\text{ if }φ ≡ ¬ φ₁ ∧ φ₂,\ ndisj_{∧}(φ₂) ≡ ⊥\\
        ¬ φ₁ ∧ ndisj_{∧}(φ₂), &\text{ if }φ ≡ ¬ φ₁ ∧ φ₂\\
        ⊥, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ φ₁ ∈_{∧} φ₂\\
        ⊥, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ ndisj_{∧}(φ₂) ≡ ⊥\\
        φ₁ ∧ ndisj_{∧}(φ₂), &\text{ if }φ ≡ φ₁ ∧ φ₂\\
        φ, &\text{ otherwise.}
      \end{cases}
    \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-ndisj$_{∧}$] % (fold)
  \label{lem:lem_ndisj-and}
  $Γ ⟝ φ$ then $Γ ⟝ ndisj_{∧}(φ)$.
\end{lemma}

% subsubsection redundancy (end)
% -------------------------------------------------------------------

We use the functions defined above to remove redundancies in conjunctions with $canon_{∧}$ function, and
$canon_{∨}$ function to remove redundancies in disjunctions.

\begin{definition}[canon$_{∧}$]
\label{def:canon-and}
\begin{align*}
    \begin{split}
      &canon_{∧} : \NProp \to \NProp\\
      &canon_{∧}(φ) =
        \begin{cases}
          φⱼ, &\text{ if } φ ≡ φ₁ ∧ φ₂,\ φᵢ ≡ ⊤,\text{ for } i,j = 1,2, i≠j\\
          ⊥,  &\text{ if } φ ≡ φ₁ ∧ φ₂,\ φᵢ ≡ ⊥,\text{ for } i,j = 1,2\\
          rm_∧(ndisj_∧(φ)), &\text{ if } φ ≡ φ₁ ∧ φ₂\\
          φ,                &\text{ otherwise.}
        \end{cases}
    \end{split}
\end{align*}
\end{definition}

\begin{lemma}[lem-canon$_{∧}$]
  \label{lem:lem_canon-and}
  $Γ ⟝ φ$ then $Γ ⟝ canon_{∧}(φ)$.
\end{lemma}

\begin{definition}[canon$_{∨}$]
\label{def:canon-or}
\begin{align*}
    \begin{split}
      &canon_{∨} : \NProp \to \NProp\\
      &canon_{∨}(φ) =
        \begin{cases}
        φⱼ, &\text{ if } φ ≡ φ₁ ∨ φ₂,\ φᵢ ≡ ⊥,\text{ for } i,j = 1,2, i≠j\\
        ⊤, &\text{ if } φ ≡ φ₁ ∨ φ₂,\ φᵢ ≡ ⊤,\text{ for } i,j = 1,2\\
        rm_∨(ndisj_∨(φ)), &\text{ if } φ ≡ φ₁ ∧ φ₂\\
        φ, &\text{ otherwise.}
        \end{cases}
    \end{split}
\end{align*}
\end{definition}

\begin{lemma}[lem-canon$_{∨}$]
  \label{lem:lem_canon-or}
  $Γ ⟝ φ$ then $Γ ⟝ canon_{∨}(φ)$.
\end{lemma}

\begin{remark}
A similar treatment defines the $canon_{⊻} : \NProp \to \NProp$.
This function removes redundancies related with the exclusive
disjunction connective.
% Its theorem, thm-canon$_{⊻}$ is presented in~\cite{AgdaMetis}.
We left out this description for the brevity of this
document and refer the interested reader to \cite{AgdaMetis} for
more details.
\end{remark}

Finally, we can translate formulas from \Prop to \NProp by defining
the $nnf₀$ function. This function is based on the $nnf$ function described in
\citeauthor{Bezem2002}~\cite{Bezem2002}. Their $nnf$ function
translates formulas to their classical negative normal form. In the
reference, the authors avoid a termination problem with a similar
function by using, as an extra argument, the polarity of the formula.
We follow the same idea in Def.~\ref{def:nnf-zero}.
Therefore, we need the \abbre{Polarity} type with
two constructors: $⊕$ to denote positive polarity, and $⊖$ to denote
negative polarity of the formula.

\begin{definition}[nnf₀]
\label{def:nnf-zero}
  \begin{align*}
    \begin{split}
    &nnf₀ : \abbre{Polarity} \to \Prop \to \NProp\\
    &nnf₀(⊕, φ) =
      \begin{cases}
      canon_{∧}(nnf₀(⊕, φ₁) ∧ nnf₀(⊕, φ₂)), &\text{ if }φ ≡ φ₁ ∧ φ₂ \\
      canon_{∨}(nnf₀(⊕, φ₁) ∨ nnf₀(⊕, φ₂)), &\text{ if }φ ≡ φ₁ ∨ φ₂ \\
      canon_{∨}(nnf₀(⊖, φ₁) ∨ nnf₀(⊕, φ₂)), &\text{ if }φ ≡ φ₁ ⇒ φ₂ \\
      canon_{⊻}(nnf₀(⊖, φ₁) ⊻ nnf₀(⊕, φ₂)), &\text{ if }φ ≡ φ₁ ⇔ φ₂ \\
      nnf₀(⊖, φ₁),                          &\text{ if }φ ≡ ¬ φ₁ \\
      φ,                                    &\text{ otherwise.} \\
      \end{cases}\\
    &nnf₀(⊖, φ) =
      \begin{cases}
      canon_{∨}(nnf₀(⊖, φ₁) ∨ nnf₀(⊖, φ₂)),  &\text{ if }φ ≡ φ₁ ∧ φ₂ \\
      canon_{∧}(nnf₀(⊖, φ₁) ∧ nnf₀(⊖, φ₂)),  &\text{ if }φ ≡ φ₁ ∨ φ₂ \\
      canon_{∧}(nnf₀(⊖, φ₂) ∧ nnf₀(⊖, φ₁)),  &\text{ if }φ ≡ φ₁ ⇒ φ₂ \\
      canon_{⊻}(nnf₀(⊕, φ₁) ⊻ nnf₀(⊕, φ₂)),  &\text{ if }φ ≡ φ₁ ⇔ φ₂ \\
      nnf₀(⊕, φ₁),                           &\text{ if }φ ≡ ¬ φ₁ \\
      ⊥,                                     &\text{ if }φ ≡ ⊤ \\
      ⊤,                                     &\text{ if }φ ≡ ⊥ \\
      φ,                                     &\text{ otherwise.} \\
      \end{cases}
    \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-nnf]
  \label{lem:lem-nnf}
  $Γ ⊢ φ$ then $Γ ⟝ nnf(φ)$ where,
  \begin{align*}
   \begin{split}
     &nnf : \NProp \to \NProp\\
     &nnf(φ) = nnf₀(⊕, φ).
   \end{split}
  \end{align*}
\end{lemma}

\begin{lemma}[lem-dist$_{∨}$]
  \label{lem:lem-dist-or}
  $Γ ⟝ φ$ then $Γ ⟝ dist_{∨}(φ)$, where,
  \begin{align*}
    \begin{split}
    &dist_{∨} : \Prop \to \Prop\\
    &dist_{∨}(φ) =
      \begin{cases}
        dist_{∨}(φ₁ ∨ φ₂) ∧ dist_{∨}(φ₂ ∨ φ₃), &\text{ if }φ ≡ (φ₁ ∧ φ₂) ∨ φ₃\\
        dist_{∨}(φ₁ ∨ φ₃) ∧ dist_{∨}(φ₁ ∨ φ₃), &\text{ if }φ ≡ φ₁ ∨ (φ₂ ∧ φ₃)\\
        φ,                                     &\text{ otherwise.}
      \end{cases}
    \end{split}
  \end{align*}
\end{lemma}

\begin{lemma}[lem-dist]
  \label{lem:lem-dist}
  $Γ ⟝ φ$ then $Γ ⟝ dist(φ)$, where,
  \begin{align*}
      \begin{split}
      &dist : \Prop \to \Prop\\
      &dist(φ) =
        \begin{cases}
          dist(φ₁) ∧ dist(φ₂),
            &\text{ if }φ ≡ φ₁ ∧ φ₂\\
          dist_{∨}(dist(φ₁) ∨ dist(φ₂)),
            &\text{ if }φ ≡ φ₁ ∨ φ₂\\
          φ, &\text{ otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
\end{lemma}

\begin{sketchproof} If $φ ≡ φ₁ ∨ φ₂$, we get for $i = 1, 2$,
\begin{equation*}
  \begin{bprooftree}
    \RightLabel{assume}
    \AxiomC{$Γ, φ_{i} ⊢ φ_{i}$}
    \RightLabel{lem-dist}
    \UnaryInfC{$Γ ⊢ dist(φ_{i})$}
    \RightLabel{∨-intro$_{1,2}$}
    \UnaryInfC{$Γ, φ_{i} ⊢ dist(φ₁) ∨ dist(φ₂)$}
    \RightLabel{lem-dist$_{∨}$.}
    \UnaryInfC{$Γ, φ_{i} ⊢ dist_{∨}(dist(φ₁) ∨ dist(φ₂))$}
    \end{bprooftree}
\end{equation*}
Then, by using the ∨-elim rule in the last derivation above, we
derive $Γ, φ₁ ∨ φ₂ ⟝ dist_{∨}(dist(φ₁) ∨ dist(φ₂))$ and the lemma
follows.
\end{sketchproof}

To convert normalized propositions to classical propositions, we
make the following definition, completing the translation between
these two types.

\begin{definition}[form]
\begin{align*}
    \begin{split}
      &form : \NProp \to \Prop\\
      &form(φ) =
      \begin{cases}
        form(φ₁) ∧ form(φ₂), &\text{ if }φ ≡ φ₁ ∧ φ₂\\
        form(φ₁) ∨ form(φ₂), &\text{ if }φ ≡ φ₁ ∨ φ₂\\
        form_{⊻}(φ₂),        &\text{ if }φ ≡ φ₁ ⊻ φ₂\\
        % ⊥, &\text{ if }φ ≡ ⊥\\
        % ⊤, &\text{ if }φ ≡ ⊤\\
        φ, &\text{ otherwise.}\\
      \end{cases}
    \end{split}
\end{align*}
\end{definition}

\begin{lemma}[lem-form]
  \label{lem:lem-form}
   $Γ ⟝ φ$ then $Γ ⊢ form(φ)$.
\end{lemma}

As a result, we can get a conjunctive normal form by applying the
following theorem.

\begin{theorem}[thm-cnf]
\label{thm:thm-cnf}
  $Γ ⊢ φ$ then $Γ ⊢ cnf(φ)$, where,
  \begin{align*}
    \begin{split}
    &cnf : \Prop \to \Prop\\
    &cnf = form ∘ dist ∘ nnf.
    \end{split}
  \end{align*}
\end{theorem}

\begin{proof}
  Composition of the Lemmas \ref{lem:lem-form}, \ref{lem:lem-dist} and \ref{lem:lem-nnf}.
\end{proof}

Since all the previous transformations came from  equivalences in  the
classical propositional logic, the following theorem plays an important role
in the next section.

\begin{theorem}[thm-inv-cnf]
\label{thm:thm-inv-cnf}
  $Γ ⊢ cnf(φ)$ then $Γ ⊢ φ$.
\end{theorem}

% subsubsection normal_forms (end)
% --------------------------------------------------------------------

% -------------------------------------------------------------------
\subsubsection{Canonicalize.}
\label{sssec:canonicalize}

The \canonicalize rule is an overloaded inference rule which performs
normalization of the proposition input.
%This rule can introduce axioms and definitions into the problem solution.
This rule converts a \texttt{fof} %TODO
formula in clausal form to a \CNF clause but also it performs some
simplifications in the process (e.g., removing ⊤ and ⊥ in the formula).

Since this rule mostly consists of dealing with \CNF clauses, to
justify its reasoning, our strategy mainly consists of checking the
equality of normalized negative form between the source and the
target formula. If it fails, we try to reorder the conjunctive
normal form of the source formula to match with
the conjunctive normal form of the target formula.

\begin{definition}[canonicalize]
\label{def:canonicalize}
\begin{align*}
    \begin{split}
      &canonicalize : \Prop \to \Prop \to \Prop\\
      &canonicalize(φ, ψ) =
      \begin{cases}
        ψ, &\text{ if }ψ ≡ φ\\
        ψ, &\text{ if }ψ ≡ form(nnf(φ))\\
        ψ, &\text{ if }cnf(ψ) ≡ reorder_{∧∨}(cnf(φ), cnf(ψ))\\
        φ, &\text{ otherwise.}\\
      \end{cases}
    \end{split}
\end{align*}
\end{definition}

\begin{theorem}[thm-canonicalize] % (fold)
  \label{thm:thm-canonicalize}
  \hspace{4mm}\\
  $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ canonicalize(φ, ψ)$.
\end{theorem}

\begin{proof}\hspace{3mm}
\begin{itemize}
\item If $φ ≡ ψ$ by substitution theorem we conclude $Γ ⊢ ψ$.
\item If $ψ ≡ form(nnf(φ))$,
\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{lem-nnf}
    \UnaryInfC{$Γ ⊢₂~nnf(φ)$}
    \RightLabel{lem-form}
    \UnaryInfC{$Γ ⊢ form(nnf(φ))$}
    \AxiomC{$ψ ≡ form(nnf(φ))$}
    \RightLabel{subst.}
    \BinaryInfC{$Γ ⊢ ψ$}
  \end{bprooftree}
\end{equation*}
\item If $γ = cnf(ψ) ≡ reorder_{∧∨}(cnf(φ), cnf(ψ))$,
\begin{equation*}
  \begin{bprooftree}
     \AxiomC{$Γ ⊢ φ$}
     \RightLabel{thm-cnf}
     \UnaryInfC{$Γ ⊢ cnf(φ)$}
     \RightLabel{thm-reorder$_{∧∨}$}
     \UnaryInfC{$Γ ⊢ reorder_{∧∨}(cnf(φ), cnf(ψ))$}
     \AxiomC{$γ$}
    \RightLabel{subst}
    \BinaryInfC{$Γ ⊢ cnf(ψ)$}
    \RightLabel{thm-inv-cnf.}
    \UnaryInfC{$Γ ⊢ ψ$}
  \end{bprooftree}
\end{equation*}
\end{itemize}
\end{proof}

% subsubsection canonicalize (end)
% -------------------------------------------------------------------

% --------------------------------------------------------------------

\subsubsection{Clausification.}
\label{sssec:clausification}

The \clausify rule transforms a
propositional formula into its clausal normal form, a conjunction
of clauses. A \emph{clause} is the disjunction of zero or more
literals and a \emph{literal} is an atom (positive literal) or a
negation of an atom (negative literal).
It is important to notice that this kind of conversion
between one formula to its clausal normal form is not unique, and \Metis has a
customized approach to perform that transformation. That is the reason we
perform some reordering for the CNF of the source formula to fulfill this
issue.

In the following \Metis \TSTP derivation, we see an example where
\clausify expands the formula \texttt{normalize\_0\_0} by using distributive
laws presented in conjunctive normal form conversion.

\begin{verbatim}
fof(a1, axiom, (p => (q & r))).
...
fof(normalize_0_0, plain, (~ p | (q & r)),
    inference(canonicalize, [], [a1])).
fof(normalize_0_1, plain, ((~ p | q) & (~ p | r)),
    inference(clausify, [], [normalize_0_0])).
\end{verbatim}

\begin{definition}[clausify]
  \label{def:clausify}
 \begin{align*}
   \begin{split}
      &clausify : \Prop → \Prop → \Prop\\
      &clausify(φ,ψ) =
      \begin{cases}
        ψ, &\text{ if }φ≡ψ\\
        reorder_{∧∨}(cnf(φ), ψ), &\text{ otherwise.}
      \end{cases}
      \end{split}
  \end{align*}
\end{definition}

\begin{theorem}[thm-clausify]
\label{thm:thm-clausify}
  $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ clausify(φ, ψ)$.
\end{theorem}

\begin{proof} If $φ ≡ ψ$, this lemmas follows after applying $subs$
lemma. Otherwise, we use Theorem~\ref{thm:thm-reorder-and-or} and Theorem~\ref{thm:thm-cnf}.
\end{proof}

\begin{remark}
The \clausify rule is often preceded by the \canonicalize rule.
Both rules perform \emph{Clausification} that introduces
into the problem axioms or definitions in the domain of the solution.
The Clausification algorithms is mainly described on paper by
\citeauthor{Sutcliffe1996}~\cite{Sutcliffe1996}. We left for future work
investigate the consequences of removing $clausify$ inference by
strengthen $canonicalize$ rule in Def.~\ref{def:canonicalize}
\end{remark}

% subsubsection clausification (end)
% --------------------------------------------------------------------

% -------------------------------------------------------------------
\subsubsection{Simplification.}
\label{sssec:simplify}

The \simplify rule is an inference that performs simplification of
definitions and tautologies. This rule
transverses a list of previous derivations by applying different theorems
(e.g., \emph{modus pones}, \emph{modus tollens}, or \emph{disjunctive
syllogism}) to get a contradiction in the first place, or a smaller
convenient formula

% To emulate this rule, we use theorems from Section~\ref{sssec:canonicalize},
% Section~\ref{sssec:conjunct}.
The following \TSTP excerpt is an example of the \simplify rule.

% \begin{figure}
\begin{verbatim}
fof(normalize_0_1, plain, (g | (~ a & k)),
    inference(conjunct, [], [normalize_0_0])).
fof(normalize_0_2, plain, (~ g | q),
    inference(conjunct, [], [normalize_0_0])).
fof(normalize_0_3, plain, (~ q),
  inference(conjunct, [], [normalize_0_0])).
fof(normalize_0_4, plain, (~ g),
    inference(simplify, [], [normalize_0_2, normalize_0_3])).
fof(normalize_0_5, plain, (~ k),
inference(conjunct, [], [normalize_0_0])).
fof(normalize_0_6, plain, ($false),
    inference(simplify, [],
              [normalize_0_1, normalize_0_4, normalize_0_5])).
\end{verbatim}
% \caption{Example of \simplify rule in a \TSTP derivation of \Metis.}
% \end{figure}

%TODO check canonicalize can reduce a conjunction into one smaller.
\begin{definition}[simplify]
\label{def:simplify}
For $i,\, j = 1, 2$, $i\neq j$ and $γ : \Prop$,
\begin{align*}
    \begin{split}
      &\textit{simplify} : \Prop → \Prop → \Prop → \Prop\\
      &\textit{simplify}(φ₁, φ₂, ψ) =\\
      &\hspace{4mm}
      \begin{cases}
        ψ,          &\text{ if }φᵢ ≡ ψ\\
        ⊥,          &\text{ if }φᵢ ≡ ⊥\\
        φⱼ,         &\text{ if }φᵢ ≡ ⊤\\
        γ,          &\text{ if }φᵢ ≡ φⱼ ⇒ γ\\
        γ,          &\text{ if }φᵢ ≡ γ ⇒ nnf(¬ φⱼ)\\
        γ,          &\text{ if }φᵢ ≡ φⱼ ⇔ γ \\
        nnf(¬ γ),   &\text{ if }φᵢ ≡ nnf(¬ φⱼ) ⇔ γ \\
        γ,          &\text{ if }φᵢ ≡ nnf(¬ φⱼ) ∨ γ\\
        ⊥,          &\text{ if } nnf(¬ φⱼ) ≡ conjunct(φᵢ, nnf(¬ φⱼ))\\
      % φ          &\text{ if }conjunct(nnf(¬ φᵢ), φⱼ) ≡  φⱼ\\
        ⊥,          &\text{ if } ¬ φⱼ ≡ canonicalize(φᵢ, ¬ φⱼ) \\
        φ₁,         &\text{ otherwise.}\\
      \end{cases}%\hspace{10cm}
    \end{split}
\end{align*}
\end{definition}

\begin{remark}
Besides the fact that $\List\ \Prop \to \Prop$ is the type that coincides
with the \simplify rule in \TSTP derivations, we choose a different
option. In the translation from \TSTP to \Agda, we take the list of
derivations and use a classical left folding ($foldl$) with
$simplify$ function over the list of $φ₁, φ₂, \cdots, φₙ$
that avoids us to define a new sequent type to
support \List \Prop type in the conclusion side.
\end{remark}

\begin{theorem}[thm-simplify] % (fold)
  \label{thm:thm-simplify}
For $i=1,\, 2, \cdots, n$, $Γ ⊢ φᵢ$ and $ψ : \Prop$ then
if $n > 2$, $Γ ⊢ simplify(γ_{n-2}, φ_{n}, ψ)$ where $γ_{i} = simplify(φ_{i}, φ_{i+1}, ψ)$
else $Γ ⊢ simplify(φ₁, φ₂, ψ)$.
\end{theorem}

% \begin{sketchproof}
% If $Γ ⊢ φᵢ$ for $i=1, \cdots, n$, we prove this theorem by induction on $n$.
% Let us show one case.
% \begin{itemize}
%   \item If $n ==2$ and $(canonicalize(φ₁, ¬ φ₂) ≡ ¬ φ₂)$, we need to prove
%   $Γ ⊢ simplify(φ₁, φ₂, ψ)$.
% \begin{equation*}
%   \begin{bprooftree}
%     \AxiomC{$Γ ⊢ φ₁$}
%     \RightLabel{thm-canonicalize}
%     \UnaryInfC{$Γ ⊢ canonicalize(φ₁, ¬φ₂)$}
%     \AxiomC{$¬ φ₂ ≡ canonicalize(φ₁, ¬ φ₂)$}
%     \RightLabel{subst}
%     \BinaryInfC{$Γ ⊢ ¬ φ₂ $}
%   \end{bprooftree}
%   \begin{bprooftree}
%   \AxiomC{$Γ ⊢ ¬ φ₂ $}
%   \AxiomC{$Γ ⊢ φ₂$}
%   \RightLabel{¬-elim}
%   \BinaryInfC{$Γ ⊢ ⊥$}
%   \RightLabel{axiom}
%   \UnaryInfC{$Γ ⊢ simplify(φ₁, φ₂, ψ)$}
%   \end{bprooftree}
% \end{equation*}

% \end{itemize}
% \end{sketchproof}

% subsubsection simplify (end)
% -------------------------------------------------------------------

\end{document}
