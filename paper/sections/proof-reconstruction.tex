
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Proof-Reconstruction}
\label{sec:proof-reconstruction}

\subsection{Workflow}
\label{ssec:workflow}

\input{sections/diagram.tex}

The proof-reconstruction approach proposed here consists of a series
of steps similar to the workflow presented by \citeauthor{sultana2015} in
\cite{sultana2015}. This process is a translation from a source
system to a target system. In our case, the system of origin, the
automatic theorem prover, is \Metis; the target system is a proof
assistant, \Agda. We choose \Agda, but another proof assistant with the same support of type theory and inductive types is valid (see a description of \Agda for its main features in
Section~\ref{sec:implementation}).
The overview of the proof-reconstruction is presented in
Fig.~\ref{fig:proof-reconstruction-workflow}, the process begin with
a \TPTP file that encodes a problem in \CPL. We use this file as the
input of the \Metis prover and if the problem is a theorem, \Metis can reply with a derivation in \TSTP format of the proof.

With the \TSTP  derivation from the Step~2, we process the derivation with the \Athena translator tool~\cite{Athena}.
\Athena parses the \TSTP format, analyzes the
derivation and generates a representation of the natural deduction
proof using a tree data structure (see the properties
of this tree in Section~\ref{sssec:metis-proofs}).
We perform an analysis of the proof-tree to remove some
unnecessary steps that introduce redundancies or unused input for
\Athena.

As a result of using \Athena, we get an \Agda file, the proof-term. To generate this file, \Athena has used names of functions and theorems from \Agda libraries:
\texttt{agda-prop}~\cite{AgdaProp}, and \texttt{agda-metis}~\cite{AgdaMetis}.


Finally, we type-check the \Agda proof-term. If type-checking
succeed, the \TSTP derivation delivered by \Metis was correct.
In that case \Agda outputs an interface file.
Otherwise, when type-checking fails, the failure must be
investigated by the user, checking for the error in \Metis, \Athena,
or in \Agda.

In the rest of this section, we provide a formal description using
type theory to build definitions and theorems for functions
necessary to emulate \Metis' inference rules. For this description,
we will write the type judgments with ``$a : A$'' to denote that $a$
has $\abbre{A}$ type. Types are written using small caps.
We use \Prop type for propositions and a the dependent type, $Γ ⊢ φ$ for theorems. In the latter type, $Γ$ has $\abbre{List}~\Prop$ type
and $φ$ has type $\Prop$. $\abbre{List}$ is the usual inductive type
for lists. Finally, we will denote by $φ ≡ ψ$, the syntactic
equivalence between propositions.

% ...................................................................

% section section_name (end)
\subsection{Structural Recursion}
\label{ssec:structural-recursion}

To emulate \Metis' inference rules in type theory,
we observed that transformations performed by some rules were given by \emph{general recursive} functions.
But algorithms based on general recursions can not be translated
directly in type theory since it is not a guarantee they terminate.
For that reason, we present in this section, a technique to avoid
such termination problems by modifying the recursive functions
to be \emph{structural recursive}.
% (see \cite{Coquand1992,Abel2002,Bove2005} for more details).

We adopt the notion of \emph{structurally smaller} from
\citeauthor{Abel2002}~\cite{Abel2002} to say, a recursive function is
structurally recursive if it calls itself with only
\emph{structurally smaller}
arguments.

General recursive calls can be translated into structurally recursive
calls by using for instance, the \emph{Bounded Recursion} technique
presented in~\cite{Bertot2004}. For a yet another method, we refer
the reader to \cite{Coquand1992,Abel2002,Bove2005}.
The former technique defines a new function based on the original
recursive function by adding an additional argument to the function.
The new argument is the \emph{bound}, a natural number given by the
function complexity. In other words, the added argument will store
the number of times the function needs to call itself to get the
expected outcome.

Henceforth, a natural number has \Nat type, and it is defined as
usual. That is, \zero and \suc are the data constructors and some
arithmetic operations are defined: ($+,\,-,\,*$). We include syntax
sugar for $\zero$, $\suc$, $\suc(\zero)$, $\cdots$, with the
classical representation: $1$, $2$, $\cdots$ as well.

Therefore, for a general recursive function $f: \Prop \to \Prop$
with termination problems, we states a new function $f^{*} : \Prop \to \Nat \to \Prop$ where all recursive calls must done by
using induction on the \Nat type structure.

\subsubsection{A practical Example.}
Let us consider the following example to exhibit the technique
mentioned above for an inner function present in the emulated version
of the \strip inference.

\begin{align}
\begin{split}
\label{eq:unshunt-definition}
&unshunt_{0}(φ) =\\
&\hspace{3mm}\begin{cases}
unshunt_{0}((φ₁ ∧ φ₂) ⇒ φ₃),
  & \text{if }φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\
unshunt_{0}(φ₁ ⇒ φ₂) ∧ unshunt_{0}(φ₁ ⇒ φ₃),
  & \text{if }φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃)\\
φ, &\text{otherwise.}
\end{cases}
\end{split}
\end{align}

From the definition above, the size of the argument, ((φ₁ ∧ φ₂) ⇒ φ₃),
is not structurally smaller than the input formula, (φ₁ ⇒ (φ₂ ⇒ φ₃)),
since ((φ₁ ∧ φ₂) ⇒ φ₃) is not a subformula of (φ₁ ⇒ (φ₂ ⇒ φ₃)).

Thus, we define the function
$unshunt_{1} : \Prop \to \Nat \to \Prop$
by structural recursion in its second argument in
Eq.~(\ref{eq:unshunt-structured}).

\begin{align}
\label{eq:unshunt-structured}
\begin{split}
&unshunt_{1}(φ, \zero)\hspace{3mm}= φ\\
&unshunt_{1}(φ, \suc(n)) =\\
&\hspace{3mm}\begin{cases}
unshunt_{1}((φ₁ ∧ φ₂) ⇒ φ₃, n),
  &\text{if } φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\[2mm]
unshunt_{1}(φ₁ ⇒ φ₂, n)\\
∧\ unshunt_{1}(φ₁ ⇒ φ₃, n),
   &\text{if } φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃).
\end{cases}
\end{split}
\end{align}

As we mentioned above, the natural number in the second argument of
the function used in Eq.~(\ref{eq:unshunt-structured}) stands for a
complexity measure of the function, in this case $unshunt_{1}$ function.

Recall, the \emph{complexity measure} defined in \cite{Agudelo-Agudelo2017}
and presented in \cite{VanDalen1994} as \emph{the rank for a
proposition}, is a function $\Prop \to \Nat$ that assigns a natural
number for a proposition $φ$ like the following $rank$ function.
The symbols, $c_{¬}$ and $c_{\square}$ is a non-negative integer
number called the complexity of the connective.

\begin{equation*}
\label{eq:rank-definition}
rank(φ)=
\begin{cases}
0, &\text{for atomic }φ \\
rank(φ₁) + c_{¬},  &\text{if } φ ≡ \neg φ₁ \\
\max{(rank(φ₁),rank(φ₂))} + c_{\square},
  &\text{if } φ ≡ φ₁\,\square\, φ₂.
\end{cases}
\end{equation*}

In the case of the $unshunt_0$ function in
Eq.~(\ref{eq:unshunt-definition}), we define the complexity function
$unshunt_{cm}: \Prop → \NN$ for our $unshunt_{1}$
presented in Eq.~(\ref{eq:unshunt-rank-definition}).

\begin{align}
\begin{split}
\label{eq:unshunt-rank-definition}
&unshunt_{cm}(φ) =\\
&\hspace{3mm}
\begin{cases}
unshunt_{cm}(φ₃) + 2, &\text{if }φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\
\max(unshunt_{cm}(φ₂),unshunt_{cm}(φ₃)) + 1,
  &\text{if }  φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃)\\
0, &\text{otherwise.}
\end{cases}
\end{split}
\end{align}

Finally, following the technique mentioned, we get a curated version of
$unshunt_{0}$ function presented in Eq.~(\ref{eq:unshunt-fixed}).

\begin{definition}[unshunt]
\begin{equation}
\label{eq:unshunt-fixed}
unshunt(\varphi) := unshunt_{1}(\varphi, unshunt_{cm}(\varphi)).
\end{equation}
\end{definition}

For a more complete treatment of general recursion, and how to
define well-founded and well-structural recursive functions, we refer
the reader to Ref.~\cite{Bove2005}, where Bove and Capettra described
not only general recursion, but they also treat mutual recursive
function, among other kinds.

% % ................................................

\subsection{Emulating \Metis' Inference Rules}
\label{ssec:emulating-inferences}

\subsubsection{Strip a Goal.}
\label{sssec:strip-a-goal}

To prove a goal, \Metis splits the goal into
disjoint cases. This process produces a list of new subgoals, the
conjunction of these subgoals implies the goal. Then, a proof of the
goal becomes in smaller proofs, one refutation for each subgoal.
These subgoals are introduced in the \TSTP derivation with the \strip
inference rule as we show with the following excerpt.

\begin{verbatim}
fof(goal, conjecture, p & r & q).
fof(subgoal_0, plain, p, inference(strip, [], [goal])).
fof(subgoal_1, plain, p => r, inference(strip, [], [goal])).
fof(subgoal_2, plain, (p & r) => q, inference(strip, [], [goal])).
\end{verbatim}

To prove the correctness of the process mentioned above, we state
the Theorem~\ref{thm:thm-strip}. But first, let us prove some
lemmas for $unshunt$ function presented in Eq.~(\ref{eq:unshunt-fixed}),
and $split$ function from the definition in Eq.~(\ref{eq:split-definition}).

\begin{lemma}[lem-unshunt]
  \label{lem:unshunt}
  $Γ ⊢ unshunt(φ)$, then $Γ ⊢ φ$.
\end{lemma}

\begin{proof} Use induction on the cases defined by the outcome of the
$unshunt$ function in Eq.~(\ref{eq:unshunt-structured}).
\begin{itemize}
	\item When $n = 0$, by definition, $Γ ⊢ φ$.
	\item When $n = 1$, we apply the following theorem from~\cite{AgdaProp}
		\begin{equation*}
		\texttt{∧⇒-to-⇒⇒}\ :\  Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃ → Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃).
		\end{equation*}
  \item For $n > 1$, we will use induction on the structure of the second
			  argument.

\begin{itemize}
\item $(φ₁ ⇒ (φ₂ ⇒ φ₃))$
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n-1)$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃}
  \RightLabel{∧⇒-to-⇒⇒.}
  \UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃)}
  \end{bprooftree}
\end{equation*}

\item $(φ₁ ⇒ (φ₂ ∧ φ₃))$
\begin{equation*}
  \scalebox{0.95}{
  ($\mathcal{D}_1$)
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n) ∧ unshunt(φ₁ ⇒ φ₃, n)$}
    \RightLabel{∧-proj₁}
    \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n)$}
    \RightLabel{axiom}
    \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n-1)$}
    \RightLabel{lem-unshunt,}
    \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
  \end{bprooftree}
  }
\end{equation*}

\begin{equation*}
  (\mathcal{D}_2)
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂) ∧ unshunt(φ₁ ⇒ φ₃)$}
    \RightLabel{∧-proj₂}
    \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₃, n)$}
    \RightLabel{axiom}
    \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₃, n-1)$}
    \RightLabel{lem-unshunt.}
    \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₃$}
    \end{bprooftree}
\end{equation*}

Finally, using the theorem \texttt{⇒∧⇒-to-⇒∧} from~\cite{AgdaProp},
\begin{equation*}
  \texttt{⇒∧⇒-to-⇒∧}\ :\ Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃) → Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃),
\end{equation*}
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}_1$}
  \AxiomC{$\mathcal{D}_2$}
  \RightLabel{∧-intro}
  \BinaryInfC{$Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃)$}
  \RightLabel{\tt ⇒∧⇒-to-⇒∧.}
  \UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃)}
  \end{bprooftree}
\end{equation*}

\end{itemize}
\end{itemize}
\end{proof}

Let us now consider the $split$ function presented in
Eq.~(\ref{eq:split-definition}) that yields the conjunction of subgoals that implies the goal of the problem in the \Metis \TSTP derivations.

\begin{definition}[split]
\label{def:split}

\begin{equation}
\label{eq:split-definition}
\mysplit(φ) =
\begin{cases}
unshunt(\mysplit(φ₁)) &\text{if }φ ≡ φ₁ ∧ φ₂\\
∧\ unshunt(φ₁ ⇒ \mysplit(φ₂)), &\\[2.5mm]
unshunt(¬ φ₁ ⇒ \mysplit(φ₂)),
  & \text{if }φ ≡ φ₁ ∨ φ₂\\[2.5mm]
unshunt(φ₁ ⇒ \mysplit(φ₂)),
  & \text{if }φ ≡ φ₁ ⇒ φ₂\\[2.5mm]
unshunt(φ₁ ⇒ \mysplit(φ₂))
  & \text{if }φ ≡ φ₁ ⇔ φ₂\\
∧\ unshunt(φ₂ ⇒ \mysplit(φ₁)),
  &\\[2.5mm]
unshunt(φ₁ ⇒ \mysplit(¬ φ₂)),
  & \text{if }φ ≡ ¬ (φ₁ ∧ φ₂)\\[2.5mm]
unshunt(\mysplit(¬ φ₁))
  & \text{if }φ ≡ ¬ (φ₁ ∨ φ₂)\\
∧\ unshunt(¬ φ₁ ⇒ \mysplit(¬ φ₂)),
  &\\[2.5mm]
unshunt(\mysplit(φ₁))
  & \text{if }φ ≡ ¬ (φ₁ ⇒ φ₂)\\
∧\ unshunt(φ₁ ⇒ \mysplit(¬ φ₂)),
  &\\[2.5mm]
unshunt(φ₁ ⇒ \mysplit(¬ φ₂))
  & \text{if }φ ≡ ¬ (φ₁ ⇔ φ₂)\\
∧\ unshunt(¬ φ₂ ⇒ \mysplit(φ₁)),
  &\\[2.5mm]
unshunt(\mysplit(φ₁)),
  & \text{if }φ ≡ ¬ ¬ φ₁\\
⊤,
  & \text{if }φ ≡ ¬ ⊥\\
⊥,
  & \text{if }φ ≡ ¬ ⊤.
\end{cases}
\end{equation}
\end{definition}

The definition above suffers termination problems since it is not
a structural recursion. Therefore, we have reformulated the equation above to solve such a issue following the technique
described in Section~\ref{ssec:structural-recursion}.
Here and below, we refer to $split$ as the function after applying
the process mentioned above.

\begin{lemma}[\thmsplit] $Γ ⊢ \mysplit(φ)$ then $Γ ⊢ φ$.
\label{lem:lem-split}
\end{lemma}

\begin{proof} We now proceed by induction on the structure of the
formula $φ$ in the definition of Eq.~(\ref{eq:split-definition}).
For a complete proof, we refer the reader to~\cite{AgdaMetis}.\\[3mm]

\begin{itemize}
\item $(φ ≡ φ₁ ∧ φ₂)$. We get a proof for each conjunct and using the introduction rule for conjunction connective, the result follows.

\begin{equation*}
(\mathcal{D})\hspace{3mm}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ \mysplit(φ,n)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁) ∧ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{∧-proj₁}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁)$}
  \RightLabel{lem-unshunt.}
  \UnaryInfC{$Γ ⊢ φ₁$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}$}
  \UnaryInfC{Γ ⊢ φ₁}
  \AxiomC{$Γ ⊢ \mysplit(φ,n)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁) ∧ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{$∧$-proj$₂$}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{$⇒$-elim}
  \BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
  \RightLabel{\thmsplit.}
  \UnaryInfC{$Γ ⊢ φ₂$}
  \end{bprooftree}
\end{equation*}

\item $(φ ≡ φ₁ ⇒ φ₂)$
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{}
  \RightLabel{assume φ₁}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁$}
  \AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{weaken φ₁}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{⇒-elim}
  \BinaryInfC{$Γ , φ₁ ⊢ \mysplit(φ₂,n-1)$}
  \RightLabel{\thmsplit}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₂$}
  \RightLabel{⇒-intro.}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
  \end{bprooftree}
\end{equation*}

\item $(φ ≡ ¬ (φ₁ ∨ φ₂))$. We show that $Γ ⊢ ¬ φ₁$ and $Γ ⊢ ¬ φ₂$.
The result follows by introducing the conjunction and applying after
De Morgan Law.

\begin{equation*}
(\mathcal{D})\hspace{3mm}
\begin{bprooftree}
\AxiomC{$Γ ⊢ \mysplit(φ, n)$}
\RightLabel{axiom}
\UnaryInfC{$Γ ⊢ unshunt(¬ φ₁) ∧ unshunt(¬ φ₁ ⇒ \mysplit(φ₂, n))$}
\RightLabel{∧-proj₁}
\UnaryInfC{$Γ ⊢ unshunt(¬ φ₁)$}
\RightLabel{lem-unshunt,}
\UnaryInfC{$Γ ⊢ ¬ φ₁$}
\end{bprooftree}
\end{equation*}
\end{itemize}
\end{proof}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}$}
  \UnaryInfC{$Γ ⊢ ¬ φ₁$}

  \AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(¬ φ₁) ∧ unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{∧-proj₂}
  \UnaryInfC{$Γ ⊢ unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢ ¬ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{⇒-elim}
  \BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
  \RightLabel{\thmsplit.}
  \UnaryInfC{$Γ ⊢ ¬ φ₂$}
  \end{bprooftree}
\end{equation*}

\begin{lemma}[subst]
  \label{lem:subst}
  Substitution theorem.
\begin{equation}
  \label{eq:substitution-theorem}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ φ$}   \AxiomC{$ψ ≡ φ$}
  \RightLabel{subst.}
  \BinaryInfC{$Γ ⊢ ψ$}
  \end{bprooftree}
\end{equation}
\end{lemma}

\begin{theorem}[thm-strip]
\label{thm:thm-strip}
 If $s_i$ are the subgoals of the goal $φ$, and
 $\{ Γ ⊢ s_i \}_{i}$, then $Γ ⊢ φ$.
\end{theorem}

\begin{proof}
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\left\{ Γ ⊢ s_i \right\}_{i}$}
  \RightLabel{∧-intro}
  \UnaryInfC{$Γ ⊢ \bigwedge_i s_i$}

  \AxiomC{$\mysplit(φ) ≡ \bigwedge_i s_i $}
  \RightLabel{subst}
  \BinaryInfC{$Γ ⊢ \mysplit(φ)$}
  \RightLabel{\thmsplit.}
  \UnaryInfC{$Γ ⊢ φ$}
\end{bprooftree}
\end{equation*}
\end{proof}

% -------------------------------------------------------------------

\subsubsection{Negate.}

Each proof of a subgoal is a refutation, thereby each proof assumes
the negation of its subgoal. The \negate rule
assumes the negation of such subgoals. This rules always
appears after apply the \strip inference to the goal.

\begin{verbatim}
fof(goal, conjecture, (p & q)).
fof(subgoal_0, plain, (p), inference(strip, [], [goal])).
fof(subgoal_1, plain, (p => q), inference(strip, [], [goal])).
fof(negate_0_0, plain, (~ p), inference(negate, [], [subgoal_0])).
\end{verbatim}

Then, to emulate this rule, we just introduce the negation
of the subgoal by using the assume rule from the inferences in
Fig.~\ref{fig:CPL-inference-rules}.

% -------------------------------------------------------------------
\subsubsection{Splitting a Conjunct.}
\label{sssec:splitting-a-conjunct}

The \conjunct rule extracts from a
conjunction one of its conjuncts; it is a generalization of the
projection rules for the conjunction connective as the
following \TSTP excerpt shows.

\begin{verbatim}
fof(normalize_1, plain, p & q & (r | ~ p),
  inference(canonicalize, [], [x])).
fof(normalize_2, plain, q,
  inference(conjunct, [], [normalize_1])).
fof(normalize_2, plain, (r | ~ p),
  inference(conjunct, [], [normalize_1])).
\end{verbatim}

\begin{definition}[conjunct]
\begin{align}
  \begin{split}
  &conjunct : \Prop \to \Prop \to \Prop\\
  &conjunct(φ, ψ) =\\
  &\hspace{3mm}
  \begin{cases}
      ψ, &\text{if }φ ≡ ψ\\
      ψ, &\text{if }φ ≡ φ₁ ∧ φ₁\text{ and }ψ ≡ conjunct(φ₁, ψ)\\
      ψ, &\text{if }φ ≡ φ₁ ∧ φ₁\text{ and }ψ ≡ conjunct(φ₂, ψ)\\
      φ, &\text{otherwise.}
    \end{cases}
  \end{split}
\end{align}
\end{definition}

\begin{theorem}[thm-conjunct]
  \label{thm:thm-conjunct}
  $Γ ⊢ φ$, and $ψ  : \Prop$ , then $Γ ⊢ conjunct(φ, ψ)$.
\end{theorem}
~\begin{proof}\hspace{2cm}\\
\begin{itemize}
  \item For the case, $φ ≡ ψ$, $Γ ⊢ conjunct(φ, ψ)$ normalizes to $Γ ⊢ ψ$.
Then, we get the desire conclusion by applying the $subst$ theorem.
  \item If the proposition $φ$ is a conjunction, and we can get $ψ ≡ conjunct(φ_{i}, ψ)$ for some $i = 1,\ 2$, then,

\begin{equation}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ φ₁ ∧ φ₂$}
  \RightLabel{∧-proj$_{i}$}
  \UnaryInfC{$Γ ⊢ φ_{i}$}
  \UnaryInfC{$Γ ⊢ conjunct(φ_{i}, ψ)$}
  \AxiomC{$ψ ≡ conjunct(φ_{i}, ψ)$}
  \RightLabel{subst.}
  \BinaryInfC{$Γ ⊢ ψ$}
  \end{bprooftree}
\end{equation}
\item The last case follows trivially by using the same hypothesis.
\end{itemize}
\end{proof}

% subsubsection splitting-a-conjunct (end)
% -------------------------------------------------------------------

% ------------------------------------------------------------------------

\subsubsection{Reordering.}
Logic equivalence between propositions is a major issue to justify
prover reasoning steps. Since we left out semantics to treat only the
syntax aspects of the propositions, our approach shows that equivalence
by converting propositions to their conjunctive normal forms and showing equivalence by reordering the conjunctions and the inner disjunctions.
In this section, we provide some theorems to perform such reordering tasks, the goals are the following.

\begin{itemize}
  \item Reorder the disjunction $φ = φ₁ ∨ φ₂ ∨ \cdots φₙ$ to match with $ψ = ψ₁ ∨ ψ₂ ∨ \cdots ∨ ψₙ$, when for all $i = 1, \cdots, n$, exists at least one $ψⱼ$ such that $φᵢ ≡ ψⱼ$ for $j = 1, \cdots, n$.
  \item Reorder a CNF formula, $φ = φ₁ ∧ φ₂ ∧ \cdots$, to match with another CNF formula $ψ = ψ₁ ∧ ψ₂ ∧ \cdots$ when for all $i = 1, \cdots, n$, exists at least one $ψⱼ$ such that $φᵢ ≡ ψⱼ$ for $j = 1, \cdots, n$.
\end{itemize}

First, we define the $rdisj$ function in Eq.~(\ref{eq:rdisj-def}) to convert a disjunction in its right-associative form.
\begin{definition}[rdisj]
\begin{align}
  \begin{split}
    \label{eq:rdisj-def}
    &rdisj(φ) : \Prop \to \Prop\\
    &rdisj(φ) =
    \begin{cases}
    rdisj(φ₁ ∨ (φ₂ ∨ φ₃)),  & \text{if } φ ≡ (φ₁ ∨ φ₂) ∨ φ₃\\
    φ₁ ∨ rdisj(φ₂),         & \text{if } φ ≡ φ₁ ∨ φ₂\\
    φ,                      & \text{otherwise.}
    \end{cases}
  \end{split}
\end{align}
\end{definition}

\begin{lemma}[lem-rdisj]
\label{lem:lem-rdisj}
  $Γ ⊢ φ$ then $Γ ⊢ rdisj(φ)$.
\end{lemma}
Following a similar way to define $rdisj$, we define the $rconj$ function,
to convert a conjunction into its right-associative form.

The $build_{∨}$ function in Eq.~(\ref{eq:build-or}) function intends to construct a disjunction from another disjunction, specifically, it rearranges the disjuncts in the source formula to match with the target disjunction formula as we described above.

\begin{definition}[build$_{∨}$]
\begin{equation}
  \begin{split}
  \label{eq:build-or}
  &build_{∨} : \Prop → \Prop → \Prop\\
  &build_{∨}(φ, ψ) =\\
  &\hspace{3mm}
  \begin{cases}
  ψ, &\text{if } φ ≡ ψ\\
  ψ, &\text{if } ψ ≡ ψ₁ ∨ ψ₂\text{ and } build_{∨}(φ, ψ_{i}) ≡ ψ_{i}\text{ for some }i=1, 2\\
  φ, &\text{otherwise.}
  \end{cases}
  \end{split}
\end{equation}
\end{definition}

\begin{lemma}[lem-build$_{∨}$]
\label{lem:lem-build-or}
$Γ ⊢ φ$, and $ψ : \Prop$ then $Γ ⊢ build_{∨}(φ)$.
\end{lemma}

From now, we assume all propositions are right-associative unless otherwise stated. The $factor$ function in
Eq.~(\ref{eq:factor-definition}) intends to simplify a special case of disjunction, the repeated disjuncts (e.g., $factor(φ ∨ φ) \mapsto\ φ$).
Notice that other cases like $φ ∨ (ψ ∨ φ)$ do no reduce to $(ψ ∨ φ)$.

\begin{definition}[factor]
\begin{align}
\begin{split}
  \label{eq:factor-definition}
  &factor : \Prop → \Prop\\
  &factor(φ) =
  \begin{cases}
    φ₁,  &\text{if }φ ≡ φ₁ ∨ φ₂ \text{ and } φ₁ ≡ factor(φ₂)\\
    φ,   &\text{otherwise.}
  \end{cases}
\end{split}
\end{align}
\end{definition}

\begin{lemma}[lem-factor]
\label{lem:lem-factor}
  $Γ ⊢ φ$ then $Γ ⊢ factor(φ)$.
\end{lemma}

To construct a disjunction $ψ$ from another disjunction $φ$, we have used ideas from the description in \citeauthor{bohme2010}~\cite{bohme2010} to prove equality between nested disjunctions. The result is the
$sbuild_{∨}$ function that uses every disjunct from the source formula, $φ$, to build up the target disjunction $ψ$.

\begin{definition}[sbuild$_{∨}$]
\begin{align}
  \begin{split}
  \label{eq:strong-build-or-definition}
    &sbuild_{∨} : \Prop → \Prop → \Prop\\
    &sbuild_{∨}(φ, ψ) =\\
    &\hspace{3mm}
    \begin{cases}
      factor(build_{∨}(φ₁, ψ) ∨ build_{∨}(φ₂,ψ)),  &\text{if }φ≡ φ₁ ∨ φ₂\\
      build_{∨}(φ, ψ),  & \text{otherwise.}
    \end{cases}
  \end{split}
\end{align}
\end{definition}

\begin{lemma}[lem-sbuild$_{∨}$]
\label{lem:lem-sbuild-or}
$Γ ⊢ φ$, and $ψ \in\Prop$ then $Γ ⊢ sbuild_{∨}(φ, ψ)$.
\end{lemma}

\begin{example}
Let see the main idea behind the lem-sbuild$_{∨}$ lemma.
We will build the disjunction $((p ∨ q) ∨ r)$ from the disjunction
$(r ∨ (q ∨ p))$.
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ q$}
  \RightLabel{∨-intro₂}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \AxiomC{$Γ ⊢ p$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \RightLabel{∨-elim}
  \BinaryInfC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ r$}
  \RightLabel{∨-intro₂}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \AxiomC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}

  \RightLabel{∨-elim}
  \BinaryInfC{$Γ, r ∨ (q ∨ p) ⊢ (p ∨ q) ∨ r$}

  \RightLabel{⇒-intro}
  \UnaryInfC{$Γ ⊢ r ∨ (q ∨ p) ⇒ (p ∨ q) ∨ r$}

  \end{bprooftree}
\end{equation*}
\end{example}

Notice that using $sbuild_{∨}$ we can build not only a disjunction with the same disjuncts of the source formula but also a complete different formula by adding new disjuncts to the source formula.

\begin{definition}[reorder$_{∨}$]
\begin{align*}
    \label{eq:reorder-or}
    \begin{split}
    &reorder_{∨} : \Prop \to \Prop \to \Prop\\
    &reorder_{∨} (φ, ψ) = sbuild_{∨}(rdisj(φ), ψ).
    \end{split}
  \end{align*}
\end{definition}

\begin{theorem}[thm-reorder$_{∨}$]
  \label{thm-reorder-or}
  $Γ ⊢ φ$, and $ψ\in\Prop$ then $Γ ⊢ reorder_{∨}(φ, ψ)$.
\end{theorem}

\begin{proof}
Use Lemma~\ref{lem:lem-rdisj} and Lemma~\ref{lem:lem-sbuild-or}.
\end{proof}

We define similar functions and state some theorems as we previously did for disjunctions, but instead, we treat conjunctive normal forms.

\begin{definition}[reorder$_{∧}$]
  \begin{align*}
      \begin{split}
        &reorder : \Prop → \Prop \to Prop\\
        &reorder_{∧}(φ, ψ) =
        \begin{cases}
          φ, &\text{if }φ ≡ ψ\\
          ψ₁ ∧ ψ₂, &\text{if } ψ ≡ ψ₁ ∧ ψ₂\text{, }reorder_{∧}(φ, ψ₁) ≡ ψ₁\\
                  &\text{and }reorder_{∧}(φ, ψ₂)≡ ψ₂\\
          φ,       &\text{if } ψ ≡ ψ₁ ∧ ψ₂\\
          conjunct(φ, ψ), &\text{otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-reorder$_{∧}$]
  \label{lem:lem-reorder-and}
  $Γ ⊢ φ$, and $ψ \in\Prop$ then $Γ ⊢ reorder(φ, ψ)$.
\end{lemma}

\begin{definition}[conjunct$_{∨}$]
  \label{eq:conjunct-or-definition}
\begin{align*}
  \begin{split}
    &conjunct_{∨} : \Prop → \Prop \to Prop\\
    &conjunct_{∨}(φ, ψ) =
    \begin{cases}
      ψ, &\text{if }φ ≡ ψ\\
      ψ, &\text{if }reorder_{∨}(φ, ψ) ≡ ψ\\
      ψ, &\text{if }ψ ≡ ψ₁ ∧ ψ₂, conjunct_{∨}(φ, ψ₁) ≡ ψ₁\\
        &\text{and } reorder_{∨}(φ, ψ₂) ≡ ψ₂\\
      ψ, &\text{if }φ ≡ φ₁ ∧ φ₂, conjunct_{∨}(φ₁, ψ) ≡ ψ\\
      ψ, &\text{if }φ ≡ φ₁ ∧ φ₂, conjunct_{∨}(φ₂, ψ) ≡ ψ\\
      φ, &\text{otherwise.}
    \end{cases}
  \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-conjunct$_{∨}$]
  \label{lem:lem-conjunct-or}
  $Γ ⊢ φ$, and $ψ \in\Prop$ then $Γ ⊢ conjunct_{∨}(φ, ψ)$.
\end{lemma}

\begin{definition}[reorder$_{∧∨}$]
 \begin{align*}
      \begin{split}
      &reorder : \Prop \to \Prop \to \Prop\\
      &reorder_{∧∨}(φ, ψ)=
        \begin{cases}
          ψ, &\text{if } φ≡ψ\\
          ψ, &\text{if } ψ ≡ ψ₁ ∧ ψ₂, reorder_{∧∨}(φ,ψ₁) ≡ ψ₁\\
             &\text{and }reorder_{∧∨}(φ, ψ₂) ≡ ψ₂\\
          φ, &\text{if }ψ ≡ ψ₁ ∧ ψ₂\\
          conjunct_{∨}(φ, ψ) &\text{otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
  \end{definition}

\begin{theorem}[thm-reorder$_{∧∨}$]
  \label{thm:thm-reorder-and-or}
  $Γ ⊢ φ$, and $ψ \in\Prop$ then $Γ ⊢ reorder_{∧∨}(φ, ψ)$.
\end{theorem}

% % --------------------------------------------------------------------

\subsubsection{Resolution.}
\label{sssec:resolve}

The \resolve rule incorporates the resolution theorem showed in
Fig.~\ref{fig:metis-inferences} for the \TSTP derivations.
This rule posses three arguments: a positive literal $l$ to apply the resolution theorem, and two derivations,
$\mathcal{D}₁$ and $\mathcal{D}₂$.
The positive literal $l$ must occur in
the formula from the first derivation $\mathcal{D}₁$, and the
negative literal must occur in the formula from the second derivation $\mathcal{D}₂$ (see the pattern in the \emph{resolve} rule).
The following excerpt is an \Metis \TSTP example for the \resolve rule.

\begin{verbatim}
cnf(refute_0_0, plain, p | q,
  inference(canonicalize, [], [normalize_0_0])).
cnf(refute_0_1, plain, ~ p,
  inference(canonicalize, [], [normalize_0_4])).
cnf(refute_0_2, plain, q,
  inference(resolve, [$cnf(p)], [refute_0_0, refute_0_1])).
\end{verbatim}

To emulate this rule, we perform rearrangements inside the formulas
involved to match with the pattern expected by the resolution theorem
described above.

\begin{definition}[rsol]
\begin{align*}
      \begin{split}
        &rsol : \Prop \to \Prop\\
        &rsol(φ) =
        \begin{cases}
          φ₂, &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (φ₃ ∨ φ₄), φ₃ ≡ ¬ φ₁, φ₂ ≡ φ₄\\
          φ₂ ∨ φ₄, &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (φ₃ ∨ φ₄), φ₃ ≡ ¬ φ₁\\
          φ, &\text{otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-rsol]
  \label{lem:lem-rsol}
  $Γ ⊢ φ$ then $Γ ⊢ rsol(φ)$.
\end{lemma}

\begin{definition}[resolve]
 \begin{equation*}
    resolve(φ₁, φ₂, l, ψ) =
      rsol(reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨} (φ₂, ¬ l ∨ ψ)).
  \end{equation*}
\end{definition}

\begin{theorem}[thm-resolve]
  \label{thm:thm-resolve}
  $Γ ⊢ φ₁$, $Γ ⊢ φ₂$, a literal $l$, and $ψ\in\Prop$ then $Γ ⊢ resolve(φ₁, φ₂, l, ψ)$.
\end{theorem}

\begin{proof}
\hspace{3mm}\\
\begin{itemize}
 \item
 \begin{equation*}
    \begin{bprooftree}
      \AxiomC{$Γ ⊢ φ₁$}
      \RightLabel{thm-reorder$_{∨}$.}
      \UnaryInfC{$Γ ⊢ reorder_{∨}(φ₁, l ∨ ψ)$}
   \end{bprooftree}
  \end{equation*}
\item
 \begin{equation*}
    \begin{bprooftree}
      \AxiomC{$Γ ⊢ φ₂$}
      \RightLabel{thm-reorder$_{∨}$.}
      \UnaryInfC{$Γ ⊢ reorder_{∨}(φ₂, ¬ l ∨ ψ)$}
   \end{bprooftree}
  \end{equation*}
  \item
  \begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ reorder_{∨}(φ₁, l ∨ ψ)$}
    \AxiomC{$Γ ⊢ reorder_{∨}(φ₂, ¬ l ∨ ψ)$}
    \RightLabel{∧-intro}
    \BinaryInfC{$Γ ⊢ reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨}(φ₂, ¬ l ∨ ψ)$}
    \RightLabel{lem-rsol.}
    \UnaryInfC{$Γ ⊢ rsol(reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨}(φ₂, ¬ l ∨ ψ))$}
  \end{bprooftree}
  \end{equation*}
\end{itemize}
\end{proof}

% subsubsection resolve (end)
% --------------------------------------------------------------------


% % --------------------------------------------------------------------

\subsubsection{Normalization.}
\label{sssec:normal_forms}
\change{Here lacks of an introduction!}
A negative normal form for the formula φ is one in which negations
appear only in the literals and the expression is in terms only of
the boolean operators (¬, ∧, ∨).

% To transform a formula φ to its equivalent \abbre{NNF} form, we
% apply recursively the following equations. The function type for
% \name{nnf} is $\Prop \to \Prop$.

% \begin{lemma}[lem-nnf]
%   \label{lem:lem-nnf}
%   $Γ ⊢ φ$ then $Γ ⊢ nnf(φ)$, where,
%   \begin{align*}
%     \begin{split}
%     \label{eq:nnf-definition}
%     nnf(φ) =
%       \begin{cases}
%       nnf(φ₁) ∧ nnf(φ₂),
%          &\text{if }φ ≡ φ₁ ∧ φ₂ \\
%       nnf(φ₁) ∨ nnf(φ₂),
%          &\text{if }φ ≡ φ₁ ∨ φ₂ \\
%       nnf(¬ φ₁ ∨ φ₂),
%          &\text{if }φ ≡ φ₁ ⇒ φ₂ \\
%       nnf(φ₁ ⇒ φ₂ ∧ φ₂ ⇒ φ₁),
%          &\text{if }φ ≡ φ₁ ⇔ φ₂ \\
%       nnf(¬ φ₁ ∨ ¬ φ₂),
%          &\text{if }φ ≡ ¬ (φ₁ ∧ φ₂) \\
%       nnf(¬ φ₁ ∧ ¬ φ₂),
%          &\text{if }φ ≡ ¬ (φ₁ ∨ φ₂) \\
%       nnf(φ₁),
%          &\text{if }φ ≡ ¬ ¬ φ₁ \\
%       nnf(¬ (φ₂ ∨ ¬ φ₁)),
%          &\text{if }φ ≡ ¬ (φ₁ ⇒ φ₂) \\
%       nnf(¬ (φ₁ ⇒ φ₂ ∧ φ₂ ⇒ φ₁)),
%          &\text{if }φ ≡ ¬ (φ₁ ⇔ φ₂) \\
%       ⊥,  &\text{if }φ ≡ ¬ ⊤ \\
%       ⊤,  &\text{if }φ ≡ ¬ ⊥ \\
%       φ,  & \text{otherwise}.
%       \end{cases}
%     \end{split}
%   \end{align*}
% \end{lemma}

% \begin{lemma}[lem-dist$_{∨}$]
%   \label{lem:lem-dist-or}
%   $Γ ⊢ φ$ then $Γ ⊢ dist_{∨}(φ)$, where,
%   \begin{align*}
%       \begin{split}
%       dist_{∨}(φ) =
%         \begin{cases}
%           dist_{∨}(φ₁ ∨ φ₂) ∧ dist_{∨}(φ₂ ∨ φ₃),
%             &\text{if }φ ≡ (φ₁ ∧ φ₂) ∨ φ₃\\
%           dist_{∨}(φ₁ ∨ φ₃) ∧ dist_{∨}(φ₁ ∨ φ₃),
%             &\text{if }φ ≡ φ₁ ∨ (φ₂ ∧ φ₃)\\
%           φ, &\text{otherwise.}
%         \end{cases}
%       \end{split}
%   \end{align*}
% \end{lemma}

% \begin{lemma}[lem-dist]
%   \label{lem:lem-dist}
%   $Γ ⊢ φ$ then $Γ ⊢ dist(φ)$, where,
%   \begin{align*}
%       \begin{split}
%       dist(φ) =
%         \begin{cases}
%           dist(φ₁) ∧ dist(φ₂),
%             &\text{if }φ ≡ φ₁ ∧ φ₂\\
%           dist_{∨}(dist(φ₁) ∨ dist(φ₂)),
%             &\text{if }φ ≡ φ₁ ∨ φ₂\\
%           φ, &\text{otherwise.}
%         \end{cases}
%       \end{split}
%   \end{align*}
% \end{lemma}

% \begin{sketchproof}
% Case when $φ ≡ φ₁ ∨ φ₂$.\\
% For $i = 1, 2$,
% \begin{equation}
%   \begin{bprooftree}
%     \RightLabel{assume}
%     \AxiomC{$Γ, φ_{i} ⊢ φ_{i}$}
%     \RightLabel{lem-dist}
%     \UnaryInfC{$Γ ⊢ dist(φ_{i})$}
%     \RightLabel{∨-intro$_{1,2}$}
%     \UnaryInfC{$Γ, φ_{i} ⊢ dist(φ₁) ∨ dist(φ₂)$}
%     \RightLabel{lem-dist$_{∨}$}
%     \UnaryInfC{$Γ, φ_{i} ⊢ dist_{∨}(dist(φ₁) ∨ dist(φ₂))$.}
%     \end{bprooftree}
% \end{equation}
% Then, by using the ∨-elim rule, from the last derivation above we derive
% $Γ, φ₁ ∨ φ₂ ⊢ dist_{∨}(dist(φ₁) ∨ dist(φ₂))$, and the lemma follows.
% \end{sketchproof}

% \begin{theorem}[thm-cnf]
% \label{thm:thm-cnf}
%   $Γ ⊢ φ$ then $Γ ⊢ cnf(φ)$, where,
%   \begin{equation}
%     cnf(φ) = (dist \circ nnf) (\varphi).
%   \end{equation}
% \end{theorem}

% \begin{proof}
%   Composition of the Lemma \ref{lem:lem-dist} and Lemma \ref{lem:lem-nnf}.
% \end{proof}
% % subsubsection normal_forms (end)
% % --------------------------------------------------------------------

% % --------------------------------------------------------------------

% \subsubsection{Clausification.}
% \label{sssec:clausification}

% \begin{theorem}[thm-clausify]
% \label{thm:thm-clausify}
%   $Γ ⊢ φ$ and $ψ \in\Prop$ then $Γ ⊢ clausify(φ, ψ)$, where,
%   \begin{align}
%       clausify(φ,ψ) =
%       \begin{cases}
%         ψ, &\text{ if }φ≡ψ\\
%         reorder_{∧∨}(cnf(φ), ψ), &\text{otherwise.}
%       \end{cases}
%   \end{align}
% \end{theorem}

% \begin{proof} When $φ ≡ ψ$, we use the $subs$ theorem Eq.~(\ref{eq:substitution-theorem}). Otherwise, we use Theorem \ref{thm:thm-reorder-and-or} and Theorem \ref{thm:thm-cnf}.
% \end{proof}

% % subsubsection clausification (end)
% % --------------------------------------------------------------------

% % --------------------------------------------------------------------
% \subsubsection{Normalization.}
% \label{sssec:normalization}

% In a disjunction, $φ = φ₁ ∨ φ₂ ∨ \cdots ∨ φₙ$, we say $ψ ∈_{∨} φ$,
% if there is some $i = 1, \cdots, n$ such that $ψ = φᵢ$.
% Then, we define the $rm_{∨}$ function to remove in a right-associative disjunction φ, those propositions ψ repeated in the formula.

% \begin{equation*}
% \label{eq:rm-or}
%   rm_{∨}(φ) =
%   \begin{cases}
%     rm_{∨}(φ₂), &\text{if }φ ≡ φ₁ ∨ φ₂, φ₁ ∈_{∨} φ₂\\
%     φ₁ ∨ rm_{∨}(φ₂), &\text{if }φ ≡ φ₁ ∨ φ₂\\
%     φ,  &\text{otherwise.}
%   \end{cases}
% \end{equation*}

% Since, our goal consists of normalizing prepositions in \abbre{CNF}, we also need to generalize $rm_{∨}$ to work with conjunctions. We define $rm_{∧∨}$ function for that purpose.

% \begin{equation*}
% \label{eq:rm-and-or}
%   rm_{∧∨}(φ) =
%   \begin{cases}
%     rm_{∧∨}(φ₁) ∧ rm_{∧∨}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂\\
%     rm_{∨}(rdisj(φ)),  &\text{otherwise.}
%   \end{cases}
% \end{equation*}

% Now, we have removed redundancies in the disjunctions, we move forward and we remove redundancies at the level of the conjunction of the CNFs by applying the $rm_{∧}$ function. We define $ψ ∈_{∧} φ$ similar as we described above for disjunction. In a conjunction, $φ = φ₁ ∧ φ₂ ∧ \cdots ∧ φₙ$, we say
% $ψ ∈_{∧} φ$, if there is some $i = 1, \cdots, n$ such that $ψ = φᵢ$.

% \begin{equation*}
% \label{eq:rm-and}
%   rm_{∧}(φ) =
%   \begin{cases}
%     rm_{∧}(φ₁) ∧ rm_{∧}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂, φ₁ ∈_{∧} φ₂\\
%     φ₁ ∧ rm_{∧}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂\\
%     φ,  &\text{otherwise.}
%   \end{cases}
% \end{equation*}

% Finally, we remove redundancies in a proposition assuming that it is given in conjunctive normal form and right-associative, by composing the functions described above in the Eq.~(\ref{eq:redun-ast})
% for the function $redun^{*}$.

% \begin{equation*}
%   \label{eq:redun-ast}
%   redun^{*} = rm_{∧} ∘ rm_{∧∨}.
% \end{equation*}

% Then, performing rearrangements to match with the expected output
% by $redon^{*}$ function.

% \begin{equation*}
%   \label{eq:redun}
%   redun(φ) = reorder_{∧∨}(φ, redun^{*}(φ)).
% \end{equation*}

% \begin{theorem}[thm-redun]
%   \label{thm:thm_redun}
%   $Γ ⊢ φ$ then $Γ ⊢ redun(φ)$.
% \end{theorem}

% \begin{proof}
% Use in Theorem~\ref{thm:thm-reorder-and-or} with $ψ$ equals to
% $redun^{*}(φ)$.
% \end{proof}

% \improvement{We need here a text, or a comment about what
% is going next.}

% % subsection normalization (end)
% % --------------------------------------------------------------------
% \begin{lemma}[lem-rmPEM$_{∨}$]
%   \label{lem:lem-rmPEM-or}
%   \begin{align*}
%   \label{eq:rmPEM-or}
%     \begin{split}
%     rmPEM_{∨}(φ) =
%       \begin{cases}
%         ⊤, &\text{if }φ ≡ ¬ φ₁ ∨ φ₂,\ φ₁ ∈_{∨} φ₂\\
%         ⊤, &\text{if}φ ≡ ¬ φ₁ ∨ φ₂,\ rmPEM_{∨}(φ₂) ≡ ⊤\\
%         ¬ φ₁ ∨ rmPEM_{∨}(φ₂), &\text{if }φ ≡ ¬ φ₁ ∨ φ₂\\
%         ⊤, &\text{if }φ ≡ φ₁ ∨ φ₂,\ ¬φ₁ ∈_{∨} φ₂ \\
%         ⊤, &\text{if }φ ≡ φ₁ ∨ φ₂,\ rmPEM_{∨}(φ₂) ≡ ⊤\\
%         φ₁ ∨ rmPEM_{∨}(φ₂), &\text{if }φ ≡ φ₁ ∨ φ₂\\
%         φ, &\text{otherwise.}
%       \end{cases}
%     \end{split}
%   \end{align*}
% \end{lemma}

% \begin{lemma}[lem-rmPEM$_{∧∨}$]
%   \label{lem:lem-rmPEM-and-or}
%   \begin{equation*}
%     \label{eq:rmPEM-and-or}
%     rmPEM_{∧∨}(φ) =
%     \begin{cases}
%       rmPEM_{∨}(φ₁) ∧ rmPEM_{∨∧}(φ₂), &\text{ if }φ ≡ φ₁ ∧ φ₂\\
%       rmPEM_{∨}(φ), &\text{otherwise.}
%     \end{cases}
%   \end{equation*}
% \end{lemma}

% \begin{lemma}[lem-rmBot$_{∧}$]
%   \label{lem:lem-rmbot-and}
%    $Γ ⊢ φ$ then $Γ ⊢ rmBot_{∧}(φ)$, where,
%   \begin{equation*}
%     \label{eq:rmBot-and}
%     rmBot_{∧}(φ) =
%     \begin{cases}
%       ⊥, &\text{ if }φ ≡ ¬ φ₁ ∧ φ₂,\ φ₁ ∈_{∧} φ₂\\
%       ⊥, &\text{ if }φ ≡ ¬ φ₁ ∧ φ₂,\ rmBot_{∧}(φ₂) ≡ ⊥\\
%       ¬ φ₁ ∧ rmBot_{∧}(φ₂), &\text{if }φ ≡ ¬ φ₁ ∧ φ₂\\
%       ⊥, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ φ₁ ∈_{∧} φ₂\\
%       ⊥, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ rmBot_{∧}(φ₂) ≡ ⊥\\
%       φ₁ ∧ rmBot_{∧}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂\\
%       φ, &\text{otherwise.}
%     \end{cases}
%   \end{equation*}
% \end{lemma}

% \begin{lemma}[lem-canon]
%   \label{lem:lem-canon}
%   \begin{align*}
%   \begin{split}
%   &canon(φ) =\\
%   &\hspace{3mm}
%   \begin{cases}
%       canon(φⱼ), &\text{if } φ ≡ φ₁ ∧ φ₂,\ canon(φᵢ) ≡ ⊤,\\
%                  &\text{for same } i,j = 1,2, i≠j\\
%      ⊥, &\text{if } φ ≡ φ₁ ∧ φ₂,\ canon(φᵢ) ≡ ⊥, i = 1,2\\
%      canon(φ₁) ∧ canon(φ₂), &\text{if } φ ≡ φ₁ ∧ φ₂\\
%      ⊤, &\text{if } φ ≡ φ₁ ∨ φ₂,\ canon(φᵢ) ≡ ⊤, i = 1,2\\
%      canon(φⱼ), &\text{if } φ ≡ φ₁ ∨ φ₂,\ canon(φᵢ) ≡ ⊥,\\
%                 &\text{for same } i,j = 1,2, i≠j\\
%      canon(φ₁) ∨ canon(φ₂), &\text{if } φ ≡ φ₁ ∨ φ₂\\
%      φ, &\text{otherwise.}
%     \end{cases}
%   \end{split}
%   \end{align*}
% \end{lemma}

% \begin{theorem}[thm-canonicalize] % (fold)
%   \label{thm:thm-canonicalize}
%   $Γ ⊢ φ$ then $Γ ⊢ canonicalize(φ)$, where,
%   \begin{equation*}
%     canonicalize =
%      canon ∘ rmBot_{∧} ∘ rmPEM_{∧∨} ∘ redun ∘ rconj ∘ cnf.
%   \end{equation*}
% \end{theorem}

% The \canonicalize rule acts in \Metis' \TSTP derivations in three main cases. First, introducing the
% negation of a subgoal. Second, to simplify an intermediate derivation.
% Third, introducing an axiom or a definition of the.
% To justify the two first cases, we use the Theorem~\ref{thm:thm-canonicalize}. For the last case, we use the Lemma~\ref{lem:lem-nnf}.

% % -------------------------------------------------------------------
% \subsubsection{Simplify}
% \label{sssec:simplify}

% The \simplify rule is the application of the the lemma showed above,
% but also the following lemmas that intend to reduce a list of derivations,
% a conjunction of their formulas into a one smaller.

% \improvement{Missing theorems here.}


% % subsubsection simplify (end)
% % -------------------------------------------------------------------

\end{document}
