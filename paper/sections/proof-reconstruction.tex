% -*- root: main.tex -*-
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Proof-Reconstruction}
\label{sec:proof-reconstruction}

\subsection{Workflow}
\label{ssec:workflow}

\begin{figure}
\centering

\begin{tikzpicture}[scale=0.9]
\node[text width=2cm, align=center](problem) at (0,0)
  {1. \CPL \\ Problem.};

\node[right = 1.1cm of problem, text width=2cm, align=center]
  (tptp){2. \TPTP \\ Problem.};

\node[right= 1.1cm of tptp, text width=2cm, align=center]
   (metis) {3. \Metis \\ Prover.};

\node[right= 1.1cm of metis, text width=2cm, align=center, inner sep=10pt]
   (tstp) {4. \TSTP \\ Derivation.};

\node[below= 0.5cm of tstp, text width=2cm, align=center, inner sep=10pt]
  (athena) {5. \Haskell \\ Translator.};

\node[left = 1.1cm of athena, text width=2cm, align=center]
   (agdafile) {6. \Agda \\ Proof.};

\node[left = 1.1cm of agdafile, text width=2cm, align=center]
   (agda) {7. Proof Checking.};

\node[below = 0.5cm of problem, text width=2cm, align=center]
   (verified) {8.1 Proof \\ Checked.};

\node[below = 0.5cm of verified, text width=2cm, align=center]
   (failure) {8.2 Failure.};

% node[below] {send to}
\draw[->, thick] (problem) to
  % node[below] {\tiny encoding}
  (tptp);
\draw[->, thick] (tptp) to
  % node[below] {\tiny }
  (metis);
\draw[->, thick] (metis) to
  % node[below] {\tiny replies on}
  (tstp);
\draw[->, thick] (tstp) to
  % node[right] {\tiny parsing}
  (athena);
\draw[->, thick] (athena) to
  % node[below] {\tiny traslation}
  (agdafile);
\draw[->, thick] (agdafile) to
  % node[below] {\tiny type-checking}
  (agda);
\draw[->, thick] (agda) to (verified);
\draw[->, thick, gray] (agda) to (failure);
\end{tikzpicture}
\caption{Proof-reconstruction overview.}
\label{fig:proof-reconstruction-workflow}
\end{figure}

The proof-reconstruction approach proposed here consists of a series
of steps similar to the workflow presented by Sultana in
\cite{sultana2015}. This process is a translation from a source
system to a target system. In our case, the system of origin, the
automatic theorem prover, is \Metis; the target system is the proof
assistant, \Agda. We choose \Agda, but another proof assistant with
support of Type Theory and similar features like \Agda
(see a description of \Agda in section
\ref{sec:implementation}) is valid; our results do not depend on
the proof assistant but the support of inductive data types,
termination checking, and type-checking.

Following the diagram in Fig.
\ref{fig:proof-reconstruction-workflow}, the process can begin with
a problem in \CPL that we encode in \TPTP format to be sent as the
input of the \Metis prover.
The proof-search algorithms of \Metis in step No. 3 intend to find
a solution; if they success, \Metis replies a derivation in \TSTP
format of the proof, else \Metis may no stop and running forever or
replies the problem is counter feasible.

With such a derivation, we process it with our \Haskell translator
tool, \Athena~\cite{Athena}.
\Athena parses the \TSTP format, analyze the
derivation and generates a representation of the natural deduction
proof using a version of a tree data structure (see the properties
of this tree in subsection \ref{ssec:metis-proofs}). As a result,
\Athena generates an \Agda file with such a proof. We have included
in this file, \emph{imports} that call \Agda libraries that give
support for the logic~\cite{AgdaProp}, and versions of the \Metis'
inference rules~\cite{AgdaMetis}.

Finally, we use the proof assistant in step No. 7 to type-check the
proof and verify its correctness. Next, we only have one answer:
type-checking succeed (i.e., the proof is valid) or type-checking
failed.
If the type-check fails, one of the three actors in the process are
responsible: \Metis, \Athena, or \Agda. We are responsible for
errors committed in the translation from \TSTP to \Agda; lack of the
coverage of the \Metis' inference rules, or bad assumptions about
them. \improvement{Make this statement stronger and clear.}

In the rest of this section, we provide a formal description using
Type Theory to build definitions and theorems for the functions
necessary to emulate the \Metis' inference rules.

% ...................................................................

\subsection{Rules as Theorems}

Main algorithms in \CPL need the propositions in some of their normal
forms. For instance, from the negative normal form
(henceforth, \abbre{NNF}), we can derive the conjunctive normal form,
and the disjunctive normal form as well.
Therefore, we start giving the definition of \abbre{NNF}, one
function definition, \name{nnf} and a refinement of it.
We will use it later for instance in the description of \canonicalize
rule. The following treatment to this function, \name{nnf},
applies for other conversion functions and theorems defined in
\cite{AgdaProp,AgdaMetis}.
We use the notation convention $:=$ for equivalence between
propositions. The \PROP inductive data type is defined as usual
based on the definition from section \ref{sec:preliminaries} and
implemented in \Agda with \name{PropFormula} in section
\ref{sec:implementation}.

\subsubsection{\CPL Functions}
\hspace*{5cm}\\[3mm]
\emph{NNF.}
A negative normal form for the formula φ is one in which negations
appear only in the literals and the expression is in terms only of
the boolean operators (¬, ∧, ∨).

To transform a formula φ to its equivalent \abbre{NNF} form, we
apply recursively the following equations. The function type for
\name{nnf} is $\PROP \to \PROP$.

\begin{equation}
\label{eq:nnf-definition}
\nnf(φ) =
\begin{cases}
\nnf(φ₁) ∧ \nnf(φ₂)
   & φ := φ₁ ∧ φ₂  \\

\nnf(φ₁) ∨ \nnf(φ₂)
   & φ := φ₁ ∨ φ₂  \\

\nnf(¬ φ₁ ∨ φ₂)
   & φ := φ₁ ⇒ φ₂  \\

\nnf(φ₁ ⇒ φ₂ ∧ φ₂ ⇒ φ₁)
   & φ := φ₁ ⇔ φ₂\\

\nnf(¬ φ₁ ∨ ¬ φ₂)
   & φ := ¬ (φ₁ ∧ φ₂) \\

\nnf(¬ φ₁ ∧ ¬ φ₂)
   & φ := ¬ (φ₁ ∨ φ₂) \\

\nnf(φ₁)
   & φ := ¬ ¬ φ₁     \\


\nnf(¬ (φ₂ ∨ ¬ φ₁))
   & φ := ¬ (φ₁ ⇒ φ₂)  \\

\nnf(¬ (φ₁ ⇒ φ₂ ∧ φ₂ ⇒ φ₁))
   & φ := ¬ (φ₁ ⇔ φ₂) \\

⊥  & φ := ¬ ⊤        \\

⊤  & φ := ¬ ⊥        \\

φ  & \text{otherwise}
\end{cases}
\end{equation}

A recursive function is a well-structured recursion, if the size of
the arguments with which it is defined decrease in size for each
call to the function in the definition. That guarantee termination
of the function, and its translation to constructive Type Theory.

But we need to improve the definition for \name{nnf} in order to have
a version of a well-structured recursion.
We show a strategy to achieve that with a smaller example function,
\unshunt, that we will use forward to formalize the inference
\name{strip}.

\begin{equation}
\label{eq:unshunt-definition}
\unshunt(φ) =
\begin{cases}
\unshunt((φ₁ ∧ φ₂) ⇒ φ₃)
  & φ := φ₁ ⇒ (φ₂ ⇒ φ₃)\\

\unshunt(φ₁ ⇒ φ₂) ∧ \unshunt(φ₁ ⇒ φ₃)
  & φ := φ₁ ⇒ (φ₂ ∧ φ₃)\\

φ &\text{otherwise}
\end{cases}
\end{equation}

To translate the functions in a way that is well defined,
we used the method proposed by Bove and Capettra in
\cite{Bove2005}, which basically consists of

We take a general recursive function $f: \sigma \to \tau$.
Its formalization in Type Theory will define an inductive
predicate $Ind$, $ P: \sigma \to Ind$.

In our case, the set of natural numbers will serve as our
inductive set $Ind$ and as second argument for new function.
Thus, the function $\unshunt$ will be defined by structural
recursion in his second term.

The new proposed $\unshunt^{*}$ has type,

\[
\unshunt^{*} : PROP \to \mathbb{N} \to PROP.
\]

\begin{equation}
\label{eq:unshunt-structured}
\unshunt^{*}(φ, n) =
\begin{cases}
\unshunt^{*}((φ₁ ∧ φ₂) ⇒ φ₃, n-1)
  & φ := φ₁ ⇒ (φ₂ ⇒ φ₃)\\

\unshunt^{*}(φ₁ ⇒ φ₂, n-1) ∧ \unshunt^{*}(φ₁ ⇒ φ₃,n-1)
  & φ := φ₁ ⇒ (φ₂ ∧ φ₃)\\

φ & n := 0
\end{cases}
\end{equation}


\begin{definition}
El rango $rank(\phi)$ de una proposition $\phi$ es definido como

\begin{equation}
\label{eq:rank-definition}
rank(\phi)=
\begin{cases}
0 &\text{for atomic }\phi\\

\max(rank(\phi_1),rank(\phi_2)) + 1
  & \phi := \phi_1\,\square\, \phi_2 \\
rank(\phi_1) + 1  & \phi := \neg \phi_1
\end{cases}
\end{equation}

\end{definition}

Then, we our final review for the function $\unshunt$ is the
function$\unshunt^{+}$ with type $PROP \to PROP$
with a structured recursion,

\begin{equation}
\unshunt^{+}(\varphi) = \unshunt^{*}(\varphi, rank(\varphi))
\end{equation}

In the following section, our task will consist of a searching
appropriate functions like $rank$ to assure the termination for transformation functions like $nnf$.


% ................................................

\subsection{Emulation \Metis' Inference Rules}

\emph{Splitting.}
To prove a goal, we can prove smaller subgoals and combine their
proofs to achieve the final target, a proof of the initial goal.

\begin{theorem}[{\tt thm-$\unshunt^{*}$}] $Γ ⊢ \unshunt^{*}(φ, n)$ for $n\in \mathbb{N}$, then $Γ ⊢ φ$.
\end{theorem}
\begin{proof} Use induction on the cases defined by the result of
$\unshunt^{*}$. When $n = 0$, by definition in Eq.
\ref{eq:unshunt-structured} then $Γ ⊢ φ$.
For the first case, we prove $Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃)$ from
$Γ ⊢ \unshunt^{*}(φ₁ ⇒ (φ₂ ⇒ φ₃), n)$.
Because $n > 0$, using induction on the second argument and the
theorem $∧⇒$\texttt{-to-}$⇒⇒$ from \cite{AgdaProp}.

\begin{equation*}
\begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ (φ₂ ⇒ φ₃), n)$}
\RightLabel{By definition}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ (φ₂ ⇒ φ₃), n-1)$}
\RightLabel{\tt thm-$\unshunt^{*}$}
\UnaryInfC{Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃}
\RightLabel{\tt ∧⇒-to-⇒⇒}
\UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃)}
\end{bprooftree}
\end{equation*}

The second case proves $Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃)$ from
 $Γ ⊢ \unshunt^{*}(φ₁ ⇒ (φ₂ ∧ φ₃), n)$ and the
theorem $⇒∧⇒$\texttt{-to-}$⇒∧$ from \cite{AgdaProp}
\begin{equation*}
\scalebox{0.95}{
$D_1$ := \begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₂, n) ∧ \unshunt^{*}(φ₁ ⇒ φ₃, n)$}
\RightLabel{\tt ∧-proj₁}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₂, n)$}
\RightLabel{By definition}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₂, n-1)$}
\RightLabel{\tt thm-$\unshunt^{*}$}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
\end{bprooftree}
}
\end{equation*}

\begin{equation*}
D_2 :=
\begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₂) ∧ \unshunt^{*}(φ₁ ⇒ φ₃)$}
\RightLabel{\tt ∧-proj₂}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₃, n)$}
\RightLabel{By definition}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₃, n-1)$}
\RightLabel{\tt thm-$\unshunt^{*}$}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₃$}
\end{bprooftree}
\end{equation*}

\begin{equation*}
\begin{bprooftree}
\AxiomC{$D_1$}
\AxiomC{$D_2$}
\RightLabel{\tt ∧-intro}
\BinaryInfC{$Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃)$}
\RightLabel{\tt ⇒∧⇒-to-⇒∧}
\UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃)}
\end{bprooftree}
\end{equation*}
\end{proof}

The function \mysplit has the type
\[ \mysplit : \PROP \to \PROP
\]
\begin{equation}
\label{eq:split-definition}
\mysplit(φ) =
\begin{cases}
\unshunt(\mysplit(φ₁)) ∧ \unshunt(φ₁ ⇒ \mysplit(φ₂)
  & φ := φ₁ ∧ φ₂\\

\unshunt(¬ φ₁ ⇒ \mysplit(φ₂))
  & φ := φ₁ ∨ φ₂\\

\unshunt(φ₁ ⇒ \mysplit(φ₂))
  & φ := φ₁ ⇒ φ₂\\

\unshunt(φ₁ ⇒ \mysplit(φ₂)) ∧ \unshunt(φ₂ ⇒ \mysplit(φ₁))
  & φ := φ₁ ⇔ φ₂\\

\unshunt(φ₁ ⇒ \mysplit(¬ φ₂))
  & φ := ¬ (φ₁ ∧ φ₂)\\

\unshunt(\mysplit(¬ φ₁)) ∧ \unshunt(¬ φ₁ ⇒ \mysplit(¬ φ₂))
  & φ := ¬ (φ₁ ∨ φ₂)\\

\unshunt(\mysplit(φ₁)) ∧ \unshunt(φ₁ ⇒ \mysplit(¬ φ₂))
  & φ := ¬ (φ₁ ⇒ φ₂)\\

\unshunt(φ₁ ⇒ \mysplit(¬ φ₂)) ∧ \unshunt(¬ φ₂ ⇒ \mysplit(φ₁))
  & φ := ¬ (φ₁ ⇔ φ₂)\\

\unshunt(\mysplit(φ₁)
  & φ := ¬ ¬ φ₁\\

⊤ & φ := ¬ ⊥\\

⊥ & φ := ¬ ⊤\\

φ &\text{otherwise}
\end{cases}
\end{equation}

\begin{theorem}[Splitting a Goal] $Γ ⊢ \mysplit(φ) ⇒ φ$
\end{theorem}

\begin{proof}
ss
\end{proof}

The \mysplit function returns a conjunction of the subgoal. From each
\TSTP derivation, we have information of the subgoals but no how they strictly appear in that conjunction. For that reason, with \Athena, we infer the exact order in the conjunction that coincides with the output by \mysplit.

\begin{theorem} For a list of subgoals $s_0, \cdots, s_1$ with their respective theorem $Γ ⊢ s_i$, such that $\bigwedge_i s_i ⇒ \texttt{goal}$, then $Γ ⊢ \texttt{goal}$.
\end{theorem}


\end{document}