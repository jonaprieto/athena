
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Proof-Reconstruction}
\label{sec:proof-reconstruction}

\subsection{Workflow}
\label{ssec:workflow}

\begin{figure}
\centering

\begin{tikzpicture}[scale=0.9]
\node[text width=2cm, align=center](problem) at (0,0)
  {1. \CPL \\ Problem.};

\node[right = 1.1cm of problem, text width=2cm, align=center]
  (tptp){2. \TPTP \\ Problem.};

\node[right= 1.1cm of tptp, text width=2cm, align=center]
   (metis) {3. \Metis \\ Prover.};

\node[right= 1.1cm of metis, text width=2cm, align=center, inner sep=10pt]
   (tstp) {4. \TSTP \\ Derivation.};

\node[below= 0.5cm of tstp, text width=2cm, align=center, inner sep=10pt]
  (athena) {5. \Haskell \\ Translator.};

\node[left = 1.1cm of athena, text width=2cm, align=center]
   (agdafile) {6. \Agda \\ Proof.};

\node[left = 1.1cm of agdafile, text width=2cm, align=center]
   (agda) {7. Proof Checking.};

\node[below = 0.5cm of problem, text width=2cm, align=center]
   (verified) {8.1 Proof \\ Checked.};

\node[below = 0.5cm of verified, text width=2cm, align=center]
   (failure) {8.2 Failure.};

% node[below] {send to}
\draw[->, thick] (problem) to
  % node[below] {\tiny encoding}
  (tptp);
\draw[->, thick] (tptp) to
  % node[below] {\tiny }
  (metis);
\draw[->, thick] (metis) to
  % node[below] {\tiny replies on}
  (tstp);
\draw[->, thick] (tstp) to
  % node[right] {\tiny parsing}
  (athena);
\draw[->, thick] (athena) to
  % node[below] {\tiny traslation}
  (agdafile);
\draw[->, thick] (agdafile) to
  % node[below] {\tiny type-checking}
  (agda);
\draw[->, thick] (agda) to (verified);
\draw[->, thick, gray] (agda) to (failure);
\end{tikzpicture}
\caption{Proof-reconstruction overview.}
\label{fig:proof-reconstruction-workflow}
\end{figure}

The proof-reconstruction approach proposed here consists of a series
of steps similar to the workflow presented by \citeauthor{sultana2015} in
\cite{sultana2015}. This process is a translation from a source
system to a target system. In our case, the system of origin, the
automatic theorem prover, is \Metis; the target system is the proof
assistant, \Agda. We choose \Agda, but a proof assistant with
support of type theory and similar features like \Agda
(see a description of \Agda in Section
\ref{sec:implementation}) can be used.
Following the diagram in Fig.
\ref{fig:proof-reconstruction-workflow}, the process can begin with
a problem in \CPL that we encode in \TPTP format to be sent as the
input of the \Metis prover.
The algorithms of \Metis in Step~3 intend to find
a solution; if they success, \Metis replies a derivation in \TSTP
format of the proof, else the problem is counter feasible.

With such a derivation, we process it with our \Haskell translator
tool, \Athena~\cite{Athena}.
\Athena parses the \TSTP format, analyze the
derivation and generates a representation of the natural deduction
proof using a version of a tree data structure (see the properties
of this tree in Subsection \ref{ssec:metis-proofs}). As a result,
\Athena generates an \Agda file with such a proof. We have included
in this file, \emph{imports} that call \Agda libraries that give
support for the logic~\cite{AgdaProp}, and versions of the \Metis'
inference rules~\cite{AgdaMetis}.

Finally, we use the proof checker in Step~7 to type-check the
proof-term. If type-checking succeed, the proof from such a \TSTP
derivation is correct, else if type-checking fails, one of the three
actors in the process could be the responsible.
They are \Metis, \Athena, or \Agda.

We are responsible for errors committed in the translation from
\TSTP to \Agda: bugs in the parsing module, lack of the coverage of
the \Metis' inference rules since we are emulating them, and last
but not least, the pretty print of the proof in \Agda code.

In the rest of this section, we provide a formal description using
type theory to build definitions and theorems for functions
necessary to emulate \Metis' inference rules.
Some conventions about notations. We will write the
type judgments with ``$a : A$'' to denote that $a$ has type
$\abbre{A}$. Types are written using small caps.
For propositions, we will denote by $φ ≡ ψ$, the syntactic
equivalence.


% ...................................................................

% section section_name (end)
\subsection{Structural Recursion}
\label{ssec:structural-recursion}

In the process to emulate \Metis' inference rules in type theory,
we encountered that some of \Metis' transformation for propositions in
the inference rules were given by \emph{general recursion} functions.
But algorithms based on general recursions can not be translated
directly in type theory since it is not a guarantee they terminate.
Then, since a termination checker in type theory recognizes
\emph{structural recursion functions}, we modify our algorithms appropriately.

Using the concept of \emph{structurally smaller} from
\citeauthor{Abel2002}~\cite{Abel2002}. We say, a recursive function is
structurally recursive if it calls itself with only \emph{structurally smaller}
arguments.

To convert a general recursive call into a structurally recursive call, we use
the \emph{Bounded Recursion} technique presented in \cite{Coquand1992} but others found in
\cite{Coquand1992,Abel2002,Bove2005} could be used.

The \emph{Bounded Recursion} technique converts a general recursive
function into a structural recursive function by adding an additional
argument that handle the times the function can call itself.

In our case, we add a natural number $n : \Nat$ in the input of the general
recursive function for such an argument in mostly cases, and perform the
recursion over the structure of \Nat type. \abbre{Nat} type is the usual
type with \zero and \suc constructors, and including the common arithmetic
operations ($+,\,-,\,*$) and representations of $\zero, \suc, \suc(\zero),
\dots$
with $0,1,2,\dots$.

Then, the type-checker will
recognize structurally smaller arguments by using the lexicographic
order~\cite{Abel2002} for such kind of functions.

In other words, we take a general recursive function $f: \Prop \to \Prop$.
and we redefine that function as
$f: \Prop \to \Nat \to \Prop$, and perform the recursion
using induction on the structure of the \Nat type.

We define

Let us consider the following example to exhibit the technique
mentioned above for an inner function in the \strip inference.

\begin{equation}
\label{eq:unshunt-definition}
\unshunt_{0}(φ) =
\begin{cases}
\unshunt_{0}((φ₁ ∧ φ₂) ⇒ φ₃)
  & φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃),\\

\unshunt_{0}(φ₁ ⇒ φ₂) ∧ \unshunt_{0}(φ₁ ⇒ φ₃)
  & φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃),\\

φ &\text{otherwise}.
\end{cases}
\end{equation}

From the definition above, the size of the argument, ((φ₁ ∧ φ₂) ⇒ φ₃),
is not structurally smaller than the input formula, (φ₁ ⇒ (φ₂ ⇒ φ₃));
((φ₁ ∧ φ₂) ⇒ φ₃) is not a subformula of (φ₁ ⇒ (φ₂ ⇒ φ₃)).

Thus, we have a new function
$\unshunt_{1} : \Prop \to \Nat \to \Prop$
defined by structural recursion in its second argument in
Eq.~\ref{eq:unshunt-structured}.

\begin{align}
\label{eq:unshunt-structured}
\begin{split}
\unshunt_{1}(φ, \zero) &= φ\\
\unshunt_{1}(φ, \suc(n)) &=
\begin{cases}
\unshunt_{1}((φ₁ ∧ φ₂) ⇒ φ₃, n)
  & φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃),\\
\unshunt_{1}(φ₁ ⇒ φ₂, n)  & φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃).\\
∧\ \unshunt_{1}(φ₁ ⇒ φ₃, n)
\end{cases}
\end{split}
\end{align}

To feed the second argument of this new function, we will use
functions. For instance, we opted to use a complexity measure of
the formula that $\unshunt_{1}$ function transforms.


A \emph{complexity measure} defined in \cite{Agudelo-Agudelo2017}
and presented in \cite{VanDalen1994} as well as \emph{the rank for a
proposition} is a function with type
$\Prop \to \Nat$ that assigns a natural number to a
proposition φ as follows.

\begin{equation*}
\label{eq:rank-definition}
rank(φ)=
\begin{cases}
0 &\text{for atomic }φ, \\
rank(φ₁) + c_{¬}  & φ ≡ \neg φ₁, \\
\max{(rank(φ₁),rank(φ₂))} + c_{\square}
  & φ ≡ φ₁\,\square\, φ₂.
\end{cases}
\end{equation*}

where $c_{¬}$ or $c_{\square}$ is a non-negative integer called the
complexity of the connective.

We have already solved the terminating problem for the \unshunt
function in Eq.~\ref{eq:unshunt-structured}, nevertheless we do not
what natural number should be feed that argument in
order to maintain the same outputs as the original \unshunt does in
Eq.~\ref{eq:unshunt-definition}.


Therefore, we define an appropriate complexity measure
$\unshunt_{cm}: \Prop → \NN$
for the second argument of the $\unshunt_{1}$ function in
Eq.~\ref{eq:unshunt-rank-definition}.

\begin{equation}
\label{eq:unshunt-rank-definition}
\unshunt_{cm}(φ)=
\begin{cases}
\unshunt_{cm}(φ₃) + 2 & φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃),\\
\max(\unshunt_{cm}(φ₂),\unshunt_{cm}(φ₃)) + 1
  & φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃),\\
0 &\text{otherwise.}
\end{cases}
\end{equation}

Then, a curated version of the $\unshunt_{0}$ function is presented
in Eq.~\ref{eq:unshunt-fixed}.

\begin{equation}
\label{eq:unshunt-fixed}
\unshunt(\varphi) := \unshunt_{1}(\varphi, \unshunt_{cm}(\varphi)).
\end{equation}

For a more complete treatment of general recursion, and how to
define well-founded and well-structural recursive functions, we refer
the reader to Ref.~\cite{Bove2005}, where Bove and Capettra described
not only general recursion but they also treat mutual recursive
function, among other kinds.

% ................................................

\subsection{Emulating \Metis' Inference Rules}
\label{ssec:emulating-inferences}


\emph{Splitting a goal.}
The goal of a proof is processed by \Metis to generated new targets,
\Metis calls these new formulas \emph{subgoals}.
Then, \Metis proves each subgoal and with that it finishes the proof
of the goal.

Nevertheless, \Metis does not provide neither an explanation of this
process in its \TSTP derivations nor in its documentation.
We provide such a evidence that the process of creating subgoals,
and combining them in a final conjunction proves the original goal.

\begin{theorem}[\thmunshunt]
\label{thm:unshunt}
$Γ ⊢ \unshunt(φ)$, then $Γ ⊢ φ$.
\end{theorem}

\begin{proof} Use induction on the cases defined by the outcome of the $\unshunt$ function in Eq.~\ref{eq:unshunt-structured}.
When $n = 0$, by definition, $Γ ⊢ φ$.
When $n = 1$, we apply the following theorem presented in
\cite{AgdaProp}

\begin{equation*}
\texttt{∧⇒-to-⇒⇒}\ :\  Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃ → Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃).
\end{equation*}

For $n > 1$, we will use induction on the structure of second
argument.

(φ₁ ⇒ (φ₂ ⇒ φ₃))
\begin{equation*}
\begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n-1)$}
\RightLabel{\thmunshunt}
\UnaryInfC{Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃}
\RightLabel{∧⇒-to-⇒⇒}
\UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃).}
\end{bprooftree}
\end{equation*}

Second, using the following theorem from \cite{AgdaProp},

\begin{equation*}
\texttt{⇒∧-to-⇒∧}\ :\ Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃) → Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃).
\end{equation*}

(φ₁ ⇒ (φ₂ ∧ φ₃))
\begin{equation*}
\scalebox{0.95}{
($\mathcal{D}_1$)
\begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt(φ₁ ⇒ φ₂, n) ∧ \unshunt(φ₁ ⇒ φ₃, n)$}
\RightLabel{∧-proj₁}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ φ₂, n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ φ₂, n-1)$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$,}
\end{bprooftree}
}
\end{equation*}

\begin{equation*}
(\mathcal{D}_2)
\begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt(φ₁ ⇒ φ₂) ∧ \unshunt(φ₁ ⇒ φ₃)$}
\RightLabel{∧-proj₂}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ φ₃, n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ φ₃, n-1)$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₃$,}
\end{bprooftree}
\end{equation*}

\begin{equation*}
\begin{bprooftree}
\AxiomC{$\mathcal{D}_1$}
\AxiomC{$\mathcal{D}_2$}
\RightLabel{∧-intro}
\BinaryInfC{$Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃)$}
\RightLabel{⇒∧⇒-to-⇒∧}
\UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃).}
\end{bprooftree}
\end{equation*}
\end{proof}

Now, let us consider the \mysplit function that
yields the conjunction of subgoals from a proposition goal.

\begin{equation}
\label{eq:split-definition}
\mysplit(φ) =
\begin{cases}
\unshunt(\mysplit(φ₁))              & φ ≡ φ₁ ∧ φ₂,\\
∧\ \unshunt(φ₁ ⇒ \mysplit(φ₂))      &\\[2mm]

\unshunt(¬ φ₁ ⇒ \mysplit(φ₂))       & φ ≡ φ₁ ∨ φ₂,\\

\unshunt(φ₁ ⇒ \mysplit(φ₂))         & φ ≡ φ₁ ⇒ φ₂,\\

\unshunt(φ₁ ⇒ \mysplit(φ₂))         & φ ≡ φ₁ ⇔ φ₂,\\
∧\ \unshunt(φ₂ ⇒ \mysplit(φ₁))      &\\[2mm]

\unshunt(φ₁ ⇒ \mysplit(¬ φ₂))       & φ ≡ ¬ (φ₁ ∧ φ₂),\\

\unshunt(\mysplit(¬ φ₁))            & φ ≡ ¬ (φ₁ ∨ φ₂),\\
∧\ \unshunt(¬ φ₁ ⇒ \mysplit(¬ φ₂))  &\\[2mm]

\unshunt(\mysplit(φ₁))              & φ ≡ ¬ (φ₁ ⇒ φ₂),\\
∧\ \unshunt(φ₁ ⇒ \mysplit(¬ φ₂))    &\\[2mm]

\unshunt(φ₁ ⇒ \mysplit(¬ φ₂))       & φ ≡ ¬ (φ₁ ⇔ φ₂),\\
∧\ \unshunt(¬ φ₂ ⇒ \mysplit(φ₁))    &\\[2mm]

\unshunt(\mysplit(φ₁))              & φ ≡ ¬ ¬ φ₁,\\
⊤                                   & φ ≡ ¬ ⊥,\\
⊥                                   & φ ≡ ¬ ⊤.
\end{cases}
\end{equation}

We reformulate \mysplit function to match with the
new definition after apply the process described above in
Subsection~\ref{ssec:structural-recursion}, since
in the recursion calls of \mysplit in Eq.~\ref{eq:split-definition},
the negations, $(¬ φ_{1,2})$ raise a terminating problem.



\begin{theorem}[\thmsplit] $Γ ⊢ \mysplit(φ)$ then $Γ ⊢ φ$.
\end{theorem}

\begin{proof} We now proceed by induction on the structure of the
formula φ in the definition of Eq.~\ref{eq:split-definition}.
For a complete proof, we refer the reader to~\cite{AgdaMetis}.\\[3mm]

(φ ≡ φ₁ ∧ φ₂)
\begin{equation*}
\begin{bprooftree}
\AxiomC{$\mathcal{D}_1$}
\UnaryInfC{Γ ⊢ φ₁}

\AxiomC{$\mathcal{D}_1$}
\UnaryInfC{Γ ⊢ φ₁}

\AxiomC{$Γ ⊢ \mysplit(φ,n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁) ∧ \unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
\RightLabel{$∧$-proj$₂$}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
\RightLabel{$⇒$-elim}
\BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
\RightLabel{\thmsplit}
\UnaryInfC{$Γ ⊢ φ₂$}

\RightLabel{∧-intro}
\BinaryInfC{$Γ ⊢ φ₁ ∧ φ₂$.}
\end{bprooftree}
\end{equation*}
Where,
\begin{equation*}
(\mathcal{D}_1)\hspace{3mm}
\begin{bprooftree}
\AxiomC{$Γ ⊢ \mysplit(φ,n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁) ∧ \unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
\RightLabel{∧-proj₁}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁)$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ φ₁$.}
\end{bprooftree}
\end{equation*}


(φ ≡ φ₁ ⇒ φ₂)
\begin{equation*}
\begin{bprooftree}
\AxiomC{}
\RightLabel{assume φ₁}
\UnaryInfC{$Γ , φ₁ ⊢ φ₁$}
\AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
\RightLabel{weaken φ₁}
\UnaryInfC{$Γ , φ₁ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
\RightLabel{⇒-elim}
\BinaryInfC{$Γ , φ₁ ⊢ \mysplit(φ₂,n-1)$}
\RightLabel{\thmsplit}
\UnaryInfC{$Γ , φ₁ ⊢ φ₂$}
\RightLabel{⇒-intro}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$.}
\end{bprooftree}
\end{equation*}


(φ ≡ ¬ (φ₁ ∨ φ₂))
\begin{equation*}
\begin{bprooftree}
\AxiomC{$\mathcal{D}$}
\UnaryInfC{$Γ ⊢ ¬ φ₁$}

\AxiomC{$\mathcal{D}$}
\UnaryInfC{$Γ ⊢ ¬ φ₁$}

\AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(¬ φ₁) ∧ \unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
\RightLabel{∧-proj₂}
\UnaryInfC{$Γ ⊢ \unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ ¬ φ₁ ⇒ \mysplit(φ₂,n-1)$}
\RightLabel{⇒-elim}
\BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
\RightLabel{\thmsplit}
\UnaryInfC{$Γ ⊢ ¬ φ₂$}
\RightLabel{∧-intro}
\BinaryInfC{$Γ ⊢ ¬ φ₁ ∧ ¬ φ₂$}
\RightLabel{¬∧¬-to-¬∨}
\UnaryInfC{$Γ ⊢ ¬ (φ₁ ∨ φ₂)$.}
\end{bprooftree}
\end{equation*}

Where,

\begin{equation*}
(\mathcal{D})
\begin{bprooftree}
\AxiomC{$Γ ⊢ \mysplit(φ, n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(¬ φ₁) ∧ \unshunt(¬ φ₁ ⇒ \mysplit(φ₂, n))$}
\RightLabel{∧-proj₁}
\UnaryInfC{$Γ ⊢ \unshunt(¬ φ₁)$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ ¬ φ₁$.}
\end{bprooftree}
\end{equation*}
\end{proof}

\begin{theorem} If $s_i$ are the subgoals for the goal φ, and
$\{ Γ ⊢ s_i \}_{i}$, then $Γ ⊢ φ$.
\end{theorem}

\begin{proof}
\begin{equation*}
\begin{bprooftree}
\AxiomC{$\left\{ Γ ⊢ s_i \right\}_{i}$}
\RightLabel{∧-intro}
\UnaryInfC{$Γ ⊢ \bigwedge_i s_i$}

\AxiomC{$\mysplit(φ) ≡ \bigwedge_i s_i $}
\RightLabel{subst}
\BinaryInfC{$Γ ⊢ \mysplit(φ) $}

\RightLabel{\thmsplit}
\UnaryInfC{$Γ ⊢ φ$.}
\end{bprooftree}
\end{equation*}
Where, the $subst$ theorem is,
\begin{equation}
\label{eq:substitution-theorem}
\begin{bprooftree}
\AxiomC{$Γ ⊢ φ$}   \AxiomC{$ψ ≡ φ$}
\RightLabel{subst}
\BinaryInfC{$Γ ⊢ ψ$.}
\end{bprooftree}
\end{equation}
\end{proof}

\emph{Splitting a conjunct}.
The \conjunct rule extracts from a conjunction, one of its conjunct.
To achieve this, we use projections repeatedly until we finally find
the conjunct required.

\begin{align}
\begin{split}
conjunct(φ, ψ) =
\begin{cases}
ψ &\text{if }φ ≡ ψ\\
ψ &\text{if }φ ≡ φ₁ ∧ φ₁\text{ and }ψ ≡ conjunct(φ₁, ψ)\\
ψ &\text{if }φ ≡ φ₁ ∧ φ₁\text{ and }ψ ≡ conjunct(φ₂, ψ)\\
φ &\text{otherwise}
\end{cases}
\end{split}
\end{align}

\begin{theorem}[thm-conjunct]  $Γ ⊢ φ$, and $ψ \in \Prop$, then $Γ ⊢ conjunct(φ, ψ)$.
\end{theorem}

\begin{proof}
When φ ≡ ψ, from $Γ ⊢ conjunct(φ, ψ)$ by normalization, we get $Γ ⊢ ψ$.
By using $subst$ theorem Eq.~\ref{eq:substitution-theorem}, we get the desire conclusion. If the proposition φ is a conjunction, and $ψ ≡ conjunct(φ_{i}, ψ)$
for some $i = 1,\ 2$, from $Γ ⊢ conjunct(φ, ψ)$ by normalization, we get
$Γ ⊢ ψ$, but since $conjunct(φ_{i}, ψ) ≡ ψ$; we apply $subst$ theorem again,
and the theorem follows.
For the latter case, by using the hypothesis, $Γ ⊢ φ$, the proof is complete.

Note that $conjunct$ function and also its theorem are well defined structural recursions, since φ₁ and φ₂ in the argument from the definition are structurally smaller than φ.
\end{proof}

\emph{Clausification.}

\end{document}