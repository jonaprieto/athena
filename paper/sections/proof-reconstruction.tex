% -*- root: main.tex -*-
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Proof-Reconstruction}
\label{sec:proof-reconstruction}

\subsection{Workflow}
\label{ssec:workflow}

\begin{figure}
\centering

\begin{tikzpicture}[scale=0.9]
\node[text width=2cm, align=center](problem) at (0,0)
  {1. \CPL \\ Problem.};

\node[right = 1.1cm of problem, text width=2cm, align=center]
  (tptp){2. \TPTP \\ Problem.};

\node[right= 1.1cm of tptp, text width=2cm, align=center]
   (metis) {3. \Metis \\ Prover.};

\node[right= 1.1cm of metis, text width=2cm, align=center, inner sep=10pt]
   (tstp) {4. \TSTP \\ Derivation.};

\node[below= 0.5cm of tstp, text width=2cm, align=center, inner sep=10pt]
  (athena) {5. \Haskell \\ Translator.};

\node[left = 1.1cm of athena, text width=2cm, align=center]
   (agdafile) {6. \Agda \\ Proof.};

\node[left = 1.1cm of agdafile, text width=2cm, align=center]
   (agda) {7. Proof Checking.};

\node[below = 0.5cm of problem, text width=2cm, align=center]
   (verified) {8.1 Proof \\ Checked.};

\node[below = 0.5cm of verified, text width=2cm, align=center]
   (failure) {8.2 Failure.};

% node[below] {send to}
\draw[->, thick] (problem) to
  % node[below] {\tiny encoding}
  (tptp);
\draw[->, thick] (tptp) to
  % node[below] {\tiny }
  (metis);
\draw[->, thick] (metis) to
  % node[below] {\tiny replies on}
  (tstp);
\draw[->, thick] (tstp) to
  % node[right] {\tiny parsing}
  (athena);
\draw[->, thick] (athena) to
  % node[below] {\tiny traslation}
  (agdafile);
\draw[->, thick] (agdafile) to
  % node[below] {\tiny type-checking}
  (agda);
\draw[->, thick] (agda) to (verified);
\draw[->, thick, gray] (agda) to (failure);
\end{tikzpicture}
\caption{Proof-reconstruction overview.}
\label{fig:proof-reconstruction-workflow}
\end{figure}

The proof-reconstruction approach proposed here consists of a series
of steps similar to the workflow presented by Sultana in
\cite{sultana2015}. This process is a translation from a source
system to a target system. In our case, the system of origin, the
automatic theorem prover, is \Metis; the target system is the proof
assistant, \Agda. We choose \Agda, but another proof assistant with
support of Type Theory and similar features like \Agda
(see a description of \Agda in section
\ref{sec:implementation}) is valid; our results do not depend on
the proof assistant but the support of inductive data types,
termination checking, and type-checking.

Following the diagram in Fig.
\ref{fig:proof-reconstruction-workflow}, the process can begin with
a problem in \CPL that we encode in \TPTP format to be sent as the
input of the \Metis prover.
The proof-search algorithms of \Metis in step No. 3 intend to find
a solution; if they success, \Metis replies a derivation in \TSTP
format of the proof, else \Metis may no stop and running forever or
replies the problem is counter feasible.

With such a derivation, we process it with our \Haskell translator
tool, \Athena~\cite{Athena}.
\Athena parses the \TSTP format, analyze the
derivation and generates a representation of the natural deduction
proof using a version of a tree data structure (see the properties
of this tree in subsection \ref{ssec:metis-proofs}). As a result,
\Athena generates an \Agda file with such a proof. We have included
in this file, \emph{imports} that call \Agda libraries that give
support for the logic~\cite{AgdaProp}, and versions of the \Metis'
inference rules~\cite{AgdaMetis}.

Finally, we use the proof assistant in step No. 7 to type-check the
proof and verify its correctness. Next, we only have one answer:
type-checking succeed (i.e., the proof is valid) or type-checking
failed.
If the type-check fails, one of the three actors in the process are
responsible: \Metis, \Athena, or \Agda. We are responsible for
errors committed in the translation from \TSTP to \Agda; lack of the
coverage of the \Metis' inference rules, or bad assumptions about
them. \improvement{Make this statement stronger and clear.}

In the rest of this section, we provide a formal description using
Type Theory to build definitions and theorems for the functions
necessary to emulate the \Metis' inference rules.

% ...................................................................

\subsection{Well-structured Recursion}
\label{ssec:well-structured recursion}

To emulate the \Metis' Inference Rules in type theory.
We encounter many functions involved with termination problems, that
means, it is not possible to determine effectively if the function
terminates. That makes impossible to translate in type theory
directly. For that reason, we show a technique that will help us to fix such a issue and guide us how to proceed later.

A recursive function is a \emph{well-structured recursion}, if the
size of the arguments with which it is defined decrease in
size for each call to the function in the definition.
A well-structured function terminates and it can be translated
directly to type theory.

Consider the following example from the \strip inference.

\begin{equation}
\label{eq:unshunt-definition}
\unshunt(φ) =
\begin{cases}
\unshunt((φ₁ ∧ φ₂) ⇒ φ₃)
  & φ := φ₁ ⇒ (φ₂ ⇒ φ₃),\\

\unshunt(φ₁ ⇒ φ₂) ∧ \unshunt(φ₁ ⇒ φ₃)
  & φ := φ₁ ⇒ (φ₂ ∧ φ₃),\\

φ &\text{otherwise}.
\end{cases}
\end{equation}

From the above definition, in the first case of the \unshunt
function, the size of the argument doesn't really decrease.
Actually, it maintains with the same size ((φ₁ ∧ φ₂) ⇒ φ₃ and  (φ₁ ⇒
(φ₂ ⇒ φ₃))). Therefore, a termination checking will fail with \unshunt
function.

To improve it, we will use the technique proposed by Bove and Capettra in
\cite{Bove2005}, which in our case basically consists of
take a general recursive function $f: \sigma \to \tau$.
and an predicate $P: \sigma \to \abbre{Ind}$, where $\abbre{Ind}$
is a type with a structure inductive definition.
Then, we redefine the function as
$f: \sigma \to \abbre{Ind}\ \to \tau$, and perform the recursion
using induction on the structure of the \abbre{Ind} type.

In our case, $\abbre{Ind}$ will be the \abbre{Nat} data type for
natural numbers with constructors \abbre{zero} and \abbre{suc} defined as usual.

Thus, we have function $\unshunt : \PROP \to \Nat \to \PROP$ defined by structural recursion in his second term with type as follows,

\begin{align*}
\label{eq:unshunt-structured}
\unshunt(φ, \zero) &= φ\\
\unshunt(φ, \suc(n)) &=
\begin{cases}
\unshunt((φ₁ ∧ φ₂) ⇒ φ₃, n)
  & φ := φ₁ ⇒ (φ₂ ⇒ φ₃),\\
\unshunt(φ₁ ⇒ φ₂, n) ∧ \unshunt(φ₁ ⇒ φ₃,n)
  & φ := φ₁ ⇒ (φ₂ ∧ φ₃).
\end{cases}
\end{align*}

Finally, we define the complexity measure to handle the second argument for the \unshunt function.

\newcommand{\rank}{\name{rank}}

A \emph{complexity measure} defined in \cite{Agudelo-Agudelo2017} or
a rank function presented in \cite{VanDalen1994} is a function
$\PROP \to \Nat$ that indents to associate a natural number for a
proposition φ. The following function is a complexity measure.

\begin{equation*}
\label{eq:rank-definition}
\rank(φ)=
\begin{cases}
0 &\text{for atomic }φ, \\
\rank(φ₁) + c_{¬}  & φ := \neg φ₁, \\
\max(\rank(φ₁),\rank(φ₂)) + c_{\square}
  & φ := φ₁\,\square\, φ₂.
\end{cases}
\end{equation*}
where $c_{¬}$ or $c_{\square}$ is a non-negative integer called the
complexity of the connective.

Nevertheless, we need to define an appropriate complexity measure for the second argument in the $\unshunt$ function, in order to
expect the same behavior of the original function as it was defined at first in Eq.~\ref{eq:unshunt-definition}.

\begin{equation}
\label{eq:rank-definition}
\unshunt_{cm}(φ)=
\begin{cases}
\unshunt_{cm}(φ₃) + 2 & φ := φ₁ ⇒ (φ₂ ⇒ φ₃),\\
\max(\unshunt_{cm}(φ₂),\unshunt_{cm}(φ₃)) + 1
  & φ := φ₁ ⇒ (φ₂ ∧ φ₃),\\
0 &\text{otherwise.}
\end{cases}
\end{equation}

Then, a curated version of \unshunt is presented in Eq.
\ref{eq:unshunt-fixed}.

\begin{equation}
\label{eq:unshunt-fixed}
\unshunt(\varphi) := \unshunt(\varphi, \unshunt_{cm}(\varphi))
\end{equation}

In the following section, we may need define such complexity measure
functions for termination-checking.

% ................................................

\subsection{Emulating \Metis' Inference Rules}
\label{ssec:emulating-inferences}


\emph{Splitting.}
To prove a goal, we can prove smaller subgoals and combine their
proofs to achieve the final target, a proof of the initial goal.

\begin{theorem}[{\tt thm-$\unshunt^{*}$}] $Γ ⊢ \unshunt^{*}(φ, n)$
for $n\in \Nat$, then $Γ ⊢ φ$.
\label{thm:unshunt}
\end{theorem}

\begin{proof} Use induction on the cases defined by the result of
$\unshunt^{*}$. When $n = 0$, by definition in Eq.
\ref{eq:unshunt-structured} then $Γ ⊢ φ$.
For the first case, we prove $Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃)$ from
$Γ ⊢ \unshunt^{*}(φ₁ ⇒ (φ₂ ⇒ φ₃), n)$.
Because $n > 0$, using induction on the second argument and the
theorem $∧⇒$\texttt{-to-}$⇒⇒$ from \cite{AgdaProp}.

\begin{equation*}
\begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ (φ₂ ⇒ φ₃), n)$}
\RightLabel{By definition}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ (φ₂ ⇒ φ₃), n-1)$}
\RightLabel{\tt thm-$\unshunt^{*}$}
\UnaryInfC{Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃}
\RightLabel{\tt ∧⇒-to-⇒⇒}
\UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃)}
\end{bprooftree}
\end{equation*}

The second case proves $Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃)$ from
 $Γ ⊢ \unshunt^{*}(φ₁ ⇒ (φ₂ ∧ φ₃), n)$ and the
theorem $⇒∧⇒$\texttt{-to-}$⇒∧$ from \cite{AgdaProp}
\begin{equation*}
\scalebox{0.95}{
$\mathcal{D}_1$ := \begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₂, n) ∧ \unshunt^{*}(φ₁ ⇒ φ₃, n)$}
\RightLabel{\tt ∧-proj₁}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₂, n)$}
\RightLabel{By definition}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₂, n-1)$}
\RightLabel{\tt thm-$\unshunt^{*}$}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
\end{bprooftree}
}
\end{equation*}

\begin{equation*}
\mathcal{D}_2 :=
\begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₂) ∧ \unshunt^{*}(φ₁ ⇒ φ₃)$}
\RightLabel{\tt ∧-proj₂}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₃, n)$}
\RightLabel{By definition}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₃, n-1)$}
\RightLabel{\tt thm-$\unshunt^{*}$}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₃$}
\end{bprooftree}
\end{equation*}

\begin{equation*}
\begin{bprooftree}
\AxiomC{$\mathcal{D}_1$}
\AxiomC{$\mathcal{D}_2$}
\RightLabel{\tt ∧-intro}
\BinaryInfC{$Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃)$}
\RightLabel{\tt ⇒∧⇒-to-⇒∧}
\UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃)}
\end{bprooftree}
\end{equation*}
\end{proof}

\vskip 3mm

From now on, we redefine the function $\unshunt$ with the
definition of $\unshunt^{+}$ for no overloading the notation forward.

\begin{theorem}[{\tt thm-\unshunt}] $Γ ⊢ \unshunt(φ)$ then $Γ ⊢ φ$.
\end{theorem}
\begin{proof} It follows from Thm.~\ref{thm:unshunt} using the
\rank function as the second argument.
\end{proof}

The \mysplit function yields a conjunction of subformulas that
implies the proposition φ, the argument of the function. This
function has type $\PROP \to \NN \to PROP$, its definition is
 $\mysplit(φ,0) = φ$, and
for all$n\in \NN$, $n > 0$,

\begin{equation}
\label{eq:split-definition}
\mysplit(φ,n+1) =
\begin{cases}
\unshunt(\mysplit(φ₁,n)) ∧ \unshunt(φ₁ ⇒ \mysplit(φ₂,n)
  & φ := φ₁ ∧ φ₂,\\

\unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n))
  & φ := φ₁ ∨ φ₂,\\

\unshunt(φ₁ ⇒ \mysplit(φ₂,n))
  & φ := φ₁ ⇒ φ₂,\\

\unshunt(φ₁ ⇒ \mysplit(φ₂,n)) ∧ \unshunt(φ₂ ⇒ \mysplit(φ₁,n))
  & φ := φ₁ ⇔ φ₂,\\

\unshunt(φ₁ ⇒ \mysplit(¬ φ₂, n))
  & φ := ¬ (φ₁ ∧ φ₂),\\

\unshunt(\mysplit(¬ φ₁,n)) ∧ \unshunt(¬ φ₁ ⇒ \mysplit(¬ φ₂,n))
  & φ := ¬ (φ₁ ∨ φ₂),\\

\unshunt(\mysplit(φ₁,n)) ∧ \unshunt(φ₁ ⇒ \mysplit(¬ φ₂,n))
  & φ := ¬ (φ₁ ⇒ φ₂),\\

\unshunt(φ₁ ⇒ \mysplit(¬ φ₂,n)) ∧ \unshunt(¬ φ₂ ⇒ \mysplit(φ₁,n))
  & φ := ¬ (φ₁ ⇔ φ₂),\\

\unshunt(\mysplit(φ₁, n))
  & φ := ¬ ¬ φ₁,\\

⊤ & φ := ¬ ⊥,\\

⊥ & φ := ¬ ⊤.
\end{cases}
\end{equation}


\newcommand{\thmsplit}{\name{thm-split}}
\begin{theorem}[\thmsplit] $Γ ⊢ \mysplit(φ)$ then $Γ ⊢ φ$.
\end{theorem}

\begin{proof} We use induction on the structure of the formula
following the cases in the definition of \mysplit function.
We proceed to show some cases since the others are proved in a
similar way.\\[3mm]
(φ := φ₁ ∧ φ₂)
\begin{equation*}
\begin{bprooftree}
\AxiomC{$\mathcal{D}_1$}
\UnaryInfC{Γ ⊢ φ₁}

\AxiomC{$\mathcal{D}_1$}
\UnaryInfC{Γ ⊢ φ₁}

\AxiomC{$Γ ⊢ \mysplit(φ)$}
\RightLabel{By Def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁) ∧ \unshunt(φ₁ ⇒ \mysplit(φ₂))$}
\RightLabel{\tt $∧$-proj$₂$}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ \mysplit(φ₂))$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂)$}
\RightLabel{\tt $⇒$-elim}
\BinaryInfC{$Γ ⊢ \mysplit(φ₂)$}
\RightLabel{\thmsplit}
\UnaryInfC{$Γ ⊢ φ₂$}

\RightLabel{\tt ∧-intro}
\BinaryInfC{$Γ ⊢ φ₁ ∧ φ₂$}
\end{bprooftree}
\end{equation*}
where
\begin{equation*}
\mathcal{D}_1 =
\begin{bprooftree}
\AxiomC{$Γ ⊢ \mysplit(φ)$}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁) ∧ \unshunt(φ₁ ⇒ \mysplit(φ₂))$}
\RightLabel{\tt ∧-proj₁}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁)$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ φ₁$}
\end{bprooftree}
\end{equation*}


(φ := φ₁ ⇒ φ₂)
\begin{equation*}
\begin{bprooftree}
\AxiomC{}
\RightLabel{\tt assume φ₁}
\UnaryInfC{$Γ , φ₁ ⊢ φ₁$}
\AxiomC{$Γ ⊢ \mysplit(φ)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ \mysplit(φ₂))$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂)$}
\RightLabel{weaken φ₁}
\UnaryInfC{$Γ , φ₁ ⊢ φ₁ ⇒ \mysplit(φ₂)$}
\RightLabel{\tt ⇒-elim}
\BinaryInfC{$Γ , φ₁ ⊢ \mysplit(φ₂)$}
\RightLabel{\thmsplit}
\UnaryInfC{$Γ , φ₁ ⊢ φ₂$}
\RightLabel{\tt ⇒-intro}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
\end{bprooftree}
\end{equation*}


(φ := ¬ (φ₁ ∨ φ₂))
\begin{equation*}
\begin{bprooftree}
\AxiomC{$\mathcal{D}$}
\UnaryInfC{$Γ ⊢ ¬ φ₁$}

\AxiomC{$\mathcal{D}$}
\UnaryInfC{$Γ ⊢ ¬ φ₁$}

\AxiomC{$Γ ⊢ \mysplit(φ)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(¬ φ₁) ∧ \unshunt(¬ φ₁ ⇒ \mysplit(φ₂))$}
\RightLabel{\tt ∧-proj₂}
\UnaryInfC{$Γ ⊢ \unshunt(¬ φ₁ ⇒ \mysplit(φ₂))$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ ¬ φ₁ ⇒ \mysplit(φ₂)$}
\RightLabel{\tt ⇒-elim}
\BinaryInfC{$Γ ⊢ \mysplit(φ₂)$}
\RightLabel{\thmsplit}
\UnaryInfC{$Γ ⊢ ¬ φ₂$}
\RightLabel{\tt ∧-intro}
\BinaryInfC{$Γ ⊢ ¬ φ₁ ∧ ¬ φ₂$}
\RightLabel{\tt ¬∧¬-to-¬∨}
\UnaryInfC{$Γ ⊢ ¬ (φ₁ ∨ φ₂)$}
\end{bprooftree}
\end{equation*}
where
\begin{equation*}
\mathcal{D} =
\begin{bprooftree}
\AxiomC{$Γ ⊢ \mysplit(φ, n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(¬ φ₁) ∧ \unshunt(¬ φ₁ ⇒ \mysplit(φ₂, n))$}
\RightLabel{\tt ∧-proj₁}
\UnaryInfC{$Γ ⊢ \unshunt(¬ φ₁)$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ ¬ φ₁$}
\end{bprooftree}
\end{equation*}
% (φ := ¬ (φ₁ ⇔ φ₂))
% \begin{equation*}
% \begin{bprooftree}

% % -- right

% \AxiomC{$Γ ⊢ \mysplit(φ, n)$}
% \RightLabel{By def.}
% \UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ \mysplit(¬ φ₂)) ∧ \unshunt(¬ φ₂ ⇒ \mysplit(φ₁)) $}
% \RightLabel{\tt ∧-proj₂}
% \UnaryInfC{$Γ ⊢ \unshunt(¬ φ₂ ⇒ \mysplit(φ₁))$}
% \RightLabel{\tt \thmunshunt}
% \UnaryInfC{$Γ ⊢ ¬ φ₂ ⇒ \mysplit(φ₁)$}
% \RightLabel{\tt weaken ¬ φ₂}
% \UnaryInfC{$Γ , ¬ φ₂ ⊢ ¬ φ₂ ⇒ \mysplit(φ₁)$}

% % -- right

% % -- left
% \AxiomC{}
% \RightLabel{\tt assume (¬ φ₂)}
% \UnaryInfC{$Γ , ¬ φ₂ ⊢ ¬ φ₂$}
% \RightLabel{\tt ⇒-elim}

% \BinaryInfC{$Γ , ¬ φ₂ ⊢ \mysplit(φ₁)$}
% \RightLabel{\thmsplit}
% \UnaryInfC{$Γ , ¬ φ₂ ⊢ φ₁ $}
% \RightLabel{\tt ⇒-intro}
% \UnaryInfC{$Γ ⊢ ¬ φ₂ ⇒ φ₁$}
% % -- left

% % \RightLabel{\tt ∧-intro}
% % \BinaryInfC{$Γ ⊢ (φ₁ ⇒ ¬ φ₂) ∧ (¬ φ₂ ⇒ φ₁)$}
% % \RightLabel{\tt ⇒¬∧¬⇒-to-¬⇔}
% % \UnaryInfC{$Γ ⊢ ¬ (φ₁ ⇔ φ₂)$}
% \end{bprooftree}
% \end{equation*}

\end{proof}

The \mysplit function returns a conjunction of the subgoals.
From each \TSTP derivation, we actually have information of the
subgoals but it is not explicit how they appear in the conjunction.
For that reason, with \Athena, we infer the exact order in the
conjunction that coincides with the output by \mysplit.

\begin{theorem} For a list of subgoals $s_0, \cdots, s_1$ with their
respective theorem $Γ ⊢ s_i$, such that $\bigwedge_i s_i ⇒ \texttt{goal}$, then $Γ ⊢ \texttt{goal}$.
\end{theorem}

\emph{Resolve.}
\newcommand{\thmresolve}{\name{thm-resolve}}
The \resolve rule is a generalization version for resolution
in propositional logic since the formulas are not shaped always as
the theorem expect (see Fig.~\ref{fig:metis-inferences}).
Since our approach is mere syntactic, in order to apply such a
theorem, we perform rearrangements inside the formulas to match with
the pattern expected by the resolution theorem. If this strategy
fails at some point, we could not check the rest of the proof.

Therefore, the best scenario to apply resolution occurs when the
literal $l$ and its negation appear in the exact place in the
formulas as the resolve inference shows.

\begin{figure}
\[%\scalebox{0.9}{
\begin{bprooftree}
\AxiomC{$Γ ⊢ (φ₁ := l ∨ ψ₁)$}
\AxiomC{$Γ ⊢ (φ₂ := ¬ l ∨ ψ₂)$}
\RightLabel{\thmresolve}
\BinaryInfC{$Γ ⊢ \resolve(φ₁, φ₂, l, (ψ₁ ∧ ψ₂))$}
\UnaryInfC{Γ ⊢ ψ₁ ∨ ψ₂}
\end{bprooftree}
%}
\]
% \caption{Resolution in \Metis.}
\label{fig:thm-resolve-best-case}
\end{figure}

To rearrange the proposition in order to match with a specific
pattern of a formula, we define the following functions and provide
its respective theorems in \cite{AgdaMetis}.

\begin{itemize}
  \item[] \name{reorder-∨}
  \item[] \name{reorder-∧}
  \item[] \name{reorder-∧∨}
\end{itemize}

\begin{equation}
\resolve((φ₁, φ₂, l, ψ)

\begin{theorem}[\thmresolve] $Γ ⊢ φ₁$, $Γ ⊢ φ₂$,
then $Γ ⊢ \resolve(φ₁, φ₂, l, ψ)$ where $l$ is a literal,
and ψ is the expected result.
\end{theorem}

% \begin{proof}
% \begin{equation*}

% \end{equation*}
% \end{proof}




\emph{Clausification.}

\end{document}