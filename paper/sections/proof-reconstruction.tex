% -*- root: main.tex -*-
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Proof-Reconstruction}
\label{sec:proof-reconstruction}

\subsection{Workflow}
\label{ssec:workflow}

\begin{figure}
\centering

\begin{tikzpicture}[scale=0.9]
\node[text width=2cm, align=center](problem) at (0,0)
  {1. \CPL \\ Problem.};

\node[right = 1.1cm of problem, text width=2cm, align=center]
  (tptp){2. \TPTP \\ Problem.};

\node[right= 1.1cm of tptp, text width=2cm, align=center]
   (metis) {3. \Metis \\ Prover.};

\node[right= 1.1cm of metis, text width=2cm, align=center, inner sep=10pt]
   (tstp) {4. \TSTP \\ Derivation.};

\node[below= 0.5cm of tstp, text width=2cm, align=center, inner sep=10pt]
  (athena) {5. \Haskell \\ Translator.};

\node[left = 1.1cm of athena, text width=2cm, align=center]
   (agdafile) {6. \Agda \\ Proof.};

\node[left = 1.1cm of agdafile, text width=2cm, align=center]
   (agda) {7. Proof Checking.};

\node[below = 0.5cm of problem, text width=2cm, align=center]
   (verified) {8.1 Proof \\ Checked.};

\node[below = 0.5cm of verified, text width=2cm, align=center]
   (failure) {8.2 Failure.};

% node[below] {send to}
\draw[->, thick] (problem) to
  % node[below] {\tiny encoding}
  (tptp);
\draw[->, thick] (tptp) to
  % node[below] {\tiny }
  (metis);
\draw[->, thick] (metis) to
  % node[below] {\tiny replies on}
  (tstp);
\draw[->, thick] (tstp) to
  % node[right] {\tiny parsing}
  (athena);
\draw[->, thick] (athena) to
  % node[below] {\tiny traslation}
  (agdafile);
\draw[->, thick] (agdafile) to
  % node[below] {\tiny type-checking}
  (agda);
\draw[->, thick] (agda) to (verified);
\draw[->, thick, gray] (agda) to (failure);
\end{tikzpicture}
\caption{Proof-reconstruction overview.}
\label{fig:proof-reconstruction-workflow}
\end{figure}

The proof-reconstruction approach proposed here consists of a series
of steps similar to the workflow presented by \citeauthor{sultana2015} in
\cite{sultana2015}. This process is a translation from a source
system to a target system. In our case, the system of origin, the
automatic theorem prover, is \Metis; the target system is the proof
assistant, \Agda. We choose \Agda, but a proof assistant with
support of type theory and similar features like \Agda
(see a description of \Agda in Section
\ref{sec:implementation}) can be used.
Following the diagram in Fig.
\ref{fig:proof-reconstruction-workflow}, the process can begin with
a problem in \CPL that we encode in \TPTP format to be sent as the
input of the \Metis prover.
The algorithms of \Metis in step~3 intend to find
a solution; if they success, \Metis replies a derivation in \TSTP
format of the proof, else the problem is counter feasible.

With such a derivation, we process it with our \Haskell translator
tool, \Athena~\cite{Athena}.
\Athena parses the \TSTP format, analyze the
derivation and generates a representation of the natural deduction
proof using a version of a tree data structure (see the properties
of this tree in Subsection \ref{ssec:metis-proofs}). As a result,
\Athena generates an \Agda file with such a proof. We have included
in this file, \emph{imports} that call \Agda libraries that give
support for the logic~\cite{AgdaProp}, and versions of the \Metis'
inference rules~\cite{AgdaMetis}.

Finally, we use the proof assistant in step 7 to type-check the
proof and verify its correctness. Next, we only have one answer:
type-checking succeed (i.e., the proof is valid) or type-checking
failed.
If the type-check fails, one of the three actors in the process are
responsible: \Metis, \Athena, or \Agda. We are responsible for
errors committed in the translation from \TSTP to \Agda; lack of the
coverage of the \Metis' inference rules, or bad assumptions about
them. \improvement{Make this statement stronger and clear.}

In the rest of this section, we provide a formal description using
type theory to build definitions and theorems for the functions
necessary to emulate the \Metis' inference rules. We will write the
type judgments with ``$a : A$'' to denote that $a$ has type $A$.
For propositions, we will denote by $φ ≡ ψ$ the syntactic
equivalence.


% ...................................................................

\subsection{Small Structured Recursion}
\label{ssec:small-structured-recursion}

In the process to emulate \Metis' inference rules in type theory,
we encountered many recursive algorithms with termination problems,
that is,when an algorithm could run forever or we can not guarantee
that it will stop after some point. Such a problem makes impossible
to translate the algorithm in type theory directly.
For that reason, we show a technique that will help us to define
new algorithms based on the previous ones to solve the problem
mentioned.

A recursive function is a \emph{small-structured-recursion}, if the
size of the arguments with which it is defined decrease in
size for each call to the function in the definition~\cite{Bove2005}.
A well-structured function terminates and it can be translated
directly to type theory~\cite{Bove2002}.

Let us consider the following example from an inner function
in the \strip inference.

\begin{equation}
\label{eq:unshunt-definition}
\unshunt(φ)_{0} =
\begin{cases}
\unshunt_{0}((φ₁ ∧ φ₂) ⇒ φ₃)
  & φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃),\\

\unshunt_{0}(φ₁ ⇒ φ₂) ∧ \unshunt_{0}(φ₁ ⇒ φ₃)
  & φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃),\\

φ &\text{otherwise}.
\end{cases}
\end{equation}

From the definition above, in the first case of the \unshunt
function, the size of the argument in the recursion,(φ₁ ∧ φ₂) ⇒ φ₃,
is not structured smaller than the decrease, (φ₁ ⇒ (φ₂ ⇒ φ₃)).
Therefore, a termination checking will fail with the \unshunt
function.

To improve that definition for terminating, we will use the
technique proposed by Bove and Capettra in
\cite{Bove2005}, which in particular with functions that
transform propositions consists of:
take a general recursive function $f: \Prop \to \Prop$.
and a predicate $P: \Prop \to \abbre{Ind}$, where $\abbre{Ind}$
is a type with a structured inductive definition.

Then, we redefine the function as
$f: \Prop \to \abbre{Ind}\ \to \Prop$, and perform the recursion
using induction on the structure of the \abbre{Ind} type.

In our case, the \abbre{Nat} data type for
natural numbers will be the $\abbre{Ind}$ type.
We define \abbre{Nat} as usual (constructors \zero and \suc).
We also allow common arithmetic operations and numbers represented by
$0,1,2,\dots$ that stand for $\zero, \suc, \suc(\zero), \dots$.

Thus, we have a new function
$\unshunt_{1} : \Prop \to \Nat \to \Prop$
defined by structural recursion in its second argument in
Eq.~\ref{eq:unshunt-structured}.

\begin{align}
\label{eq:unshunt-structured}
\begin{split}
\unshunt_{1}(φ, \zero) &= φ\\
\unshunt_{1}(φ, \suc(n)) &=
\begin{cases}
\unshunt_{1}((φ₁ ∧ φ₂) ⇒ φ₃, n)
  & φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃),\\
\unshunt_{1}(φ₁ ⇒ φ₂, n)  & φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃).\\
∧\ \unshunt_{1}(φ₁ ⇒ φ₃, n)
\end{cases}
\end{split}
\end{align}

To feed the second argument of this new function, we will use
functions. For instance, we opted to use a complexity measure of
the formula that $\unshunt_{1}$ function transforms.


A \emph{complexity measure} defined in \cite{Agudelo-Agudelo2017}
and presented in \cite{VanDalen1994} as well as \emph{the rank for a
proposition} is a function with type
$\Prop \to \Nat$ that assigns a natural number to a
proposition φ as follows.

\begin{equation*}
\label{eq:rank-definition}
rank(φ)=
\begin{cases}
0 &\text{for atomic }φ, \\
rank(φ₁) + c_{¬}  & φ ≡ \neg φ₁, \\
\max{(rank(φ₁),rank(φ₂))} + c_{\square}
  & φ ≡ φ₁\,\square\, φ₂.
\end{cases}
\end{equation*}

where $c_{¬}$ or $c_{\square}$ is a non-negative integer called the
complexity of the connective.

We have already solved the terminating problem for the \unshunt
function in Eq.~\ref{eq:unshunt-structured}, nevertheless we do not
what natural number should be feed that argument in
order to maintain the same outputs as the original \unshunt does in
Eq.~\ref{eq:unshunt-definition}.

Therefore, we define an appropriate complexity measure
$\unshunt_{cm}: \Prop → \NN$
for the second argument of the $\unshunt_{1}$ function in
Eq.~\ref{eq:unshunt-rank-definition}.

\begin{equation}
\label{eq:unshunt-rank-definition}
\unshunt_{cm}(φ)=
\begin{cases}
\unshunt_{cm}(φ₃) + 2 & φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃),\\
\max(\unshunt_{cm}(φ₂),\unshunt_{cm}(φ₃)) + 1
  & φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃),\\
0 &\text{otherwise.}
\end{cases}
\end{equation}

Then, a curated version of the $\unshunt_{0}$ function is presented
in Eq.~\ref{eq:unshunt-fixed}.

\begin{equation}
\label{eq:unshunt-fixed}
\unshunt(\varphi) := \unshunt_{1}(\varphi, \unshunt_{cm}(\varphi)).
\end{equation}


% ................................................

\subsection{Emulating \Metis' Inference Rules}
\label{ssec:emulating-inferences}


\emph{Splitting a goal.}
The goal of a proof is processed by \Metis to generated new targets,
\Metis calls these new formulas \emph{subgoals}.
Then, \Metis proves each subgoal and with that it finishes the proof
of the goal.

Nevertheless, \Metis does not provide neither an explanation of this
process in its \TSTP derivations nor in its documentation.
We provide such a evidence that the process of creating subgoals,
and combining them in a final conjunction proves the original goal.

\begin{theorem}[\thmunshunt]
\label{thm:unshunt}
$Γ ⊢ \unshunt(φ)$, then $Γ ⊢ φ$.
\end{theorem}

\begin{proof} Use induction on the cases defined by the outcome of the $\unshunt$ function in Eq.~\ref{eq:unshunt-structured}.
When $n = 0$, by definition, $Γ ⊢ φ$.
When $n = 1$, we apply the following theorem presented in
\cite{AgdaProp}

\begin{equation*}
\texttt{∧⇒-to-⇒⇒}\ :\  Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃ → Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃).
\end{equation*}

For $n > 1$, we will use induction on the structure of second
argument.

(φ₁ ⇒ (φ₂ ⇒ φ₃))
\begin{equation*}
\begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n-1)$}
\RightLabel{\thmunshunt}
\UnaryInfC{Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃}
\RightLabel{∧⇒-to-⇒⇒}
\UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃).}
\end{bprooftree}
\end{equation*}

Second, using the following theorem from \cite{AgdaProp},

\begin{equation*}
\texttt{⇒∧-to-⇒∧}\ :\ Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃) → Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃).
\end{equation*}

(φ₁ ⇒ (φ₂ ∧ φ₃))
\begin{equation*}
\scalebox{0.95}{
($\mathcal{D}_1$)
\begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt(φ₁ ⇒ φ₂, n) ∧ \unshunt(φ₁ ⇒ φ₃, n)$}
\RightLabel{∧-proj₁}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ φ₂, n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ φ₂, n-1)$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$,}
\end{bprooftree}
}
\end{equation*}

\begin{equation*}
(\mathcal{D}_2)
\begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt(φ₁ ⇒ φ₂) ∧ \unshunt(φ₁ ⇒ φ₃)$}
\RightLabel{∧-proj₂}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ φ₃, n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ φ₃, n-1)$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₃$,}
\end{bprooftree}
\end{equation*}

\begin{equation*}
\begin{bprooftree}
\AxiomC{$\mathcal{D}_1$}
\AxiomC{$\mathcal{D}_2$}
\RightLabel{∧-intro}
\BinaryInfC{$Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃)$}
\RightLabel{⇒∧⇒-to-⇒∧}
\UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃).}
\end{bprooftree}
\end{equation*}
\end{proof}

Now, let us consider the \mysplit function that
yields the conjunction of subgoals from a proposition goal.

\begin{equation}
\label{eq:split-definition}
\mysplit(φ) =
\begin{cases}
\unshunt(\mysplit(φ₁))              & φ ≡ φ₁ ∧ φ₂,\\
∧\ \unshunt(φ₁ ⇒ \mysplit(φ₂))      &\\[2mm]

\unshunt(¬ φ₁ ⇒ \mysplit(φ₂))       & φ ≡ φ₁ ∨ φ₂,\\

\unshunt(φ₁ ⇒ \mysplit(φ₂))         & φ ≡ φ₁ ⇒ φ₂,\\

\unshunt(φ₁ ⇒ \mysplit(φ₂))         & φ ≡ φ₁ ⇔ φ₂,\\
∧\ \unshunt(φ₂ ⇒ \mysplit(φ₁))      &\\[2mm]

\unshunt(φ₁ ⇒ \mysplit(¬ φ₂))       & φ ≡ ¬ (φ₁ ∧ φ₂),\\

\unshunt(\mysplit(¬ φ₁))            & φ ≡ ¬ (φ₁ ∨ φ₂),\\
∧\ \unshunt(¬ φ₁ ⇒ \mysplit(¬ φ₂))  &\\[2mm]

\unshunt(\mysplit(φ₁))              & φ ≡ ¬ (φ₁ ⇒ φ₂),\\
∧\ \unshunt(φ₁ ⇒ \mysplit(¬ φ₂))    &\\[2mm]

\unshunt(φ₁ ⇒ \mysplit(¬ φ₂))       & φ ≡ ¬ (φ₁ ⇔ φ₂),\\
∧\ \unshunt(¬ φ₂ ⇒ \mysplit(φ₁))    &\\[2mm]

\unshunt(\mysplit(φ₁))              & φ ≡ ¬ ¬ φ₁,\\
⊤                                   & φ ≡ ¬ ⊥,\\
⊥                                   & φ ≡ ¬ ⊤.
\end{cases}
\end{equation}

We reformulate \mysplit function to match with the
new definition after apply the process described above in
Subsection~\ref{ssec:small-structured-recursion}, since
in the recursion calls of \mysplit in Eq.~\ref{eq:split-definition},
the negations, $(¬ φ_{1,2})$ raise a terminating problem.



\begin{theorem}[\thmsplit] $Γ ⊢ \mysplit(φ)$ then $Γ ⊢ φ$.
\end{theorem}

\begin{proof} We now proceed by induction on the structure of the
formula φ in the definition of Eq.~\ref{eq:split-definition}.
For a complete proof, we refer the reader to~\cite{AgdaMetis}.\\[3mm]

(φ ≡ φ₁ ∧ φ₂)
\begin{equation*}
\begin{bprooftree}
\AxiomC{$\mathcal{D}_1$}
\UnaryInfC{Γ ⊢ φ₁}

\AxiomC{$\mathcal{D}_1$}
\UnaryInfC{Γ ⊢ φ₁}

\AxiomC{$Γ ⊢ \mysplit(φ,n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁) ∧ \unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
\RightLabel{$∧$-proj$₂$}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
\RightLabel{$⇒$-elim}
\BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
\RightLabel{\thmsplit}
\UnaryInfC{$Γ ⊢ φ₂$}

\RightLabel{∧-intro}
\BinaryInfC{$Γ ⊢ φ₁ ∧ φ₂$.}
\end{bprooftree}
\end{equation*}
Where,
\begin{equation*}
(\mathcal{D}_1)\hspace{3mm}
\begin{bprooftree}
\AxiomC{$Γ ⊢ \mysplit(φ,n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁) ∧ \unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
\RightLabel{∧-proj₁}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁)$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ φ₁$.}
\end{bprooftree}
\end{equation*}


(φ ≡ φ₁ ⇒ φ₂)
\begin{equation*}
\begin{bprooftree}
\AxiomC{}
\RightLabel{assume φ₁}
\UnaryInfC{$Γ , φ₁ ⊢ φ₁$}
\AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
\RightLabel{weaken φ₁}
\UnaryInfC{$Γ , φ₁ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
\RightLabel{⇒-elim}
\BinaryInfC{$Γ , φ₁ ⊢ \mysplit(φ₂,n-1)$}
\RightLabel{\thmsplit}
\UnaryInfC{$Γ , φ₁ ⊢ φ₂$}
\RightLabel{⇒-intro}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$.}
\end{bprooftree}
\end{equation*}


(φ ≡ ¬ (φ₁ ∨ φ₂))
\begin{equation*}
\begin{bprooftree}
\AxiomC{$\mathcal{D}$}
\UnaryInfC{$Γ ⊢ ¬ φ₁$}

\AxiomC{$\mathcal{D}$}
\UnaryInfC{$Γ ⊢ ¬ φ₁$}

\AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(¬ φ₁) ∧ \unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
\RightLabel{∧-proj₂}
\UnaryInfC{$Γ ⊢ \unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ ¬ φ₁ ⇒ \mysplit(φ₂,n-1)$}
\RightLabel{⇒-elim}
\BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
\RightLabel{\thmsplit}
\UnaryInfC{$Γ ⊢ ¬ φ₂$}
\RightLabel{∧-intro}
\BinaryInfC{$Γ ⊢ ¬ φ₁ ∧ ¬ φ₂$}
\RightLabel{¬∧¬-to-¬∨}
\UnaryInfC{$Γ ⊢ ¬ (φ₁ ∨ φ₂)$.}
\end{bprooftree}
\end{equation*}

Where,

\begin{equation*}
(\mathcal{D})
\begin{bprooftree}
\AxiomC{$Γ ⊢ \mysplit(φ, n)$}
\RightLabel{By def.}
\UnaryInfC{$Γ ⊢ \unshunt(¬ φ₁) ∧ \unshunt(¬ φ₁ ⇒ \mysplit(φ₂, n))$}
\RightLabel{∧-proj₁}
\UnaryInfC{$Γ ⊢ \unshunt(¬ φ₁)$}
\RightLabel{\thmunshunt}
\UnaryInfC{$Γ ⊢ ¬ φ₁$.}
\end{bprooftree}
\end{equation*}
\end{proof}

\begin{theorem} If $s_i$ are the subgoals for the goal φ, and
$\{ Γ ⊢ s_i \}_{i}$, then $Γ ⊢ φ$.
\end{theorem}

\begin{proof}
\begin{equation*}
\begin{bprooftree}
\AxiomC{$\left\{ Γ ⊢ s_i \right\}_{i}$}
\RightLabel{∧-intro}
\UnaryInfC{$Γ ⊢ \bigwedge_i s_i$}

\AxiomC{$\mysplit(φ) ≡ \bigwedge_i s_i $}
\RightLabel{subst}
\BinaryInfC{$Γ ⊢ \mysplit(φ) $}

\RightLabel{\thmsplit}
\UnaryInfC{$Γ ⊢ φ$.}
\end{bprooftree}
\end{equation*}
Where,
\begin{equation*}
\begin{bprooftree}
\AxiomC{$Γ ⊢ φ$}   \AxiomC{$ψ ≡ φ$}
\RightLabel{subst}
\BinaryInfC{$Γ ⊢ ψ$.}
\end{bprooftree}
\end{equation*}
\end{proof}


\emph{Resolve.}

The \resolve rule is a generalization version for resolution
in propositional logic since the formulas are not shaped always as
the theorem expect (see Fig.~\ref{fig:metis-inferences}).
Since our approach is mere syntactic, in order to apply such a
theorem, we perform rearrangements inside the formulas to match with
the pattern expected by the resolution theorem. If this strategy
fails at some point, we could not check the rest of the proof.

Therefore, the best scenario to apply resolution occurs when the
literal $l$ and its negation appear in the exact place in the
formulas as the resolve inference shows.

\begin{figure}
\[%\scalebox{0.9}{
\begin{bprooftree}
\AxiomC{$Γ ⊢ (φ₁ ≡ l ∨ ψ₁)$}
\AxiomC{$Γ ⊢ (φ₂ ≡ ¬ l ∨ ψ₂)$}
\RightLabel{\thmresolve}
\BinaryInfC{$Γ ⊢ \resolve(φ₁, φ₂, l, (ψ₁ ∧ ψ₂))$}
\UnaryInfC{Γ ⊢ ψ₁ ∨ ψ₂}
\end{bprooftree}
%}
\]
% \caption{Resolution in \Metis.}
\label{fig:thm-resolve-best-case}
\end{figure}

To rearrange the propositions in order to match with a specific
pattern for applying a particular theorem like resolution, we have
define the following functions and provide
its respective theorems in \cite{AgdaMetis}.
These rearrangement functions are mainly inspired in
\cite{bohme2010}, for their treatment for conjunction and
disjunction equivalence.

\improvement{provide examples for each of the following functions.}

\begin{itemize}
  \item \name{reorder-∨.} Given two formulas, φ and ψ, both disjunctions, fix the order of the first one by following the syntactically
  order of the second one. If the process succeed (denote by φ ⤳ ψ),
  returns the target formula, ψ, otherwise, keep the first one, φ.
  \begin{align}
  \begin{split}
&\name{reorder-∨}\ :\ \Prop \to \Prop \to \Prop\\
&\name{reorder-∨}(φ, ψ) =
  \begin{cases}
  ψ   & φ ⤳ ψ\\
  ϕ   & \text{otherwise.}
  \end{cases}
  \end{split}
  \end{align}

  \item \name{reorder-∧.} Given two formulas, φ and ψ, both conjunctions, fix the order of the first one by following the order  of the second one.
  \item \name{reorder-∧∨.} Given two formulas, φ and ψ, both in CNF, fix the order of the first one by following the order  of the second one.
\end{itemize}

\begin{equation}
\resolve((φ₁, φ₂, l, ψ)
\end{equation}

\begin{theorem}[\thmresolve] $Γ ⊢ φ₁$, $Γ ⊢ φ₂$,
then $Γ ⊢ \resolve(φ₁, φ₂, l, ψ)$ where $l$ is a literal,
and ψ is the expected result.
\end{theorem}

% \begin{proof}
% \begin{equation*}

% \end{equation*}
% \end{proof}

\emph{Clausification.}

\end{document}