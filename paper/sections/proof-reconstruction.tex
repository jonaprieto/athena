
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Proof-Reconstruction}
\label{sec:proof-reconstruction}

\subsection{Workflow}
\label{ssec:workflow}

\input{sections/diagram.tex}

The proof-reconstruction approach proposed here consists of a series
of steps similar to the workflow presented by \citeauthor{sultana2015} in
\cite{sultana2015}. This process is a translation from a source
system to a target system. In our case, the system of origin, the
automatic theorem prover, is \Metis; the target system is a proof
assistant, \Agda. We choose \Agda, but another proof assistant with the same support of type theory and inductive types is valid.
%  (see a description of \Agda for its main features in
% Section~\ref{sec:implementation}).
The overview of the proof-reconstruction is presented in
Fig.~\ref{fig:proof-reconstruction-workflow}, the process begin with
a \TPTP file that encodes a problem in \CPL. We use this file as the
input of the \Metis prover and if the problem is a theorem, \Metis can reply with a derivation in \TSTP format of the proof.

With the \TSTP  derivation from the Step~2, we process the derivation with the \Athena translator tool~\cite{Athena}.
\Athena parses the \TSTP format, analyzes the
derivation and generates a representation of the natural deduction
proof using a tree data structure (see the properties
of this tree in Section~\ref{sssec:metis-proofs}).
We perform an analysis of the proof-tree to remove some
unnecessary steps that introduce redundancies or unused input for
\Athena.

As a result of using \Athena, we get an \Agda file, the proof-term. To generate this file, \Athena has used names of functions and theorems from \Agda libraries:
\texttt{agda-prop}~\cite{AgdaProp}, and \texttt{agda-metis}~\cite{AgdaMetis}.


Finally, we type-check the \Agda proof-term. If type-checking
succeed, the \TSTP derivation delivered by \Metis was correct.
In that case \Agda outputs an interface file.
Otherwise, when type-checking fails, the failure must be
investigated by the user, checking for the error in \Metis, \Athena,
or in \Agda.

In the rest of this section, we provide a formal description using
type theory to build definitions and theorems for functions
necessary to emulate \Metis' inference rules. For this description,
we will write the type judgments with ``$a : A$'' to denote that $a$
has $\abbre{A}$ type. Types are written using small caps.
We use \Prop type for propositions and the dependent type, $Γ ⊢ φ$ for theorems. In the latter type, $Γ$ has $\abbre{List}~\Prop$ type
and $φ$ has type $\Prop$. $\abbre{List}$ is the usual inductive type
for lists. Finally, we will denote by $φ ≡ ψ$, the syntactic
equivalence between propositions.

% ...................................................................

% section section_name (end)
\subsection{Structural Recursion}
\label{ssec:structural-recursion}

To emulate \Metis' inference rules in type theory,
we observed that transformations performed by some rules were given by \emph{general recursive} functions.
But algorithms based on general recursions can not be translated
directly in type theory since it is not a guarantee they terminate.
For that reason, we present in this section, a technique to avoid
such termination problems by modifying the recursive functions
to be \emph{structural recursive}.
% (see \cite{Coquand1992,Abel2002,Bove2005} for more details).

We adopt the notion of \emph{structurally smaller} from
\citeauthor{Abel2002}~\cite{Abel2002} to say, a recursive function is
structurally recursive if it calls itself with only
\emph{structurally smaller}
arguments.

General recursive calls can be translated into structurally recursive
calls by using for instance, the \emph{Bounded Recursion} technique
presented in~\cite{Bertot2004}. For a yet another method, we refer
the reader to \cite{Coquand1992,Abel2002,Bove2005}.
The former technique defines a new function based on the original
recursive function by adding an additional argument to the function.
The new argument is the \emph{bound}, a natural number given by the
function complexity. In other words, the added argument will store
the number of times the function needs to call itself to get the
expected outcome.

Henceforth, a natural number has \Nat type, and it is defined as
usual. That is, \zero and \suc are the data constructors and some
arithmetic operations are defined: ($+,\,-,\,*$). We include syntax
sugar for $\zero$, $\suc$, $\suc(\zero)$, $\cdots$, with the
classical representation: $1$, $2$, $\cdots$ as well.

Therefore, for a general recursive function $f: \Prop \to \Prop$
with termination problems, we states a new function $f^{*} : \Prop \to \Nat \to \Prop$ where all recursive calls must done by
using induction on the \Nat type structure.

\subsubsection*{A Practical Example.}
Let us consider the following example to exhibit the technique
mentioned above for an inner function present in the emulated version
of the \strip inference.

\begin{align}
\begin{split}
\label{eq:unshunt-definition}
&unshunt_{0}(φ) =\\
&\hspace{3mm}\begin{cases}
unshunt_{0}((φ₁ ∧ φ₂) ⇒ φ₃),
  & \text{if }φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\
unshunt_{0}(φ₁ ⇒ φ₂) ∧ unshunt_{0}(φ₁ ⇒ φ₃),
  & \text{if }φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃)\\
φ, &\text{otherwise.}
\end{cases}
\end{split}
\end{align}

From the definition above, the size of the argument, $((φ₁ ∧ φ₂) ⇒ φ₃)$,
is not structurally smaller than the input formula, $(φ₁ ⇒ (φ₂ ⇒ φ₃))$,
since $((φ₁ ∧ φ₂) ⇒ φ₃)$ is not a subformula of $(φ₁ ⇒ (φ₂ ⇒ φ₃))$.

Thus, we define the function
$unshunt_{1} : \Prop \to \Nat \to \Prop$
by structural recursion in its second argument in
Eq.~(\ref{eq:unshunt-structured}).

\begin{align}
\label{eq:unshunt-structured}
\begin{split}
&unshunt_{1}(φ, \zero)\hspace{3mm}= φ\\
&unshunt_{1}(φ, \suc(n)) =\\
&\hspace{3mm}\begin{cases}
unshunt_{1}((φ₁ ∧ φ₂) ⇒ φ₃, n),
  &\text{if } φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\[2mm]
unshunt_{1}(φ₁ ⇒ φ₂, n)\\
∧\ unshunt_{1}(φ₁ ⇒ φ₃, n),
   &\text{if } φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃).
\end{cases}
\end{split}
\end{align}

As we mentioned above, the natural number in the second argument of
the function used in Eq.~(\ref{eq:unshunt-structured}) stands for a
complexity measure of the function, in this case $unshunt_{1}$ function.

Recall, the \emph{complexity measure} defined in \cite{Agudelo-Agudelo2017}
and presented in \cite{VanDalen1994} as \emph{the rank for a
proposition}, is a function $\Prop \to \Nat$ that assigns a natural
number for a proposition $φ$ like the following $rank$ function.
The symbols, $c_{¬}$ and $c_{\square}$ is a non-negative integer
number called the complexity of the connective.

\begin{equation*}
\label{eq:rank-definition}
rank(φ)=
\begin{cases}
0, &\text{for atomic }φ \\
rank(φ₁) + c_{¬},  &\text{if } φ ≡ \neg φ₁ \\
\max{(rank(φ₁),rank(φ₂))} + c_{\square},
  &\text{if } φ ≡ φ₁\,\square\, φ₂.
\end{cases}
\end{equation*}

In the case of the $unshunt_0$ function in
Eq.~(\ref{eq:unshunt-definition}), we define the complexity function
$unshunt_{cm}: \Prop → \NN$ for our $unshunt_{1}$
presented in Eq.~(\ref{eq:unshunt-rank-definition}).

\begin{align}
\begin{split}
\label{eq:unshunt-rank-definition}
&unshunt_{cm}(φ) =\\
&\hspace{3mm}
\begin{cases}
unshunt_{cm}(φ₃) + 2, &\text{if }φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\
\max(unshunt_{cm}(φ₂),unshunt_{cm}(φ₃)) + 1,
  &\text{if }  φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃)\\
0, &\text{otherwise.}
\end{cases}
\end{split}
\end{align}

Finally, following the technique mentioned, we get a curated version of
$unshunt_{0}$ function presented in the following definition.

\begin{definition}[unshunt]
\label{def:unshunt}
  \begin{align*}
    \begin{split}
    &unshunt : \Prop → \Prop\\
    &unshunt(\varphi) = unshunt_{1}(\varphi, unshunt_{cm}(\varphi)).
    \end{split}
  \end{align*}
\end{definition}

For a more complete treatment of general recursion, and how to
define well-founded and well-structural recursive functions, we refer
the reader to Ref.~\cite{Bove2005}, where Bove and Capettra described
not only general recursion, but they also treat mutual recursive
function, among other kinds.

% % ................................................

\subsection{Emulating \Metis' Inference Rules}
\label{ssec:emulating-inferences}

In this section, we emulate each \Metis inference rule by proving a
function with the same name, and a theorem that
proves the soundness of the function. Then, we will find
the following pattern to present the formalization for
the \Metis inference rules.

\begin{itemize}
\item \texttt{rule} is a \Metis inference rule
\item $rule$ is the emulated version function for
the \texttt{rule} inference.
\begin{align*}
\begin{split}
&rule : \Prop → \Prop → \Prop\\
&rule(φ, ψ) =
  \begin{cases}
  ψ, &\text{if }rule\text{ built }ψ\text{ by applying valid transformations to }φ\\
  φ, &\text{otherwise.}
  \end{cases}
\end{split}
\end{align*}

\begin{itemize}
  \item $φ$ is the \emph{source} formula.
  \item $ψ$ is the \emph{target} formula.
\end{itemize}
\item thm-rule is the theorem, $Γ ⊢ rule(φ, ψ)$, that proves
the soundness of the $rule$ function.
\end{itemize}

\subsubsection{Stripping a Goal.}
\label{sssec:strip-a-goal}

To prove a goal, \Metis splits the goal into
disjoint cases. This process produces a list of new subgoals, the
conjunction of these subgoals implies the goal. Then, a proof of the
goal becomes in smaller proofs, one refutation for each subgoal.
These subgoals are introduced in the \TSTP derivation with the \strip
inference rule as we show with the following excerpt.

\begin{verbatim}
fof(goal, conjecture, p & r & q).
fof(subgoal_0, plain, p,
    inference(strip, [], [goal])).
fof(subgoal_1, plain, p => r,
    inference(strip, [], [goal])).
fof(subgoal_2, plain, (p & r) => q,
    inference(strip, [], [goal])).
\end{verbatim}

To prove the correctness of the process mentioned above, we state
the Theorem~\ref{thm:thm-strip}. But first, let us prove some
lemmas for $unshunt$ function presented in Def.~(\ref{def:unshunt}),
and for $split$ function presented in Eq.~(\ref{eq:split-definition}).

\begin{lemma}[lem-unshunt]
  \label{lem:unshunt}
  $Γ ⊢ unshunt(φ)$, then $Γ ⊢ φ$.
\end{lemma}

\begin{sketchproof} Use induction on the cases defined by the outcome of the
$unshunt$ function in Eq.~(\ref{eq:unshunt-structured}).
\begin{itemize}
	\item If $n = 0$, by definition we conclude $Γ ⊢ φ$.
	\item If $n = 1$, we apply the following theorem proved in~\cite{AgdaProp},
		\begin{equation*}
		\texttt{∧⇒-to-⇒⇒}\ :\  Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃ → Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃).
		\end{equation*}
  \item For $n > 1$, we will use induction on the structure of the second
			  argument.
\begin{itemize}
\item $(φ₁ ⇒ (φ₂ ⇒ φ₃))$
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n-1)$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃}
  \RightLabel{∧⇒-to-⇒⇒.}
  \UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃)}
  \end{bprooftree}
\end{equation*}

\item $(φ₁ ⇒ (φ₂ ∧ φ₃))$
\begin{equation*}
  \scalebox{0.95}{
  ($\mathcal{D}_1$)
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n) ∧ unshunt(φ₁ ⇒ φ₃, n)$}
    \RightLabel{∧-proj₁}
    \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n)$}
    \RightLabel{axiom}
    \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n-1)$}
    \RightLabel{lem-unshunt,}
    \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
  \end{bprooftree}
  }
\end{equation*}

\begin{equation*}
  (\mathcal{D}_2)
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂) ∧ unshunt(φ₁ ⇒ φ₃)$}
    \RightLabel{∧-proj₂}
    \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₃, n)$}
    \RightLabel{axiom}
    \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₃, n-1)$}
    \RightLabel{lem-unshunt.}
    \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₃$}
    \end{bprooftree}
\end{equation*}

Finally, using the theorem \texttt{⇒∧⇒-to-⇒∧} from~\cite{AgdaProp},
\begin{equation*}
  \texttt{⇒∧⇒-to-⇒∧}\ :\ Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃) → Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃),
\end{equation*}
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}_1$}
  \AxiomC{$\mathcal{D}_2$}
  \RightLabel{∧-intro}
  \BinaryInfC{$Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃)$}
  \RightLabel{\tt ⇒∧⇒-to-⇒∧.}
  \UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃)}
  \end{bprooftree}
\end{equation*}
\item Other cases are proved in a similar way.
\end{itemize}
\end{itemize}
\end{sketchproof}

Let us now consider the $split$ function presented in
Eq.~(\ref{eq:split-definition}) that yields the conjunction of subgoals that implies the goal of the problem in the \Metis \TSTP derivations.

\begin{definition}[split]
\label{def:split}

\begin{equation}
\label{eq:split-definition}
\begin{split}
&split : \Prop → \Prop\\
&\mysplit(φ) =
\begin{cases}
unshunt(\mysplit(φ₁)) &\text{if }φ ≡ φ₁ ∧ φ₂\\
∧\ unshunt(φ₁ ⇒ \mysplit(φ₂)), &\\[2.5mm]
unshunt(¬ φ₁ ⇒ \mysplit(φ₂)),
  & \text{if }φ ≡ φ₁ ∨ φ₂\\[2.5mm]
unshunt(φ₁ ⇒ \mysplit(φ₂)),
  & \text{if }φ ≡ φ₁ ⇒ φ₂\\[2.5mm]
unshunt(φ₁ ⇒ \mysplit(φ₂))
  & \text{if }φ ≡ φ₁ ⇔ φ₂\\
∧\ unshunt(φ₂ ⇒ \mysplit(φ₁)),
  &\\[2.5mm]
unshunt(φ₁ ⇒ \mysplit(¬ φ₂)),
  & \text{if }φ ≡ ¬ (φ₁ ∧ φ₂)\\[2.5mm]
unshunt(\mysplit(¬ φ₁))
  & \text{if }φ ≡ ¬ (φ₁ ∨ φ₂)\\
∧\ unshunt(¬ φ₁ ⇒ \mysplit(¬ φ₂)),
  &\\[2.5mm]
unshunt(\mysplit(φ₁))
  & \text{if }φ ≡ ¬ (φ₁ ⇒ φ₂)\\
∧\ unshunt(φ₁ ⇒ \mysplit(¬ φ₂)),
  &\\[2.5mm]
unshunt(φ₁ ⇒ \mysplit(¬ φ₂))
  & \text{if }φ ≡ ¬ (φ₁ ⇔ φ₂)\\
∧\ unshunt(¬ φ₂ ⇒ \mysplit(φ₁)),
  &\\[2.5mm]
unshunt(\mysplit(φ₁)),
  & \text{if }φ ≡ ¬ ¬ φ₁\\
⊤,
  & \text{if }φ ≡ ¬ ⊥\\
⊥,
  & \text{if }φ ≡ ¬ ⊤.
\end{cases}
\end{split}
\end{equation}
\end{definition}

The definition above suffers termination problems since it is not
a structural recursion. Therefore, we have reformulated the equation
above to solve such a issue following the technique
described in Section~\ref{ssec:structural-recursion}. We refer to $split$
as the function after applying the process mentioned above here and below
unless otherwise stated.

\begin{lemma}[\thmsplit] $Γ ⊢ \mysplit(φ)$ then $Γ ⊢ φ$.
\label{lem:lem-split}
\end{lemma}

\begin{sketchproof}
We now proceed by induction on the structure of the
formula $φ$ by following the cases defined in
Eq.~(\ref{eq:split-definition}).
We present some cases but for a complete proof, we refer the reader to~\cite{AgdaMetis}.
\begin{itemize}
\item $(φ ≡ ¬ ¬ φ₁)$
%Using the double negation equivalence, we conclude.
\begin{equation*}
  \begin{bprooftree}
 \AxiomC{$Γ ⊢ \mysplit(φ,n)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(split(¬¬φ₁,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢split(¬¬φ₁,n-1)$}
  \RightLabel{\thmsplit}
  \UnaryInfC{$Γ ⊢ ¬¬φ₁$}
  \RightLabel{axiom.}
  \UnaryInfC{$Γ ⊢ φ$}
  \end{bprooftree}
\end{equation*}

\item $(φ ≡ φ₁ ∧ φ₂)$. We get a proof for each conjunct and using the introduction rule for conjunction connective, the result follows.

\begin{equation*}
(\mathcal{D})\hspace{3mm}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ \mysplit(φ,n)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁) ∧ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{∧-proj₁}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁)$}
  \RightLabel{lem-unshunt.}
  \UnaryInfC{$Γ ⊢ φ₁$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}$}
  \UnaryInfC{Γ ⊢ φ₁}
  \AxiomC{$Γ ⊢ \mysplit(φ,n)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁) ∧ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{$∧$-proj$₂$}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{$⇒$-elim}
  \BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
  \RightLabel{\thmsplit.}
  \UnaryInfC{$Γ ⊢ φ₂$}
  \end{bprooftree}
\end{equation*}

\item $(φ ≡ φ₁ ⇒ φ₂)$
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{}
  \RightLabel{assume φ₁}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁$}
  \AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{weaken φ₁}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{⇒-elim}
  \BinaryInfC{$Γ , φ₁ ⊢ \mysplit(φ₂,n-1)$}
  \RightLabel{\thmsplit}
  \UnaryInfC{$Γ , φ₁ ⊢ φ₂$}
  \RightLabel{⇒-intro.}
  \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
  \end{bprooftree}
\end{equation*}

\item $(φ ≡ ¬ (φ₁ ∨ φ₂))$. We show that $Γ ⊢ ¬ φ₁$ and $Γ ⊢ ¬ φ₂$.
The result follows by introducing the conjunction and applying after
De Morgan Law.

\begin{equation*}
(\mathcal{D})\hspace{3mm}
\begin{bprooftree}
\AxiomC{$Γ ⊢ \mysplit(φ, n)$}
\RightLabel{axiom}
\UnaryInfC{$Γ ⊢ unshunt(¬ φ₁) ∧ unshunt(¬ φ₁ ⇒ \mysplit(φ₂, n))$}
\RightLabel{∧-proj₁}
\UnaryInfC{$Γ ⊢ unshunt(¬ φ₁)$}
\RightLabel{lem-unshunt,}
\UnaryInfC{$Γ ⊢ ¬ φ₁$}
\end{bprooftree}
\end{equation*}
\end{itemize}
\end{sketchproof}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\mathcal{D}$}
  \UnaryInfC{$Γ ⊢ ¬ φ₁$}

  \AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
  \RightLabel{axiom}
  \UnaryInfC{$Γ ⊢ unshunt(¬ φ₁) ∧ unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{∧-proj₂}
  \UnaryInfC{$Γ ⊢ unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
  \RightLabel{lem-unshunt}
  \UnaryInfC{$Γ ⊢ ¬ φ₁ ⇒ \mysplit(φ₂,n-1)$}
  \RightLabel{⇒-elim}
  \BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
  \RightLabel{\thmsplit.}
  \UnaryInfC{$Γ ⊢ ¬ φ₂$}
  \end{bprooftree}
\end{equation*}

\begin{lemma}[subst]
  \label{lem:subst}
  Substitution theorem.
\begin{equation}
  \label{eq:substitution-theorem}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ φ$}   \AxiomC{$ψ ≡ φ$}
  \RightLabel{subst.}
  \BinaryInfC{$Γ ⊢ ψ$}
  \end{bprooftree}
\end{equation}
\end{lemma}

\begin{theorem}[thm-strip]
\label{thm:thm-strip}
 If $s_i$ are the subgoals of the goal $φ$, and
 $\{ Γ ⊢ s_i \}_{i}$, then $Γ ⊢ φ$.
\end{theorem}

\begin{proof}
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$\left\{ Γ ⊢ s_i \right\}_{i}$}
  \RightLabel{∧-intro}
  \UnaryInfC{$Γ ⊢ \bigwedge_i s_i$}

  \AxiomC{$\mysplit(φ) ≡ \bigwedge_i s_i $}
  \RightLabel{subst}
  \BinaryInfC{$Γ ⊢ \mysplit(φ)$}
  \RightLabel{\thmsplit.}
  \UnaryInfC{$Γ ⊢ φ$}
\end{bprooftree}
\end{equation*}
\end{proof}

% -------------------------------------------------------------------

\subsubsection{Negating Subgoals.}

Each proof of a subgoal is a refutation, thereby each proof assumes
the negation of its subgoal. The \negate rule
assumes the negation of such subgoals. This rules always
appears after apply the \strip inference to the goal.

\begin{verbatim}
fof(goal, conjecture, (p & q)).
fof(subgoal_0, plain, (p), inference(strip, [], [goal])).
fof(subgoal_1, plain, (p => q), inference(strip, [], [goal])).
fof(negate_0_0, plain, (~ p), inference(negate, [], [subgoal_0])).
\end{verbatim}

Then, to emulate this rule, we just introduce the negation
of the subgoal by using the assume rule from the inferences in
Fig.~\ref{fig:CPL-inference-rules}.

% -------------------------------------------------------------------
\subsubsection{Splitting a Conjunct.}
\label{sssec:splitting-a-conjunct}

The \conjunct rule extracts from a
conjunction one of its conjuncts; it is a generalization of the
projection rules for the conjunction connective as the
following \TSTP excerpt shows.

\begin{verbatim}
fof(normalize_1, plain, p & q & (r | ~ p),
  inference(canonicalize, [], [x])).
fof(normalize_2, plain, q,
  inference(conjunct, [], [normalize_1])).
fof(normalize_2, plain, (r | ~ p),
  inference(conjunct, [], [normalize_1])).
\end{verbatim}

\begin{definition}[conjunct]
\begin{align}
  \begin{split}
  &conjunct : \Prop \to \Prop \to \Prop\\
  &conjunct(φ, ψ) =\\
  &\hspace{3mm}
  \begin{cases}
      ψ, &\text{if }φ ≡ ψ\\
      ψ, &\text{if }φ ≡ φ₁ ∧ φ₁\text{ and }ψ ≡ conjunct(φ₁, ψ)\\
      ψ, &\text{if }φ ≡ φ₁ ∧ φ₁\text{ and }ψ ≡ conjunct(φ₂, ψ)\\
      φ, &\text{otherwise.}
    \end{cases}
  \end{split}
\end{align}
\end{definition}

\begin{theorem}[thm-conjunct]
  \label{thm:thm-conjunct}
  $Γ ⊢ φ$, and $ψ  : \Prop$ , then $Γ ⊢ conjunct(φ, ψ)$.
\end{theorem}
\begin{proof}\hspace{2cm}
\begin{itemize}
  \item For the case, $φ ≡ ψ$, $Γ ⊢ conjunct(φ, ψ)$ normalizes to $Γ ⊢ ψ$.
Then, we get the desire conclusion by applying the $subst$ theorem.
  \item If the proposition $φ$ is a conjunction, and we can get $ψ ≡ conjunct(φ_{i}, ψ)$ for some $i = 1,\ 2$, then,

\begin{equation}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ φ₁ ∧ φ₂$}
  \RightLabel{∧-proj$_{i}$}
  \UnaryInfC{$Γ ⊢ φ_{i}$}
  \UnaryInfC{$Γ ⊢ conjunct(φ_{i}, ψ)$}
  \AxiomC{$ψ ≡ conjunct(φ_{i}, ψ)$}
  \RightLabel{subst.}
  \BinaryInfC{$Γ ⊢ ψ$}
  \end{bprooftree}
\end{equation}
\item The last case follows trivially by using the same hypothesis.
\end{itemize}
\end{proof}

% subsubsection splitting-a-conjunct (end)
% -------------------------------------------------------------------

% ------------------------------------------------------------------------

\subsubsection{Reordering.}
Logic equivalence between propositions is a major issue to justify
prover reasoning steps. Since we left out semantics to treat only the
syntax aspects of the propositions, our approach shows that equivalence
by converting propositions to their conjunctive normal forms and showing equivalence by reordering the conjunctions and the inner disjunctions.
In this section, we provide some theorems to perform such reordering tasks, the goals are the following.

\begin{itemize}
  \item Reorder the disjunction $φ = φ₁ ∨ φ₂ ∨ \cdots φₙ$ to match with $ψ = ψ₁ ∨ ψ₂ ∨ \cdots ∨ ψₙ$, when for all $i = 1, \cdots, n$, exists at least one $ψⱼ$ such that $φᵢ ≡ ψⱼ$ for $j = 1, \cdots, n$.
  \item Reorder a CNF formula, $φ = φ₁ ∧ φ₂ ∧ \cdots$, to match with another CNF formula $ψ = ψ₁ ∧ ψ₂ ∧ \cdots$ when for all $i = 1, \cdots, n$, exists at least one $ψⱼ$ such that $φᵢ ≡ ψⱼ$ for $j = 1, \cdots, n$.
\end{itemize}

First, we define the $rdisj$ function in Eq.~(\ref{eq:rdisj-def}) to convert a disjunction in its right-associative form.

\begin{definition}[rdisj]
\label{def:rdisj}
\begin{align}
  \begin{split}
  \label{eq:rdisj-def}
    &rdisj(φ) : \Prop \to \Prop\\
    &rdisj(φ) =
    \begin{cases}
    rdisj(φ₁ ∨ (φ₂ ∨ φ₃)),  & \text{if } φ ≡ (φ₁ ∨ φ₂) ∨ φ₃\\
    φ₁ ∨ rdisj(φ₂),         & \text{if } φ ≡ φ₁ ∨ φ₂\\
    φ,                      & \text{otherwise.}
    \end{cases}
  \end{split}
\end{align}
\end{definition}

\begin{lemma}[lem-rdisj]
\label{lem:lem-rdisj}
  $Γ ⊢ φ$ then $Γ ⊢ rdisj(φ)$.
\end{lemma}
% Following a similar way to define $rdisj$, we define the $rconj$ function,
% to convert a conjunction into its right-associative form.

The $build_{∨}$ function in Eq.~(\ref{eq:build-or}) intends to construct a disjunction from another disjunction, specifically, this functions will try to rearrange the disjuncts in the source formula to match with the target disjunction formula, similar as we described above.

\begin{definition}[build$_{∨}$]
\begin{equation}
  \begin{split}
  \label{eq:build-or}
  &build_{∨} : \Prop → \Prop → \Prop\\
  &build_{∨}(φ, ψ) =\\
  &\hspace{3mm}
  \begin{cases}
  ψ, &\text{if } φ ≡ ψ\\
  ψ, &\text{if } ψ ≡ ψ₁ ∨ ψ₂\text{ and } build_{∨}(φ, ψ_{i}) ≡ ψ_{i}\text{ for some }i=1, 2\\
  φ, &\text{otherwise.}
  \end{cases}
  \end{split}
\end{equation}
\end{definition}

\begin{lemma}[lem-build$_{∨}$]
\label{lem:lem-build-or}
$Γ ⊢ φ$, and $ψ : \Prop$ then $Γ ⊢ build_{∨}(φ)$.
\end{lemma}

From now, we assume all propositions are right-associative unless otherwise stated. The $factor$ function in
Eq.~(\ref{eq:factor-definition}) intends to simplify a special case of disjunction, the repeated disjuncts (e.g., $factor(φ ∨ φ) \mapsto\ φ$).
Notice that other cases like $φ ∨ (ψ ∨ φ)$ do no reduce to $(ψ ∨ φ)$.

\begin{definition}[factor]
\begin{align}
\begin{split}
  \label{eq:factor-definition}
  &factor : \Prop → \Prop\\
  &factor(φ) =
  \begin{cases}
    φ₁,  &\text{if }φ ≡ φ₁ ∨ φ₂ \text{ and } φ₁ ≡ factor(φ₂)\\
    φ,   &\text{otherwise.}
  \end{cases}
\end{split}
\end{align}
\end{definition}

\begin{lemma}[lem-factor]
\label{lem:lem-factor}
  $Γ ⊢ φ$ then $Γ ⊢ factor(φ)$.
\end{lemma}

To construct a disjunction $ψ$ from another disjunction $φ$, we have used ideas from the description in \citeauthor{bohme2010}~\cite{bohme2010} to prove equality between nested disjunctions. The result is the
$sbuild_{∨}$ function that uses every disjunct from the source formula, $φ$, to build up the target disjunction $ψ$.

\begin{definition}[sbuild$_{∨}$]
\begin{align}
  \begin{split}
  \label{eq:strong-build-or-definition}
    &sbuild_{∨} : \Prop → \Prop → \Prop\\
    &sbuild_{∨}(φ, ψ) =\\
    &\hspace{3mm}
    \begin{cases}
      factor(build_{∨}(φ₁, ψ) ∨ build_{∨}(φ₂,ψ)),  &\text{if }φ≡ φ₁ ∨ φ₂\\
      build_{∨}(φ, ψ),  & \text{otherwise.}
    \end{cases}
  \end{split}
\end{align}
\end{definition}

\begin{lemma}[lem-sbuild$_{∨}$]
\label{lem:lem-sbuild-or}
$Γ ⊢ φ$, and $ψ : \Prop$ then $Γ ⊢ sbuild_{∨}(φ, ψ)$.
\end{lemma}

\begin{example}
Let see the main idea behind the lem-sbuild$_{∨}$ lemma.
We will build the disjunction $((p ∨ q) ∨ r)$ from the disjunction
$(r ∨ (q ∨ p))$.
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ q$}
  \RightLabel{∨-intro₂}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \AxiomC{$Γ ⊢ p$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \RightLabel{∨-intro₁}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \RightLabel{∨-elim}
  \BinaryInfC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}
  \end{bprooftree}
\end{equation*}

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ r$}
  \RightLabel{∨-intro₂}
  \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

  \AxiomC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}

  \RightLabel{∨-elim}
  \BinaryInfC{$Γ, r ∨ (q ∨ p) ⊢ (p ∨ q) ∨ r$}

  \RightLabel{⇒-intro}
  \UnaryInfC{$Γ ⊢ r ∨ (q ∨ p) ⇒ (p ∨ q) ∨ r$}

  \end{bprooftree}
\end{equation*}
\end{example}

Notice that using $sbuild_{∨}$ we can build not only a disjunction with the same disjuncts of the source formula but also a complete different formula by adding new disjuncts to the source formula.

\begin{definition}[reorder$_{∨}$]
\begin{align*}
    \label{eq:reorder-or}
    \begin{split}
    &reorder_{∨} : \Prop \to \Prop \to \Prop\\
    &reorder_{∨} (φ, ψ) = sbuild_{∨}(rdisj(φ), ψ).
    \end{split}
  \end{align*}
\end{definition}

\begin{theorem}[thm-reorder$_{∨}$]
  \label{thm-reorder-or}
  $Γ ⊢ φ$, and $ψ: \Prop$ then $Γ ⊢ reorder_{∨}(φ, ψ)$.
\end{theorem}

\begin{proof}
Use Lemma~\ref{lem:lem-rdisj} and Lemma~\ref{lem:lem-sbuild-or}.
\end{proof}

We define similar functions and state some theorems as we previously did for disjunctions, but instead, we treat only with conjunctive normal forms.

\begin{definition}[reorder$_{∧}$]
  \begin{align*}
      \begin{split}
        &reorder : \Prop → \Prop \to Prop\\
        &reorder_{∧}(φ, ψ) =
        \begin{cases}
          φ, &\text{if }φ ≡ ψ\\
          ψ₁ ∧ ψ₂, &\text{if } ψ ≡ ψ₁ ∧ ψ₂\text{, }reorder_{∧}(φ, ψ₁) ≡ ψ₁\\
                  &\text{and }reorder_{∧}(φ, ψ₂)≡ ψ₂\\
          φ,       &\text{if } ψ ≡ ψ₁ ∧ ψ₂\\
          conjunct(φ, ψ), &\text{otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-reorder$_{∧}$]
  \label{lem:lem-reorder-and}
  $Γ ⊢ φ$, and $ψ : \Prop$ then $Γ ⊢ reorder(φ, ψ)$.
\end{lemma}

\begin{definition}[conjunct$_{∨}$]
  \label{eq:conjunct-or-definition}
\begin{align*}
  \begin{split}
    &conjunct_{∨} : \Prop → \Prop \to Prop\\
    &conjunct_{∨}(φ, ψ) =
    \begin{cases}
      ψ, &\text{if }φ ≡ ψ\\
      ψ, &\text{if }reorder_{∨}(φ, ψ) ≡ ψ\\
      ψ, &\text{if }ψ ≡ ψ₁ ∧ ψ₂, conjunct_{∨}(φ, ψ₁) ≡ ψ₁\\
        &\text{and } reorder_{∨}(φ, ψ₂) ≡ ψ₂\\
      ψ, &\text{if }φ ≡ φ₁ ∧ φ₂, conjunct_{∨}(φ₁, ψ) ≡ ψ\\
      ψ, &\text{if }φ ≡ φ₁ ∧ φ₂, conjunct_{∨}(φ₂, ψ) ≡ ψ\\
      φ, &\text{otherwise.}
    \end{cases}
  \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-conjunct$_{∨}$]
  \label{lem:lem-conjunct-or}
  $Γ ⊢ φ$, and $ψ : \Prop$ then $Γ ⊢ conjunct_{∨}(φ, ψ)$.
\end{lemma}

\begin{definition}[reorder$_{∧∨}$]
 \begin{align*}
      \begin{split}
      &reorder : \Prop \to \Prop \to \Prop\\
      &reorder_{∧∨}(φ, ψ)=
        \begin{cases}
          ψ, &\text{if } φ≡ψ\\
          ψ, &\text{if } ψ ≡ ψ₁ ∧ ψ₂, reorder_{∧∨}(φ,ψ₁) ≡ ψ₁\\
             &\text{and }reorder_{∧∨}(φ, ψ₂) ≡ ψ₂\\
          φ, &\text{if }ψ ≡ ψ₁ ∧ ψ₂\\
          conjunct_{∨}(φ, ψ) &\text{otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
  \end{definition}

\begin{theorem}[thm-reorder$_{∧∨}$]
  \label{thm:thm-reorder-and-or}
  $Γ ⊢ φ$, and $ψ : \Prop$ then $Γ ⊢ reorder_{∧∨}(φ, ψ)$.
\end{theorem}

% % --------------------------------------------------------------------

\subsubsection{Resolution.}
\label{sssec:resolve}

The \resolve rule incorporates the resolution theorem showed in
Fig.~\ref{fig:metis-inferences} for the \TSTP derivations.
This rule posses three arguments: a positive literal $l$ to apply the
resolution theorem, and two derivations.
The positive literal $l$ must occur in
the formula from the first derivation and the
negative literal must occur in the formula from the second derivation,
see the pattern of \emph{resolve} rule in Fig.~\ref{fig:metis-inferences}.

% \begin{figure}
\label{fig:resolve-tstp-example}
\begin{verbatim}
cnf(refute_0_4, plain, (~ r | p | q),
    inference(canonicalize, [], [normalize_0_5])).
cnf(refute_0_5, plain, (p | q | r),
    inference(canonicalize, [], [normalize_0_6])).
cnf(refute_0_6, plain, (p | q),
    inference(resolve, [$cnf(r)], [refute_0_5, refute_0_4])).
\end{verbatim}
% \caption{Excerpt of a \Metis \TSTP example for the \resolve rule.}
% \end{figure}

To emulate this rule, we perform rearrangements inside the formulas
involved to match with the pattern expected by the resolution theorem
described above. We begin by defining a convenient version of
the binary resolution in Def.~\ref{def:rsol}.

\begin{definition}[rsol]
\label{def:rsol}
\begin{align*}
      \begin{split}
        &rsol : \Prop \to \Prop\\
        &rsol(φ) =
        \begin{cases}
          φ₂, &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (φ₃ ∨ φ₄), φ₃ ≡ ¬ φ₁, φ₂ ≡ φ₄\\
          φ₂ ∨ φ₄, &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (φ₃ ∨ φ₄), φ₃ ≡ ¬ φ₁\\
          φ, &\text{otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-rsol]
  \label{lem:lem-rsol}
  $Γ ⊢ φ$ then $Γ ⊢ rsol(φ)$.
\end{lemma}

In Def.~\ref{def:resolve}, the emulated rule for $resolve$
has four arguments. The first three were described
above. The last one, ψ, represents the expected conclusion in the \Metis
derivation.

\begin{definition}[resolve]
\label{def:resolve}
 \begin{equation*}
    resolve(φ₁, φ₂, l, ψ) =
      rsol(reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨} (φ₂, ¬ l ∨ ψ)).
  \end{equation*}
\end{definition}

\begin{theorem}[thm-resolve]
  \label{thm:thm-resolve}
  $Γ ⊢ φ₁$, $Γ ⊢ φ₂$, a literal $l$, and $ψ: \Prop$ then $Γ ⊢ resolve(φ₁, φ₂, l, ψ)$.
\end{theorem}
\Needspace{3\baselineskip}
\begin{proof}
 \begin{equation*}
    \begin{bprooftree}
      \AxiomC{$Γ ⊢ φ₁$}
      \RightLabel{thm-reorder$_{∨}$,}
      \UnaryInfC{$Γ ⊢ reorder_{∨}(φ₁, l ∨ ψ)$}
   \end{bprooftree}
  \end{equation*}
    \vskip 1.5mm
 \begin{equation*}
    \begin{bprooftree}
      \AxiomC{$Γ ⊢ φ₂$}
      \RightLabel{thm-reorder$_{∨}$,}
      \UnaryInfC{$Γ ⊢ reorder_{∨}(φ₂, ¬ l ∨ ψ)$}
   \end{bprooftree}
  \end{equation*}
  \vskip 1.5mm
  \begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ reorder_{∨}(φ₁, l ∨ ψ)$}
    \AxiomC{$Γ ⊢ reorder_{∨}(φ₂, ¬ l ∨ ψ)$}
    \RightLabel{∧-intro}
    \BinaryInfC{$Γ ⊢ reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨}(φ₂, ¬ l ∨ ψ)$}
    \RightLabel{lem-rsol.}
    \UnaryInfC{$Γ ⊢ rsol(reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨}(φ₂, ¬ l ∨ ψ))$}
  \end{bprooftree}
  \end{equation*}
\end{proof}

\begin{figure}
\label{fig:resolve-example}
\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⊢ ¬ r ∨ p ∨ q$}
  \AxiomC{$Γ ⊢ p ∨ q ∨ r $}
  \RightLabel{thm-resolve}
  \BinaryInfC{$Γ ⊢ resolve(¬ r ∨ p ∨ q, p ∨ q ∨ r, r, p ∨ q)$}
  \UnaryInfC{$Γ ⊢ p ∨ q$}
  \end{bprooftree}
\end{equation*}
\caption{Example of a resolution in \Metis using
Thm.~\ref{thm:thm-resolve}.}
%Application of Thm.~\ref{thm:thm-resolve} for the \TSTP excerpt Fig.~\ref{fig:resolve-tstp-example}.}
\end{figure}

% subsubsection resolve (end)
% --------------------------------------------------------------------


% % --------------------------------------------------------------------

\subsubsection{Normalization.}
\label{sssec:normal_forms}
In the core of \Metis, we find an important module:
\texttt{Normalize.sml}.
This module is the responsible for rules like \canonicalize, \clausify,
\conjunct or \simplify.
One of the main purposes of the module consists of adding the axioms to the problem. Into this process, some transformation are carried out by different inference rules.
For example, the \canonicalize rule can convert a FOF formula to their CNF form. In that process, the formula can suffers different transformations by removing redundancies (tautologies or definitions), converting the proposition to its normalized negative normal form, to its conjunctive normal form, or to a specialized normal form.

\begin{definition}[\abbre{NProp}]
  \NProp is the type for a formula in normalized negative normal form
  in which negations appear only in the literals and the expression is in terms only of ($⊥$, $⊤$, $¬$, $∧$, $∨$, $⊻$) connectives. The $⊻$ connective is the exclusive disjunction.
  We define the \NProp type in a similar way as we did for \Prop type.
\end{definition}

A sequent $Γ ⟝ φ$ represents a theorem where
$Γ$ is a set of \Prop propositions premises, and $φ : \NProp$ is the
sequent's conclusion. These theorems have a subset of rules from
the classical inference rules in Fig.~\ref{fig:CPL-inference-rules}
that apply for the connectives that coincides with \NProp type.

% φ ⊻ ψ if and only if ¬ (φ ⇔ ψ).

\begin{figure}
  \[
    \begin{bprooftree}
      \AxiomC{$φ ∧ ⊥$}
      \UnaryInfC{$⊥$}
    \end{bprooftree}
    \qquad
    \begin{bprooftree}
      \AxiomC{$φ ∧ ⊤$}
      \UnaryInfC{$φ$}
    \end{bprooftree}
    \qquad
    \begin{bprooftree}
      \AxiomC{$φ ∧ ¬ φ$}
      \UnaryInfC{$⊥$}
    \end{bprooftree}
    \qquad
    \begin{bprooftree}
      \AxiomC{$φ ∧ φ$}
      \UnaryInfC{$φ$}
    \end{bprooftree}
  \]

  \[
    \begin{bprooftree}
      \AxiomC{$φ ∨ ⊥$}
      \UnaryInfC{$φ$}
    \end{bprooftree}
    \qquad
    \begin{bprooftree}
      \AxiomC{$φ ∨ ⊤$}
      \UnaryInfC{$⊤$}
    \end{bprooftree}
    \qquad
    \begin{bprooftree}
      \AxiomC{$φ ∨ ¬ φ$}
      \UnaryInfC{$⊤$}
    \end{bprooftree}
    \qquad
    \begin{bprooftree}
      \AxiomC{$φ ∨ φ$}
      \UnaryInfC{$φ$}
    \end{bprooftree}
  \]
\caption{Some definitions applied to translate a formula into its
normalized normal form.}
\label{fig:conjunctive-disjunctive-simpl}
\end{figure}

% -------------------------------------------------------------------
\subsubsection{Redundancy.}
\label{sssec:redundancy}

In this section we provide the functions and theorems to
remove inside a normalized formula the definitions showed in
Fig.~\ref{fig:conjunctive-disjunctive-simpl}.

\begin{remark}
We assume all formulas are in right-associative form in
the input of the functions by applying a version of $rdisj$ or $rconj$
functions for normalized propositions (see Def.~\ref{def:rdisj}).
\end{remark}

In a disjunction, $φ = φ₁ ∨ φ₂ ∨ \cdots ∨ φₙ$, we say $ψ ∈_{∨} φ$,
if there is some $i = 1, \cdots, n$ such that $ψ = φᵢ$.
Note that $ψ ∈_{∨} φ$ can be defined as the equality
$ψ ≡ conjunct_{∨}(φ, ψ)$.

\begin{definition}[rm$_∨$]
  \label{def:rm-or}
  \begin{align*}
    \begin{split}
      &rm_{∨} :  \NProp \to \NProp\\
      &rm_{∨}(φ) =
      \begin{cases}
        rm_{∨}(φ₂), &\text{if }φ ≡ φ₁ ∨ φ₂,\ φ₁ ∈_{∨} φ₂\\
        φ₁ ∨ rm_{∨}(φ₂), &\text{if }φ ≡ φ₁ ∨ φ₂\\
        φ,  &\text{otherwise.}
      \end{cases}
    \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-rm$_{∨}$]
  \label{lem:lem_rm-or}
  $Γ ⟝ φ$ then $Γ ⟝ rm_{∨}(φ)$.
\end{lemma}

Now, we have removed redundancies in the disjunctions by applying the
$rm_{∨}$, we can define a similar function to work with conjunctions.

\begin{equation*}
  \begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∨ φ$}
  \RightLabel{lem-rm$_∨$,}
  \UnaryInfC{$Γ ⟝ φ$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∧ φ$}
  \RightLabel{lem-rm$_∧$.}
  \UnaryInfC{$Γ ⟝ φ$}
  \end{bprooftree}
\end{equation*}

In a conjunction, $φ = φ₁ ∧ φ₂ ∧ \cdots ∧ φₙ$, we say
$ψ ∈_{∧} φ$, if there is some $i = 1, \cdots, n$ such that $ψ = φᵢ$.
We define $ψ ∈_{∧} φ$ as the equality $ψ ≡ conjunct(φ, ψ)$.

\begin{definition}[rm$_∧$]
\label{eq:rm-and}
  \begin{align*}
    \begin{split}
    &rm_{∧} : \NProp \to \NProp\\
    &rm_{∧}(φ) =
    \begin{cases}
      rm_{∧}(φ₂),      &\text{if }φ ≡ φ₁ ∧ φ₂, φ₁ ∈_{∧} φ₂\\
      φ₁ ∧ rm_{∧}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂\\
      φ,               &\text{otherwise.}
    \end{cases}
    \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-rm$_{∧}$] % (fold)
  \label{lem:lem_rm-and}
  $Γ ⟝ φ$ then $Γ ⟝ rm_{∧}(φ)$.
\end{lemma}

Continuing with the rest of tautologies from
Fig.~\ref{fig:conjunctive-disjunctive-simpl}, we define
$ndisj_{∨}$ function and $ndisj_{∨}$ function that
take into account the following cases.

\begin{equation*}
\begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∨ ¬~φ$}
  \RightLabel{lem-ndisj$_{∨}$,}
  \UnaryInfC{$Γ ⟝ ⊤$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∨ ⊤$}
  \RightLabel{lem-ndisj$_{∨}$,}
  \UnaryInfC{$Γ ⟝ ⊤$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∨ ⊥$}
  \RightLabel{lem-ndisj$_{∨}$.}
  \UnaryInfC{$Γ ⟝ φ$}
\end{bprooftree}
\end{equation*}

\begin{equation*}
\begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∧ ¬~φ$}
  \RightLabel{lem-ndisj$_{∧}$,}
  \UnaryInfC{$Γ ⟝ ⊥$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∧ ⊤$}
  \RightLabel{lem-ndisj$_{∧}$,}
  \UnaryInfC{$Γ ⟝ φ$}
\end{bprooftree}
\begin{bprooftree}
  \AxiomC{$Γ ⟝ φ ∧ ⊥$}
  \RightLabel{lem-ndisj$_{∧}$.}
  \UnaryInfC{$Γ ⟝ ⊥$}
\end{bprooftree}
\end{equation*}


\begin{definition}[ndisj$_{∨}$]
  \label{def:ndisj-or}
  \begin{align*}
    \begin{split}
    &ndisj_{∨} : \NProp \to \NProp\\
    &ndisj_{∨}(φ) =
      \begin{cases}
        ⊤, &\text{if }φ ≡ ¬ φ₁ ∨ φ₂,\ φ₁ ∈_{∨} φ₂\\
        ⊤, &\text{if}φ ≡ ¬ φ₁ ∨ φ₂,\ ndisj_{∨}(φ₂) ≡ ⊤\\
        ¬ φ₁ ∨ ndisj_{∨}(φ₂), &\text{if }φ ≡ ¬ φ₁ ∨ φ₂\\
        ⊤, &\text{if }φ ≡ φ₁ ∨ φ₂,\ ¬φ₁ ∈_{∨} φ₂ \\
        ⊤, &\text{if }φ ≡ φ₁ ∨ φ₂,\ ndisj_{∨}(φ₂) ≡ ⊤\\
        φ₁ ∨ ndisj_{∨}(φ₂), &\text{if }φ ≡ φ₁ ∨ φ₂\\
        φ, &\text{otherwise.}
      \end{cases}
    \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-ndisj$_{∨}$] % (fold)
  \label{lem:lem_ndisj-or}
  $Γ ⟝ φ$ then $Γ ⟝ ndisj_{∨}(φ)$.
\end{lemma}

\begin{definition}[ndisj$_{∧}$]
  \label{def:ndisj-and}
  \begin{align*}
    \begin{split}
    &ndisj_{∧} : \NProp \to \NProp\\
    &ndisj_{∧}(φ) =
      \begin{cases}
        ⊥, &\text{ if }φ ≡ ¬ φ₁ ∧ φ₂,\ φ₁ ∈_{∧} φ₂\\
        ⊥, &\text{ if }φ ≡ ¬ φ₁ ∧ φ₂,\ ndisj_{∧}(φ₂) ≡ ⊥\\
        ¬ φ₁ ∧ ndisj_{∧}(φ₂), &\text{ if }φ ≡ ¬ φ₁ ∧ φ₂\\
        ⊥, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ φ₁ ∈_{∧} φ₂\\
        ⊥, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ ndisj_{∧}(φ₂) ≡ ⊥\\
        φ₁ ∧ ndisj_{∧}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂\\
        φ, &\text{otherwise.}
      \end{cases}
    \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-ndisj$_{∧}$] % (fold)
  \label{lem:lem_ndisj-and}
  $Γ ⟝ φ$ then $Γ ⟝ ndisj_{∧}(φ)$.
\end{lemma}

% subsubsection redundancy (end)
% -------------------------------------------------------------------

We are ready to combine all function defined above in two function
$canon_{∧}$ for removing redundancies in conjunctions, and
$canon_{∨}$ for removing redundancies in disjunctions.

\begin{definition}[canon$_{∧}$]
\label{def:canon-and}
\begin{align*}
    \begin{split}
      &canon_{∧} : \NProp \to \NProp\\
      &canon_{∧}(φ) =
        \begin{cases}
        φⱼ, &\text{if } φ ≡ φ₁ ∧ φ₂,\ φᵢ ≡ ⊤,\text{ for } i,j = 1,2, i≠j\\
        ⊥, &\text{if } φ ≡ φ₁ ∧ φ₂,\ φᵢ ≡ ⊥,\text{ for } i,j = 1,2\\
       rm_∧(ndisj_∧(φ)), &\text{if } φ ≡ φ₁ ∧ φ₂\\
       φ, &\text{otherwise.}
        \end{cases}
    \end{split}
\end{align*}
\end{definition}

\begin{lemma}[lem-canon$_{∧}$]
  \label{lem:lem_canon-and}
  $Γ ⟝ φ$ then $Γ ⟝ canon_{∧}(φ)$.
\end{lemma}

\begin{definition}[canon$_{∨}$]
\label{def:canon-or}
\begin{align*}
    \begin{split}
      &canon_{∨} : \NProp \to \NProp\\
      &canon_{∨}(φ) =
        \begin{cases}
        φⱼ, &\text{if } φ ≡ φ₁ ∨ φ₂,\ φᵢ ≡ ⊥,\text{ for } i,j = 1,2, i≠j\\
        ⊤, &\text{if } φ ≡ φ₁ ∨ φ₂,\ φᵢ ≡ ⊤,\text{ for } i,j = 1,2\\
        rm_∨(ndisj_∨(φ)), &\text{if } φ ≡ φ₁ ∧ φ₂\\
        φ, &\text{otherwise.}
        \end{cases}
    \end{split}
\end{align*}
\end{definition}

\begin{lemma}[lem-canon$_{∨}$]
  \label{lem:lem_canon-or}
  $Γ ⟝ φ$ then $Γ ⟝ canon_{∨}(φ)$.
\end{lemma}

\begin{remark}
A similar treatment we do to define the $canon_{⊻} : \NProp \to \NProp$
function that removes redundancies related with the exclusive
disjunction connective, and to prove its soundness with the respective
theorem thm-canon$_{⊻}$ in~\cite{AgdaMetis}.
We left out this description for the brevity of this
document and refer the interested reader to the implementation
in~\cite{AgdaMetis}.
\end{remark}

Finally, we can translate formulas from \Prop to \NProp by defining the
$nnf₀$ function based on the \Metis'source code. We have taken
inspiration on the $nnf$ function described in
\citeauthor{Bezem2002}~\cite{Bezem2002}. Their $nnf$ function translates
formulas to their classical negative normal form. In the reference, the
authors avoid a termination problem with a similar function by using as a
extra argument, the polarity of the formula.

For the polarity of a formula, we use the \abbre{Polarity} type with two
constructors: $⊕$ to denote positive polarity, and $⊖$ to denote negative
polarity.

\begin{definition}[nnf₀]
\label{def:nnf-zero}
  \begin{align*}
    \begin{split}
    &nnf₀ : \abbre{Polarity} \to \Prop \to \NProp\\
    &nnf₀(⊕, φ) =
      \begin{cases}
      canon_{∧}(nnf₀(⊕, φ₁) ∧ nnf₀(⊕, φ₂)), &\text{if }φ ≡ φ₁ ∧ φ₂ \\
      canon_{∨}(nnf₀(⊕, φ₁) ∨ nnf₀(⊕, φ₂)), &\text{if }φ ≡ φ₁ ∨ φ₂ \\
      canon_{∨}(nnf₀(⊖, φ₁) ∨ nnf₀(⊕, φ₂)), &\text{if }φ ≡ φ₁ ⇒ φ₂ \\
      canon_{⊻}(nnf₀(⊖, φ₁) ⊻ nnf₀(⊕, φ₂)), &\text{if }φ ≡ φ₁ ⇔ φ₂ \\
      nnf₀(⊖, φ₁),                          &\text{if }φ ≡ ¬ φ₁ \\
      φ,                                    &\text{otherwise.} \\
      \end{cases}\\
    &nnf₀(⊖, φ) =
      \begin{cases}
      canon_{∨}(nnf₀(⊖, φ₁) ∨ nnf₀(⊖, φ₂)),  &\text{if }φ ≡ φ₁ ∧ φ₂ \\
      canon_{∧}(nnf₀(⊖, φ₁) ∧ nnf₀(⊖, φ₂)),  &\text{if }φ ≡ φ₁ ∨ φ₂ \\
      canon_{∧}(nnf₀(⊖, φ₂) ∧ nnf₀(⊖, φ₁)),  &\text{if }φ ≡ φ₁ ⇒ φ₂ \\
      canon_{⊻}(nnf₀(⊕, φ₁) ⊻ nnf₀(⊕, φ₂)),  &\text{if }φ ≡ φ₁ ⇔ φ₂ \\
      nnf₀(⊕, φ₁),                           &\text{if }φ ≡ ¬ φ₁ \\
      ⊥,                                     &\text{if }φ ≡ ⊤ \\
      ⊤,                                     &\text{if }φ ≡ ⊥ \\
      φ,                                     &\text{otherwise.} \\
      \end{cases}
    \end{split}
  \end{align*}
\end{definition}

\begin{lemma}[lem-nnf]
  \label{lem:lem-nnf}
  $Γ ⊢ φ$ then $Γ ⟝ nnf(φ)$ where,
  \begin{align*}
   \begin{split}
     &nnf : \NProp \to \NProp\\
     &nnf(φ) = nnf₀(⊕, φ).
   \end{split}
  \end{align*}
\end{lemma}

\begin{lemma}[lem-dist$_{∨}$]
  \label{lem:lem-dist-or}
  $Γ ⟝ φ$ then $Γ ⟝ dist_{∨}(φ)$, where,
  \begin{align*}
      \begin{split}
      dist_{∨}(φ) =
        \begin{cases}
          dist_{∨}(φ₁ ∨ φ₂) ∧ dist_{∨}(φ₂ ∨ φ₃),
            &\text{if }φ ≡ (φ₁ ∧ φ₂) ∨ φ₃\\
          dist_{∨}(φ₁ ∨ φ₃) ∧ dist_{∨}(φ₁ ∨ φ₃),
            &\text{if }φ ≡ φ₁ ∨ (φ₂ ∧ φ₃)\\
          φ, &\text{otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
\end{lemma}

\begin{lemma}[lem-dist]
  \label{lem:lem-dist}
  $Γ ⟝ φ$ then $Γ ⟝ dist(φ)$, where,
  \begin{align*}
      \begin{split}
      dist(φ) =
        \begin{cases}
          dist(φ₁) ∧ dist(φ₂),
            &\text{if }φ ≡ φ₁ ∧ φ₂\\
          dist_{∨}(dist(φ₁) ∨ dist(φ₂)),
            &\text{if }φ ≡ φ₁ ∨ φ₂\\
          φ, &\text{otherwise.}
        \end{cases}
      \end{split}
  \end{align*}
\end{lemma}

\begin{sketchproof} If $φ ≡ φ₁ ∨ φ₂$, we get for $i = 1, 2$,
\begin{equation*}
  \begin{bprooftree}
    \RightLabel{assume}
    \AxiomC{$Γ, φ_{i} ⊢ φ_{i}$}
    \RightLabel{lem-dist}
    \UnaryInfC{$Γ ⊢ dist(φ_{i})$}
    \RightLabel{∨-intro$_{1,2}$}
    \UnaryInfC{$Γ, φ_{i} ⊢ dist(φ₁) ∨ dist(φ₂)$}
    \RightLabel{lem-dist$_{∨}$.}
    \UnaryInfC{$Γ, φ_{i} ⊢ dist_{∨}(dist(φ₁) ∨ dist(φ₂))$}
    \end{bprooftree}
\end{equation*}
Then, by using the ∨-elim rule, from the last derivation above we derive
$Γ, φ₁ ∨ φ₂ ⟝ dist_{∨}(dist(φ₁) ∨ dist(φ₂))$, and the lemma follows.
\end{sketchproof}

\begin{definition}[form]
\begin{align*}
    \begin{split}
      &form : \NProp \to \Prop\\
      &form(φ) =
      \begin{cases}
        form(φ₁) ∧ form(φ₂), &\text{ if }φ ≡ φ₁ ∧ φ₂\\
        form(φ₁) ∨ form(φ₂), &\text{ if }φ ≡ φ₁ ∨ φ₂\\
        form_{⊻}(φ₂),        &\text{ if }φ ≡ φ₁ ⊻ φ₂\\
        % ⊥, &\text{ if }φ ≡ ⊥\\
        % ⊤, &\text{ if }φ ≡ ⊤\\
        φ, &\text{otherwise.}\\
      \end{cases}
    \end{split}
\end{align*}
\end{definition}

\begin{lemma}[lem-form]
  \label{lem:lem-form}
   $Γ ⟝ φ$ then $Γ ⊢ form(φ)$.
\end{lemma}

\begin{theorem}[thm-cnf]
\label{thm:thm-cnf}
  $Γ ⊢ φ$ then $Γ ⊢ cnf(φ)$, where,
  \begin{align*}
    \begin{split}
    &cnf : \NProp \to \NProp\\
    &cnf = form ∘ dist ∘ nnf.
    \end{split}
  \end{align*}
\end{theorem}

\begin{proof}
  Composition of the Lemmas \ref{lem:lem-form}, \ref{lem:lem-dist} and \ref{lem:lem-nnf}.
\end{proof}

Since all transformations performed above come from equivalences
in classical propositional logic, we can also states the following theorem convenient for the next section.

\begin{theorem}[thm-inv-cnf]
\label{thm:thm-inv-cnf}
  $Γ ⊢ cnf(φ)$ then $Γ ⊢ φ$.
\end{theorem}

% subsubsection normal_forms (end)
% --------------------------------------------------------------------

% -------------------------------------------------------------------
\subsubsection{Canonicalize.}
\label{sssec:canonicalize}

The \canonicalize rule is an overloaded inference rule that performs
mainly normalization of the proposition input by using theorems
described in the section above. This rule  can convert a FOF formula in
clausal form to a CNF clause. \Metis can introduce axioms, and definitions
by using this rule. Since the nature of this rule consists of dealing with
CNF clauses, our strategy to justify its reasoning mainly consists of
testing for equality with normalized negative form of the formula, or a
reordering of the conjunctive normal form of the source formula to match
the conjunctive normal form of the target formula.

\begin{definition}[canonicalize]
\label{def:canonicalize}
\begin{align*}
    \begin{split}
      &canonicalize : \Prop \to \Prop \to \Prop\\
      &canonicalize(φ, ψ) =
      \begin{cases}
        ψ, &\text{if }ψ ≡ φ\\
        ψ, &\text{if }ψ ≡ form(nnf(φ))\\
        ψ, &\text{if }cnf(ψ) ≡ reorder_{∧∨}(cnf(φ), cnf(ψ))\\
        φ, &\text{otherwise.}\\
      \end{cases}
    \end{split}
\end{align*}
\end{definition}

\begin{theorem}[thm-canonicalize] % (fold)
  \label{thm:thm-canonicalize}
  \hspace{4mm}\\
  $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ canonicalize(φ, ψ)$.
\end{theorem}

\begin{proof}\hspace{3mm}
\begin{itemize}
\item If $φ ≡ ψ$ by substitution theorem we conclude $Γ ⊢ ψ$.
\item If $ψ ≡ form(nnf(φ))$,
\begin{equation*}
  \begin{bprooftree}
    \AxiomC{$Γ ⊢ φ$}
    \RightLabel{lem-nnf}
    \UnaryInfC{$Γ ⊢₂~nnf(φ)$}
    \RightLabel{lem-form}
    \UnaryInfC{$Γ ⊢ form(nnf(φ))$}
    \AxiomC{$ψ ≡ form(nnf(φ))$}
    \RightLabel{subst.}
    \BinaryInfC{$Γ ⊢ ψ$}
  \end{bprooftree}
\end{equation*}
\item If $γ := cnf(ψ) ≡ reorder_{∧∨}(cnf(φ), cnf(ψ))$,
\begin{equation*}
  \begin{bprooftree}
     \AxiomC{$Γ ⊢ φ$}
     \RightLabel{thm-cnf}
     \UnaryInfC{$Γ ⊢ cnf(φ)$}
     \RightLabel{thm-reorder$_{∧∨}$}
     \UnaryInfC{$Γ ⊢ reorder_{∧∨}(cnf(φ), cnf(ψ))$}
     \AxiomC{$γ$}
    \RightLabel{subst}
    \BinaryInfC{$Γ ⊢ cnf(ψ)$}
    \RightLabel{thm-inv-cnf.}
    \UnaryInfC{$Γ ⊢ ψ$}
  \end{bprooftree}
\end{equation*}
\end{itemize}
\end{proof}

% subsubsection canonicalize (end)
% -------------------------------------------------------------------

% --------------------------------------------------------------------

\subsubsection{Clausification.}
\label{sssec:clausification}

The \clausify rule transforms a
propositional formula in its clausal normal form, a conjunction
of clauses. Where a \emph{clause} is the disjunction of zero or more
literals and a \emph{literal} is an atom (positive literal) or a
negation of an atom (negative literal). Be aware this kind of conversion between one formula to its clausal normal form is not unique, and \Metis has a customized approach to perform that transformation.
In the following \Metis \TSTP derivation, we see a clear example, where
clausify expands the formula \texttt{normalize\_0\_0} by using distributive
laws.

\begin{verbatim}
fof(a1, axiom, (p => (q & r))).
...
fof(normalize_0_0, plain, (~ p | (q & r)),
    inference(canonicalize, [], [a1])).
fof(normalize_0_1, plain, ((~ p | q) & (~ p | r)),
    inference(clausify, [], [normalize_0_0])).
\end{verbatim}

\begin{definition}[clausify]
  \label{def:clausify}
 \begin{align*}
   \begin{split}
      &clausify : \Prop → \Prop → \Prop\\
      &clausify(φ,ψ) =
      \begin{cases}
        ψ, &\text{ if }φ≡ψ\\
        reorder_{∧∨}(cnf(φ), ψ), &\text{otherwise.}
      \end{cases}
      \end{split}
  \end{align*}
\end{definition}

\begin{theorem}[thm-clausify]
\label{thm:thm-clausify}
  $Γ ⊢ φ$ and $ψ : \Prop$ then $Γ ⊢ clausify(φ, ψ)$.
\end{theorem}

\begin{proof} When $φ ≡ ψ$, we use the $subs$ theorem Eq.~(\ref{eq:substitution-theorem}). Otherwise, we use Theorem \ref{thm:thm-reorder-and-or} and Theorem \ref{thm:thm-cnf}.
\end{proof}

\begin{remark}
The \clausify rule is often preceded by the \canonicalize rule.
Both rules perform \emph{Clausification} that introduces
into the problem axioms or definitions in the domain of the solution.
The Clausification algorithms is mainly described on paper by
\citeauthor{Sutcliffe1996}~\cite{Sutcliffe1996}. We left for future work
investigate the consequences of removing $clausify$ inference by
strengthen $canonicalize$ rule in Def.~\ref{def:canonicalize}
\end{remark}

% subsubsection clausification (end)
% --------------------------------------------------------------------

% -------------------------------------------------------------------
\subsubsection{Simplification.}
\label{sssec:simplify}

The \simplify rule is an inference that performs simplification of
definitions and tautologies. This rule
transverses a list of inner derivations by applying different theorems
(e.g., \emph{modus pones}, \emph{modus tollens}, or \emph{disjunctive
syllogism}) to get a contradiction or just simplify the formulas.
To emulate this rule, we have included theorems
from \canonicalize rule Section~\ref{sssec:canonicalize} and
\resolve rule Section~\ref{sssec:resolve}.

\begin{remark}
Besides the fact, $\List\ \Prop \to \Prop$ is the type that coincides
with the reading of a \TSTP derivation, we choose a different option.
In the translation from \TSTP to \Agda, we build a conjunction
from the list of derivations by introducing binary conjunction
with $∧$-intro rule. That avoids us to define a new sequent type
to support \List \Prop type in the conclusion side.
\end{remark}

\begin{figure}
\begin{verbatim}
fof(normalize_1_0, plain, (~ p & ~ r & q),
    inference(canonicalize, [], [negate_1_0])).
fof(normalize_1_1, plain, ((p | q) & (p | r)),
    inference(canonicalize, [], [a1])).
fof(normalize_1_2, plain, (p | r),
    inference(conjunct, [], [normalize_1_1])).
fof(normalize_1_3, plain, ($false),
    inference(simplify, [], [normalize_1_0, normalize_1_2])).
\end{verbatim}
\caption{Example of \simplify rule in a \TSTP derivation of \Metis.}
\end{figure}


\begin{align}
    \begin{split}
      &\textit{simpl} : \Prop \to \Prop \to \Prop \to \Prop\\
      &\textit{simpl}(φ₁, φ₂ ψ) =
      \begin{cases}
        ψ, &\text{if }φᵢ ≡ ψ,\text{ for some }i = 1, 2\\
        ψ, &\text{if }φ₁ ≡ φ₂ ⇒ ψ\\
      \end{cases}
    \end{split}
\end{align}

\begin{theorem}[thm-simplify] % (fold)
  \label{thm:thm-simplify}
$\{ Γ ⊢ φᵢ \}$ for $i = 1, \cdots, n$ then
$Γ ⊢ simplify (\bigwedge_{i=1}^n φ)$.
\end{theorem}

% subsubsection simplify (end)
% -------------------------------------------------------------------

\end{document}
