% -*- root: main.tex -*-
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Proof-Reconstruction}
\label{sec:proof-reconstruction}

\subsection{Workflow}
\label{ssec:workflow}

\begin{figure}
\centering

\begin{tikzpicture}[scale=0.9]
\node[text width=2cm, align=center](problem) at (0,0)
  {1. \CPL \\ Problem.};

\node[right = 1.1cm of problem, text width=2cm, align=center]
  (tptp){2. \TPTP \\ Problem.};

\node[right= 1.1cm of tptp, text width=2cm, align=center]
   (metis) {3. \Metis \\ Prover.};

\node[right= 1.1cm of metis, text width=2cm, align=center, inner sep=10pt]
   (tstp) {4. \TSTP \\ Derivation.};

\node[below= 0.5cm of tstp, text width=2cm, align=center, inner sep=10pt]
  (athena) {5. \Haskell \\ Translator.};

\node[left = 1.1cm of athena, text width=2cm, align=center]
   (agdafile) {6. \Agda \\ Proof.};

\node[left = 1.1cm of agdafile, text width=2cm, align=center]
   (agda) {7. Proof Checking.};

\node[below = 0.5cm of problem, text width=2cm, align=center]
   (verified) {8.1 Proof \\ Checked.};

\node[below = 0.5cm of verified, text width=2cm, align=center]
   (failure) {8.2 Failure.};

% node[below] {send to}
\draw[->, thick] (problem) to
  % node[below] {\tiny encoding}
  (tptp);
\draw[->, thick] (tptp) to
  % node[below] {\tiny }
  (metis);
\draw[->, thick] (metis) to
  % node[below] {\tiny replies on}
  (tstp);
\draw[->, thick] (tstp) to
  % node[right] {\tiny parsing}
  (athena);
\draw[->, thick] (athena) to
  % node[below] {\tiny traslation}
  (agdafile);
\draw[->, thick] (agdafile) to
  % node[below] {\tiny type-checking}
  (agda);
\draw[->, thick] (agda) to (verified);
\draw[->, thick, gray] (agda) to (failure);
\end{tikzpicture}
\caption{Proof-reconstruction overview.}
\label{fig:proof-reconstruction-workflow}
\end{figure}

The proof-reconstruction approach proposed here consists of a series
of steps similar to the workflow presented by Sultana in
\cite{sultana2015}. This process is a translation from a source
system to a target system. In our case, the system of origin, the
automatic theorem prover, is \Metis; the target system is the proof
assistant, \Agda. We choose \Agda, but another proof assistant with
support of type theory and similar features like \Agda
(see a description of \Agda in section
\ref{sec:implementation}) is valid; our results do not depend on 
the proof assistant but the support of inductive data types, 
termination checking, and type-checking.

Following the diagram in Fig.
\ref{fig:proof-reconstruction-workflow}, the process can begin with
a problem in \CPL that we encode in \TPTP format to be sent as the
input of the \Metis prover.
The proof-search algorithms of \Metis in step No. 3 intend to find 
a solution; if they success, \Metis replies a derivation in \TSTP 
format of the proof, else \Metis may no stop and running forever or 
replies the problem is counter feasible.

With such a derivation, we process it with our \Haskell translator
tool, \Athena~\cite{Athena}.
\Athena parses the \TSTP format, analyze the
derivation and generates a representation of the natural deduction
proof using a version of a tree data structure (see the properties
of this tree in subsection \ref{ssec:metis-proofs}). As a result,
\Athena generates an \Agda file with such a proof. We have included
in this file, \emph{imports} that call \Agda libraries that give 
support for the logic~\cite{AgdaProp}, and versions of the \Metis' 
inference rules~\cite{AgdaMetis}.

Finally, we use the proof assistant in step No. 7 to type-check the
proof and verify its correctness. Next, we only have one answer:
type-checking succeed (i.e., the proof is valid) or type-checking 
failed.
If the type-check fails, one of the three actors in the process are
responsible: \Metis, \Athena, or \Agda. We are responsible for
errors committed in the translation from \TSTP to \Agda; lack of the
coverage of the \Metis' inference rules, or bad assumptions about
them. \improvement{Make this statement stronger and clear.}

In the rest of this section, we provide a formal description using
type theory to build definitions and theorems for the functions
necessary to emulate the \Metis' inference rules.

% ...................................................................

\subsection{Recursion Theorems}

\improvement{Convention notation := for equivalence between propositions}
% \footnote{We use the \Agda standard library's implementation of the List data type.}.

\begin{definition}(Negative Normal Form (NNF))
Una forma normal negativa para la formula $\varphi$ es aquella
en la cual negaciones aparecen solamente en los literales y
la expresión se encuentra en términos unicamente
de los operadores booleanos ($\neg$, $\wedge$, $\vee$).
\end{definition}

Para transformar una formula $\varphi$ a su forma equivalente NNF,
aplicamos recursivamente las siguientes ecuaciones que definen
la función \name{nnf}.

\begin{equation}
\label{eq:nnf-definition}
\nnf(φ) =
\begin{cases}
\nnf(φ₁) ∧ \nnf(φ₂)
   & φ := φ₁ ∧ φ₂  \\

\nnf(φ₁) ∨ \nnf(φ₂)
   & φ := φ₁ ∨ φ₂  \\

\nnf(¬ φ₁ ∨ φ₂)
   & φ := φ₁ ⇒ φ₂  \\

\nnf(φ₁ ⇒ φ₂ ∧ φ₂ ⇒ φ₁)
   & φ := φ₁ ⇔ φ₂\\

\nnf(¬ φ₁ ∨ ¬ φ₂)
   & φ := ¬ (φ₁ ∧ φ₂) \\

\nnf(¬ φ₁ ∧ ¬ φ₂)
   & φ := ¬ (φ₁ ∨ φ₂) \\

\nnf(φ₁)
   & φ := ¬ ¬ φ₁     \\


\nnf(¬ (φ₂ ∨ ¬ φ₁))
   & φ := ¬ (φ₁ ⇒ φ₂)  \\

\nnf(¬ (φ₁ ⇒ φ₂ ∧ φ₂ ⇒ φ₁))
   & φ := ¬ (φ₁ ⇔ φ₂) \\

⊥  & φ := ¬ ⊤        \\

⊤  & φ := ¬ ⊥        \\

φ  & \text{otherwise}
\end{cases}
\end{equation}

\begin{definition}
Una funcion recursiva se dice bien estructura, si el tamaño de los argumentos
con que con esta se define se reducen en tamaño por cada llamada a la
funcion.
\end{definition}

De la anterior definincion, sintacticamente la funcion nnf no es recursivamente
bien estructurado. El problem que no lo sea esta en nuestra traducion
de este tipo de funciones a la teoria de tipos.

Veamos otros ejemplos de funciones con el mismo problema que utilizaremos mas
adelante para formalizar la inferencia strip.

\begin{equation}
\label{eq:unshunt-definition}
\unshunt(φ) =
\begin{cases}
\unshunt((φ₁ ∧ φ₂) ⇒ φ₃)
  & φ := φ₁ ⇒ (φ₂ ⇒ φ₃)\\

\unshunt(φ₁ ⇒ φ₂) ∧ \unshunt(φ₁ ⇒ φ₃)
  & φ := φ₁ ⇒ (φ₂ ∧ φ₃)\\

φ &\text{otherwise}
\end{cases}
\end{equation}


Para traducir las funciones en un manera que esten bien definidas,
utilizamos el metodo propuesto por Ana Bove, el cual basicamente consiste


una funcion general recursiva $f:\sigma \to \tau$, su formalizacion en
teoria de tipos consiste en definir un predicado inductivo $Ind$,
$P:\sigma \to Ind$

En nuestro caso, el conjunto de los numeros servira como nuestro
conjunto inductivo y como segundo argumento para nueva funcion.
De manera, que la funcion g estara definida por recursion estructural en
su segundo termino.

Para aplicar la tecnica antes mencionada para nuestras funciones,
veamos su aplicación con la funcion \unshunt porque para las demas,
seguiremos un camino similar, f con tipo:

\[
\unshunt^{*} : PROP \to \mathcal{N} \to PROP
\]

\begin{equation}
\label{eq:unshunt-structured}
\unshunt^{*}(φ, n) =
\begin{cases}
\unshunt^{*}((φ₁ ∧ φ₂) ⇒ φ₃, n-1)
  & φ := φ₁ ⇒ (φ₂ ⇒ φ₃)\\

\unshunt^{*}(φ₁ ⇒ φ₂, n-1) ∧ \unshunt^{*}(φ₁ ⇒ φ₃,n-1)
  & φ := φ₁ ⇒ (φ₂ ∧ φ₃)\\

φ & n := 0
\end{cases}
\end{equation}


\begin{definition}
El rango $rank(\phi)$ de una proposition $\phi$ es definido como

\begin{equation}
\label{eq:rank-definition}
rank(\phi)=
\begin{cases}
0 &\text{for atomic }\phi\\

\max(rank(\phi_1),rank(\phi_2)) + 1
  & \phi := \phi_1\,\square\, \phi_2 \\
rank(\phi_1) + 1  & \phi := \neg \phi_1
\end{cases}
\end{equation}

\end{definition}

Then, we our final revision for the function $\unshunt$ is the
function$\unshunt^{+}$ with type $PROP \to PROP$
with a structured recursion,

\begin{equation}
\unshunt^{+}(\varphi) = \unshunt^{*}(\varphi, rank(\varphi))
\end{equation}

In the following section, our task will consist of a searching
appropriate functions like $rank$ to assure the termination of
our transformation functions like $nnf$.


% ................................................

\subsection{Emulation \Metis' Inference Rules}

\emph{Splitting.}
We take a goal and generate subgoals that all in a conjunction
prove the goal.

\begin{theorem}[{\tt thm-$\unshunt^{*}$}] $Γ ⊢ \unshunt^{*}(φ, n)$ for $n\in \mathbb{N}$, then $Γ ⊢ φ$.
\end{theorem}
\begin{proof} Use induction on the cases defined by the result of
$\unshunt^{*}$. When $n = 0$, by definition in Eq.
\ref{eq:unshunt-structured} then $Γ ⊢ φ$.
For the first case, we prove $Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃)$ from
$Γ ⊢ \unshunt^{*}(φ₁ ⇒ (φ₂ ⇒ φ₃), n)$.
Because $n > 0$, using induction on the second argument and the
theorem $∧⇒$\texttt{-to-}$⇒⇒$ from \cite{AgdaProp}.

\begin{equation*}
\begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ (φ₂ ⇒ φ₃), n)$}
\RightLabel{By definition}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ (φ₂ ⇒ φ₃), n-1)$}
\RightLabel{\tt thm-$\unshunt^{*}$}
\UnaryInfC{Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃}
\RightLabel{\tt ∧⇒-to-⇒⇒}
\UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃)}
\end{bprooftree}
\end{equation*}

The second case proves $Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃)$ from
 $Γ ⊢ \unshunt^{*}(φ₁ ⇒ (φ₂ ∧ φ₃), n)$ and the
theorem $⇒∧⇒$\texttt{-to-}$⇒∧$ from \cite{AgdaProp}
\begin{equation*}
\scalebox{0.95}{
$D_1$ := \begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₂, n) ∧ \unshunt^{*}(φ₁ ⇒ φ₃, n)$}
\RightLabel{\tt ∧-proj₁}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₂, n)$}
\RightLabel{By definition}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₂, n-1)$}
\RightLabel{\tt thm-$\unshunt^{*}$}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$}
\end{bprooftree}
}
\end{equation*}

\begin{equation*}
D_2 :=
\begin{bprooftree}
\AxiomC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₂) ∧ \unshunt^{*}(φ₁ ⇒ φ₃)$}
\RightLabel{\tt ∧-proj₂}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₃, n)$}
\RightLabel{By definition}
\UnaryInfC{$Γ ⊢ \unshunt^{*}(φ₁ ⇒ φ₃, n-1)$}
\RightLabel{\tt thm-$\unshunt^{*}$}
\UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₃$}
\end{bprooftree}
\end{equation*}

\begin{equation*}
\begin{bprooftree}
\AxiomC{$D_1$}
\AxiomC{$D_2$}
\RightLabel{\tt ∧-intro}
\BinaryInfC{$Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃)$}
\RightLabel{\tt ⇒∧⇒-to-⇒∧}
\UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃)}
\end{bprooftree}
\end{equation*}
\end{proof}

The function \mysplit performs such that strategy and it has the type
\[ \mysplit : \PROP \to \PROP
\]
\begin{equation}
\label{eq:split-definition}
\mysplit(φ) =
\begin{cases}
\unshunt(\mysplit(φ₁)) ∧ \unshunt(φ₁ ⇒ \mysplit(φ₂)
  & φ := φ₁ ∧ φ₂\\

\unshunt(¬ φ₁ ⇒ \mysplit(φ₂))
  & φ := φ₁ ∨ φ₂\\

\unshunt(φ₁ ⇒ \mysplit(φ₂))
  & φ := φ₁ ⇒ φ₂\\

\unshunt(φ₁ ⇒ \mysplit(φ₂)) ∧ \unshunt(φ₂ ⇒ \mysplit(φ₁))
  & φ := φ₁ ⇔ φ₂\\

\unshunt(φ₁ ⇒ \mysplit(¬ φ₂))
  & φ := ¬ (φ₁ ∧ φ₂)\\

\unshunt(\mysplit(¬ φ₁)) ∧ \unshunt(¬ φ₁ ⇒ \mysplit(¬ φ₂))
  & φ := ¬ (φ₁ ∨ φ₂)\\

\unshunt(\mysplit(φ₁)) ∧ \unshunt(φ₁ ⇒ \mysplit(¬ φ₂))
  & φ := ¬ (φ₁ ⇒ φ₂)\\

\unshunt(φ₁ ⇒ \mysplit(¬ φ₂)) ∧ \unshunt(¬ φ₂ ⇒ \mysplit(φ₁))
  & φ := ¬ (φ₁ ⇔ φ₂)\\

\unshunt(\mysplit(φ₁)
  & φ := ¬ ¬ φ₁\\

⊤ & φ := ¬ ⊥\\

⊥ & φ := ¬ ⊤\\

φ &\text{otherwise}
\end{cases}
\end{equation}

The theorem is the following.

\begin{theorem}[Splitting a Goal] $Γ ⊢ \mysplit(φ) ⇒ φ$
\end{theorem}

\begin{proof}
ss
\end{proof}

The \mysplit function returns a conjunction of the subgoal. From each
\TSTP derivation, we have information of the subgoals but no how they strictly appear in that conjunction. For that reason, with \Athena, we infer the exact order in the conjunction that coincides with the conjunction given by \mysplit.

\begin{theorem} For a list of subgoals $s_0, \cdots, s_1$ with their respective theorem $Γ ⊢ s_i$, such that $\bigwedge_i s_i ⇒ \texttt{goal}$, then $Γ ⊢ \texttt{goal}$ 
\end{theorem}





\end{document}