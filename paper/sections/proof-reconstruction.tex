
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Proof-Reconstruction}
\label{sec:proof-reconstruction}

\subsection{Workflow}
\label{ssec:workflow}

\input{sections/diagram.tex}

The proof-reconstruction approach proposed here consists of a series
of steps similar to the workflow presented by \citeauthor{sultana2015} in
\cite{sultana2015}. This process is a translation from a source
system to a target system. In our case, the system of origin, the
automatic theorem prover, is \Metis; the target system is a proof
assistant, \Agda. We choose \Agda, but another proof assistant with the same support of type theory and inductive types is valid (see a description of \Agda for its main features in
Section~\ref{sec:implementation}).
The overview of the proof-reconstruction is presented in
Fig.~\ref{fig:proof-reconstruction-workflow}, the process can begin with
a problem in \CPL that we encode in \TPTP format to be sent as the
input of the \Metis prover.
The algorithms of \Metis in Step~3 find
a solution if the problem is a theorem, in that case \Metis replies
with a derivation in \TSTP format of the proof, otherwise the problem is counter feasible.

% With such a derivation, in Step~5, we process the derivation with our \Haskell translator tool, \Athena~\cite{Athena}.
% \Athena parses the \TSTP format, analyze the
% derivation and generates a representation of the natural deduction
% proof using a tree data structure (see the properties
% of this tree in Section~\ref{ssec:metis-proofs}).
% We perform an analysis of the proof-tree removing redundancies,
% unnecessary steps or unused output from the \TSTP derivation.

% As a result,
% \Athena generates an \Agda file with the proof-term. We have included
% in this file, \emph{imports} that call our \Agda libraries that give
% support for CPL presented in~\cite{AgdaProp}, and support for \Metis'
% inference rules implemented in~\cite{AgdaMetis}.

% Finally, we use the proof checker in Step~7 to type-check the
% proof-term. If type-checking succeed, the \TSTP
% derivation is correct, otherwise when it fails, one of the three
% actors in the process could be the responsible: \Metis, \Athena, or
% \Agda.

% We are responsible for errors committed in the translation from
% \TSTP to \Agda: bugs in the parsing module, lack of the coverage of
% \Metis' inference rules, and last but not least, the pretty print of
% the proof in \Agda code.

% In the rest of this section, we provide a formal description using
% type theory to build definitions and theorems for functions
% necessary to emulate \Metis' inference rules.
% Some conventions about notations. We will write the
% type judgments with ``$a : A$'' to denote that $a$ has type
% $\abbre{A}$. Types are written using small caps.
% For propositions, we will denote by $φ ≡ ψ$, the syntactic
% equivalence. We use the \Prop type for propositions and for theorems,
% the dependent type, $ Γ ⊢ φ$ where $Γ$ has type $\abbre{List} \Prop$ and
% $φ$ has type $\Prop$.


% % ...................................................................

% % section section_name (end)
% \subsection{Structural Recursion}
% \label{ssec:structural-recursion}

% To emulate \Metis' inference rules in type theory,
% we observed that transformations performed by some rules were given by \emph{general recursive} functions.
% But algorithms based on general recursions can not be translated
% directly in type theory since it is not a guarantee they terminate.

% Then, we solve the termination problem by modifying problematic functions
% to be \emph{structural recursive}~\cite{Coquand1992,Abel2002,Bove2005}.

% We use the same notion of \emph{structurally smaller} from
% \citeauthor{Abel2002}~\cite{Abel2002} to say, a recursive function is
% structurally recursive if it calls itself with only
% \emph{structurally smaller}
% arguments.

% To convert a general recursive call into a structurally recursive call,
% we use the \emph{Bounded Recursion} technique presented
% in~\cite{Bertot2004} but
% others found in \cite{Coquand1992,Abel2002,Bove2005} could be used.
% This technique converts a general recursive
% function into a structural recursive function by adding an additional
% argument for the function complexity, the bound for the number of times, the function needs to call itself to get the final result.

% Then, we add the natural number $n : \Nat$ in the input of the
% general recursive function, and perform the recursion over the structure of
% \Nat type. \abbre{Nat} type is the usual type for natural numbers with \zero and \suc as their constructors. We consider the common arithmetic operations ($+,\,-,\,*$) and numbers $0,1,2,\dots$ as representations of $\zero, \suc, \suc(\zero), \dots$.

% Then, the type-checker will
% recognize structurally smaller arguments by using the lexicographic
% order~\cite{Abel2002} for such kind of functions.

% In other words, we take a general recursive function $f: \Prop \to \Prop$.
% and we redefine that function as
% $f: \Prop \to \Nat \to \Prop$, and perform the recursion
% using induction on the structure of the \Nat type.

% Let us consider the following example to exhibit the technique
% mentioned above for an inner function in the \strip inference.

% \begin{align}
% \begin{split}
% \label{eq:unshunt-definition}
% &unshunt_{0}(φ) =\\
% &\hspace{3mm}\begin{cases}
% unshunt_{0}((φ₁ ∧ φ₂) ⇒ φ₃),
%   & \text{if }φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\
% unshunt_{0}(φ₁ ⇒ φ₂) ∧ unshunt_{0}(φ₁ ⇒ φ₃),
%   & \text{if }φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃)\\
% φ, &\text{otherwise.}
% \end{cases}
% \end{split}
% \end{align}

% From the definition above, the size of the argument, ((φ₁ ∧ φ₂) ⇒ φ₃),
% is not structurally smaller than the input formula, (φ₁ ⇒ (φ₂ ⇒ φ₃)), since ((φ₁ ∧ φ₂) ⇒ φ₃) is not a subformula of (φ₁ ⇒ (φ₂ ⇒ φ₃)).

% Thus, we define the function
% $unshunt_{1} : \Prop \to \Nat \to \Prop$
% by structural recursion in its second argument in
% Eq.~(\ref{eq:unshunt-structured}).

% \begin{align}
% \label{eq:unshunt-structured}
% \begin{split}
% &unshunt_{1}(φ, \zero)\hspace{3mm}= φ\\
% &unshunt_{1}(φ, \suc(n)) =\\
% &\hspace{3mm}\begin{cases}
% unshunt_{1}((φ₁ ∧ φ₂) ⇒ φ₃, n),
%   &\text{if } φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\
% unshunt_{1}(φ₁ ⇒ φ₂, n) ∧\ unshunt_{1}(φ₁ ⇒ φ₃, n),
%    &\text{if } φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃).
% \end{cases}
% \end{split}
% \end{align}

% As we mentioned above, the natural number in the second argument of the
% function used in Eq.~(\ref{eq:unshunt-structured}) stands for a complexity
% measure of the function, in this case $unshunt_{1}$ function.

% A \emph{complexity measure} defined in \cite{Agudelo-Agudelo2017}
% and presented in \cite{VanDalen1994} as \emph{the rank for a
% proposition}, is a function $\Prop \to \Nat$ that assigns a natural
% number for a proposition φ as follows.

% \begin{equation*}
% \label{eq:rank-definition}
% rank(φ)=
% \begin{cases}
% 0, &\text{for atomic }φ \\
% rank(φ₁) + c_{¬},  &\text{if } φ ≡ \neg φ₁ \\
% \max{(rank(φ₁),rank(φ₂))} + c_{\square},
%   &\text{if } φ ≡ φ₁\,\square\, φ₂.
% \end{cases}
% \end{equation*}

% where $c_{¬}$ or $c_{\square}$ is a non-negative integer called the
% complexity of the connective.

% Recall, we want to maintain the same outputs as the original unshunt
% does in Eq.~(\ref{eq:unshunt-definition}) and the complexity measure of it,
% is a bound for the number of times this function can call itself.

% Therefore, we define an appropriate complexity measure
% $unshunt_{cm}: \Prop → \NN$ for our $unshunt_{1}$ function presented in
% Eq.~(\ref{eq:unshunt-rank-definition}).

% \begin{align}
% \begin{split}
% \label{eq:unshunt-rank-definition}
% &unshunt_{cm}(φ) =\\
% &\hspace{3mm}
% \begin{cases}
% unshunt_{cm}(φ₃) + 2, &\text{if }φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\
% \max(unshunt_{cm}(φ₂),unshunt_{cm}(φ₃)) + 1,
%   &\text{if }  φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃)\\
% 0, &\text{otherwise.}
% \end{cases}
% \end{split}
% \end{align}

% Finally, the curated version of $unshunt_{0}$ function is presented
% in Eq.~(\ref{eq:unshunt-fixed}).

% \begin{equation}
% \label{eq:unshunt-fixed}
% unshunt(\varphi) := unshunt_{1}(\varphi, unshunt_{cm}(\varphi)).
% \end{equation}

% For a more complete treatment of general recursion, and how to
% define well-founded and well-structural recursive functions, we refer
% the reader to Ref.~\cite{Bove2005}, where Bove and Capettra described
% not only general recursion, but they also treat mutual recursive
% function, among other kinds.

% % ................................................

% \subsection{Emulating \Metis' Inference Rules}
% \label{ssec:emulating-inferences}


% \subsubsection{Splitting a Goal.}
% \label{sssec:splitting-goal}

% The goal of a problem to be proved by \Metis is processed to generate new
% propositions, the new targets, \Metis calls these formulas
% \emph{subgoals}.

% The conjunction of these subgoals is a proposition equivalent to the
% original goal. Then, we find a refutation for each subgoal in the \Metis' \TSTP derivation.

% Nevertheless, \Metis does not provide neither an explanation for the user about the process in its \TSTP derivations nor in its documentation.

% In the following, we show how Theorem.~\ref{thm:thm-strip} proves the correctness of the process mentioned above. But first, let prove some lemmas for $unshunt$ function presented in Eq.~(\ref{eq:unshunt-fixed}),
% and $split$ function from the definition in Eq.~(\ref{eq:split-definition}).

% \begin{lemma}[lem-unshunt]
%   \label{lem:unshunt}
%   $Γ ⊢ unshunt(φ)$, then $Γ ⊢ φ$.
% \end{lemma}

% \begin{proof} Use induction on the cases defined by the outcome of the
% $unshunt$ function in Eq.~(\ref{eq:unshunt-structured}).
% When $n = 0$, by definition, $Γ ⊢ φ$.
% When $n = 1$, we apply the following theorem from~\cite{AgdaProp}

% \begin{equation*}
% \texttt{∧⇒-to-⇒⇒}\ :\  Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃ → Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃).
% \end{equation*}

% For $n > 1$, we will use induction on the structure of second
% argument.

% (φ₁ ⇒ (φ₂ ⇒ φ₃))
% \begin{equation*}
%   \begin{bprooftree}
%   \AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n)$}
%   \RightLabel{By def.}
%   \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ (φ₂ ⇒ φ₃), n-1)$}
%   \RightLabel{lem-unshunt}
%   \UnaryInfC{Γ ⊢ (φ₁ ∧ φ₂) ⇒ φ₃}
%   \RightLabel{∧⇒-to-⇒⇒}
%   \UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ⇒ φ₃).}
%   \end{bprooftree}
% \end{equation*}

% Second, using the following theorem from \cite{AgdaProp},

% \begin{equation*}
%   \texttt{⇒∧-to-⇒∧}\ :\ Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃) → Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃).
% \end{equation*}

% ($φ₁ ⇒ (φ₂ ∧ φ₃)$)
% \begin{equation*}
% \scalebox{0.95}{
% ($\mathcal{D}_1$)
% \begin{bprooftree}
% \AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n) ∧ unshunt(φ₁ ⇒ φ₃, n)$}
% \RightLabel{∧-proj₁}
% \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n)$}
% \RightLabel{By def.}
% \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂, n-1)$}
% \RightLabel{lem-unshunt}
% \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$,}
% \end{bprooftree}
% }
% \end{equation*}

% \begin{equation*}
% (\mathcal{D}_2)
% \begin{bprooftree}
% \AxiomC{$Γ ⊢ unshunt(φ₁ ⇒ φ₂) ∧ unshunt(φ₁ ⇒ φ₃)$}
% \RightLabel{∧-proj₂}
% \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₃, n)$}
% \RightLabel{By def.}
% \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ φ₃, n-1)$}
% \RightLabel{lem-unshunt}
% \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₃$,}
% \end{bprooftree}
% \end{equation*}

% \begin{equation*}
%   \begin{bprooftree}
%   \AxiomC{$\mathcal{D}_1$}
%   \AxiomC{$\mathcal{D}_2$}
%   \RightLabel{∧-intro}
%   \BinaryInfC{$Γ ⊢ (φ₁ ⇒ φ₂) ∧ (φ₁ ⇒ φ₃)$}
%   \RightLabel{⇒∧⇒-to-⇒∧}
%   \UnaryInfC{Γ ⊢ φ₁ ⇒ (φ₂ ∧ φ₃).}
%   \end{bprooftree}
% \end{equation*}
% \end{proof}

% Now, let us consider the $split$ function presented in
% Eq.~(\ref{eq:split-definition}) that yields a conjunction of subgoals from a proposition, the goal in \Metis.

% \begin{equation}
% \label{eq:split-definition}
% \mysplit(φ) =
% \begin{cases}
% unshunt(\mysplit(φ₁)) &\text{if }φ ≡ φ₁ ∧ φ₂\\
% ∧\ unshunt(φ₁ ⇒ \mysplit(φ₂)), &\\[2.5mm]
% unshunt(¬ φ₁ ⇒ \mysplit(φ₂)),
%   & \text{if }φ ≡ φ₁ ∨ φ₂\\[2.5mm]
% unshunt(φ₁ ⇒ \mysplit(φ₂)),
%   & \text{if }φ ≡ φ₁ ⇒ φ₂\\[2.5mm]
% unshunt(φ₁ ⇒ \mysplit(φ₂))
%   & \text{if }φ ≡ φ₁ ⇔ φ₂\\
% ∧\ unshunt(φ₂ ⇒ \mysplit(φ₁)),
%   &\\[2.5mm]
% unshunt(φ₁ ⇒ \mysplit(¬ φ₂)),
%   & \text{if }φ ≡ ¬ (φ₁ ∧ φ₂)\\[2.5mm]
% unshunt(\mysplit(¬ φ₁))
%   & \text{if }φ ≡ ¬ (φ₁ ∨ φ₂)\\
% ∧\ unshunt(¬ φ₁ ⇒ \mysplit(¬ φ₂)),
%   &\\[2.5mm]
% unshunt(\mysplit(φ₁))
%   & \text{if }φ ≡ ¬ (φ₁ ⇒ φ₂)\\
% ∧\ unshunt(φ₁ ⇒ \mysplit(¬ φ₂)),
%   &\\[2.5mm]
% unshunt(φ₁ ⇒ \mysplit(¬ φ₂))
%   & \text{if }φ ≡ ¬ (φ₁ ⇔ φ₂)\\
% ∧\ unshunt(¬ φ₂ ⇒ \mysplit(φ₁)),
%   &\\[2.5mm]
% unshunt(\mysplit(φ₁)),
%   & \text{if }φ ≡ ¬ ¬ φ₁\\
% ⊤,
%   & \text{if }φ ≡ ¬ ⊥\\
% ⊥,
%   & \text{if }φ ≡ ¬ ⊤.
% \end{cases}
% \end{equation}

% The definition above suffers termination problems since it is not
% a structural recursion. Therefore, we have reformulated Def.~\ref{eq:split-definition} to solve such a issue following the technique
% described in Section~\ref{ssec:structural-recursion}.
% Here and below, we refer to $split$ as the function after applying
% the process mentioned above.

% \begin{lemma}[\thmsplit] $Γ ⊢ \mysplit(φ)$ then $Γ ⊢ φ$.
% \label{lem:lem-split}
% \end{lemma}

% \begin{proof} We now proceed by induction on the structure of the
% formula φ in the definition of Eq.~(\ref{eq:split-definition}).
% For a complete proof, we refer the reader to~\cite{AgdaMetis}.\\[3mm]

% ($φ ≡ φ₁ ∧ φ₂$). We get a proof for each conjunct and using the introduction rule for conjunction, the result follows.

% \begin{equation*}
% (\mathcal{D})\hspace{3mm}
%   \begin{bprooftree}
%   \AxiomC{$Γ ⊢ \mysplit(φ,n)$}
%   \RightLabel{By def.}
%   \UnaryInfC{$Γ ⊢ unshunt(φ₁) ∧ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
%   \RightLabel{∧-proj₁}
%   \UnaryInfC{$Γ ⊢ unshunt(φ₁)$}
%   \RightLabel{lem-unshunt}
%   \UnaryInfC{$Γ ⊢ φ₁$.}
%   \end{bprooftree}
% \end{equation*}

% \begin{equation*}
%   \begin{bprooftree}
%   \AxiomC{$\mathcal{D}$}
%   \UnaryInfC{Γ ⊢ φ₁}
%   \AxiomC{$Γ ⊢ \mysplit(φ,n)$}
%   \RightLabel{By def.}
%   \UnaryInfC{$Γ ⊢ unshunt(φ₁) ∧ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
%   \RightLabel{$∧$-proj$₂$}
%   \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
%   \RightLabel{lem-unshunt}
%   \UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
%   \RightLabel{$⇒$-elim}
%   \BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
%   \RightLabel{\thmsplit}
%   \UnaryInfC{$Γ ⊢ φ₂.$}
%   \end{bprooftree}
% \end{equation*}

% \vskip 3mm

% ($φ ≡ φ₁ ⇒ φ₂$).
% \begin{equation*}
%   \begin{bprooftree}
%   \AxiomC{}
%   \RightLabel{assume φ₁}
%   \UnaryInfC{$Γ , φ₁ ⊢ φ₁$}
%   \AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
%   \RightLabel{By def.}
%   \UnaryInfC{$Γ ⊢ unshunt(φ₁ ⇒ \mysplit(φ₂,n-1))$}
%   \RightLabel{lem-unshunt}
%   \UnaryInfC{$Γ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
%   \RightLabel{weaken φ₁}
%   \UnaryInfC{$Γ , φ₁ ⊢ φ₁ ⇒ \mysplit(φ₂,n-1)$}
%   \RightLabel{⇒-elim}
%   \BinaryInfC{$Γ , φ₁ ⊢ \mysplit(φ₂,n-1)$}
%   \RightLabel{\thmsplit}
%   \UnaryInfC{$Γ , φ₁ ⊢ φ₂$}
%   \RightLabel{⇒-intro}
%   \UnaryInfC{$Γ ⊢ φ₁ ⇒ φ₂$.}
%   \end{bprooftree}
% \end{equation*}
% \vskip 3mm

% (φ ≡ ¬ (φ₁ ∨ φ₂)). We show $Γ ⊢ ¬ φ₁$ and $Γ ⊢ ¬ φ₂$. Using their conjunction by the introduction rule, and De Morgan Law, the results follows.

% \begin{equation*}
% (\mathcal{D})\hspace{3mm}
% \begin{bprooftree}
% \AxiomC{$Γ ⊢ \mysplit(φ, n)$}
% \RightLabel{By def.}
% \UnaryInfC{$Γ ⊢ unshunt(¬ φ₁) ∧ unshunt(¬ φ₁ ⇒ \mysplit(φ₂, n))$}
% \RightLabel{∧-proj₁}
% \UnaryInfC{$Γ ⊢ unshunt(¬ φ₁)$}
% \RightLabel{lem-unshunt}
% \UnaryInfC{$Γ ⊢ ¬ φ₁$,}
% \end{bprooftree}
% \end{equation*}

% \begin{equation*}
%   \begin{bprooftree}
%   \AxiomC{$\mathcal{D}$}
%   \UnaryInfC{$Γ ⊢ ¬ φ₁$}

%   \AxiomC{$Γ ⊢ \mysplit(φ,n-1)$}
%   \RightLabel{By def.}
%   \UnaryInfC{$Γ ⊢ unshunt(¬ φ₁) ∧ unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
%   \RightLabel{∧-proj₂}
%   \UnaryInfC{$Γ ⊢ unshunt(¬ φ₁ ⇒ \mysplit(φ₂,n-1))$}
%   \RightLabel{lem-unshunt}
%   \UnaryInfC{$Γ ⊢ ¬ φ₁ ⇒ \mysplit(φ₂,n-1)$}
%   \RightLabel{⇒-elim}
%   \BinaryInfC{$Γ ⊢ \mysplit(φ₂,n-1)$}
%   \RightLabel{\thmsplit}
%   \UnaryInfC{$Γ ⊢ ¬ φ₂.$}
%   \end{bprooftree}
% \end{equation*}
% \end{proof}

% \begin{theorem}[thm-strip]
% \label{thm:thm-strip}
%  If $s_i$ are the subgoals for the goal φ, and
% $\{ Γ ⊢ s_i \}_{i}$, then $Γ ⊢ φ$.
% \end{theorem}

% \begin{proof}
% \begin{equation*}
%   \begin{bprooftree}
%   \AxiomC{$\left\{ Γ ⊢ s_i \right\}_{i}$}
%   \RightLabel{∧-intro}
%   \UnaryInfC{$Γ ⊢ \bigwedge_i s_i$}

%   \AxiomC{$\mysplit(φ) ≡ \bigwedge_i s_i $}
%   \RightLabel{subst}
%   \BinaryInfC{$Γ ⊢ \mysplit(φ) $}

%   \RightLabel{\thmsplit}
%   \UnaryInfC{$Γ ⊢ φ$.}
% \end{bprooftree}
% \end{equation*}
% Where, the $subst$ theorem is,
% \begin{equation}
%   \label{eq:substitution-theorem}
%   \begin{bprooftree}
%   \AxiomC{$Γ ⊢ φ$}   \AxiomC{$ψ ≡ φ$}
%   \RightLabel{subst}
%   \BinaryInfC{$Γ ⊢ ψ$.}
%   \end{bprooftree}
% \end{equation}
% \end{proof}

% % -------------------------------------------------------------------
% \subsubsection{splitting a Conjunct}
% \label{sssec:splitting-a-conjunct}

% The \conjunct rule extracts from a conjunction, one of its conjunct.
% To achieve this, we use projections repeatedly until we finally find
% the conjunct required.

% \begin{align}
%   \begin{split}
%   conjunct(φ, ψ) =
%     \begin{cases}
%       ψ, &\text{if }φ ≡ ψ\\
%       ψ, &\text{if }φ ≡ φ₁ ∧ φ₁\text{ and }conjunct(φ₁, ψ)≡ ψ\\
%       ψ, &\text{if }φ ≡ φ₁ ∧ φ₁\text{ and }conjunct(φ₂, ψ)≡ ψ\\
%       φ, &\text{otherwise.}
%     \end{cases}
%   \end{split}
% \end{align}

% \begin{theorem}[thm-conjunct]
%   \label{thm:thm-conjunct}
%   $Γ ⊢ φ$, and $ψ \in \Prop$ , then $Γ ⊢ conjunct(φ, ψ)$.
% \end{theorem}

% \begin{proof}
% When φ ≡ ψ, from $Γ ⊢ conjunct(φ, ψ)$ by normalization, we get $Γ ⊢ ψ$.
% By using $subst$ theorem Eq.~(\ref{eq:substitution-theorem}), we get the desire conclusion. If the proposition φ is a conjunction, and $ψ ≡ conjunct(φ_{i}, ψ)$
% for some $i = 1,\ 2$, then,

% \begin{equation}
%   \begin{bprooftree}
%   \AxiomC{$Γ ⊢ φ₁ ∧ φ₂$}
%   \RightLabel{∧-proj$_{i}$}
%   \UnaryInfC{$Γ ⊢ φ_{i}$}
%   \UnaryInfC{$Γ ⊢ conjunct(φ_{i}, ψ)$}
%   \AxiomC{$conjunct(φ_{i}, ψ) ≡ ψ$}
%   \RightLabel{subst}
%   \BinaryInfC{$Γ ⊢ ψ$.}
%   \end{bprooftree}
% \end{equation}

% The last statement follows by using the hypothesis and the proof is complete.
% \end{proof}

% % subsubsection splitting-a-conjunct (end)
% % -------------------------------------------------------------------

% % ------------------------------------------------------------------------

% \subsubsection{Reordering.}

% Syntactically speaking, showing the logic equivalence between two conjunctive normal forms is a matter of rearrangements of the conjunctions
% but also of the inner disjunctions inside the propositions involved.
% \improvement{Make clear: we are dealing with CNFs, and prove equivalence between two formulas is equivalent to show two trees are  isomorphic.
% And that problem is NP-hard, and for that, we mostly do brute force.}

% We provide some useful theorems to perform the following tasks.

% \begin{itemize}
%   \item Reorder a disjunction like $φ = φ₁ ∨ φ₂ ∨ \cdots$ to match with another disjunction $ψ = ψ₁ ∨ ψ₂ ∨ \cdots$, when $φ$ is a disjunct of $ψ$.
%   \item Reorder a conjunction of disjuncts (CNF), $φ = φ₁ ∧ φ₂ ∧ \cdots$, to match with another CNF formula equivalent $ψ = ψ₁ ∧ ψ₂ ∧ \cdots$.
% \end{itemize}

% First, we define the $rdisj$ function in Eq.~(\ref{eq:rdisj-def}) to convert a disjunction to be a right-associative disjunction, and following
% a similar approach we define the $rconj$ function for conjunctions.

% \begin{align}
%   \begin{split}
%     \label{eq:rdisj-def}
%     rdisj(φ) =
%     \begin{cases}
%     rdisj(φ₁ ∨ (φ₂ ∨ φ₃)),  & \text{if } φ ≡ (φ₁ ∨ φ₂) ∨ φ₃\\
%     φ₁ ∨ rdisj(φ₂),         & \text{if } φ ≡ φ₁ ∨ φ₂\\
%     φ,                      & \text{otherwise.}
%     \end{cases}
%   \end{split}
% \end{align}

% \begin{lemma}[lem-rdisj]
% \label{lem:lem-rdisj}
%   $Γ ⊢ φ$ then $Γ ⊢ rdisj(φ)$.
% \end{lemma}

% The following function, $build_{∨} : \Prop → \Prop → \Prop$ in Eq.~(\ref{eq:build-or}), intends to construct a disjunction from another disjunction, specifically, we want to rearrange the disjuncts in the source formula to match with the target disjunction for syntactic
% equivalence.

% \begin{equation}
%   \begin{split}
%   \label{eq:build-or}
%   &build_{∨}(φ, ψ) =\\
%   &\hspace{3mm}
%   \begin{cases}
%   ψ, &\text{if } φ ≡ ψ\\
%   ψ, &\text{if } ψ ≡ ψ₁ ∨ ψ₂\text{ and } build_{∨}(φ, ψ_{i}) ≡ ψ_{i}\text{ for some }i=1, 2\\
%   φ, &\text{otherwise.}
%   \end{cases}
%   \end{split}
% \end{equation}

% \begin{lemma}[lem-build$_{∨}$]
% \label{lem:lem-build-or}
% $Γ ⊢ φ$, and $ψ\in \Prop$ then $Γ ⊢ build_{∨}(φ)$.
% \end{lemma}

% The function $factor : \Prop → \Prop$  in Eq.~(\ref{eq:factor-definition}) is intended to work only for right-associative disjunctions, and reduces a disjunction of the same disjunct (e.g., $factor(φ ∨ (φ ∨ \cdots)) \mapsto\ φ$).

% \begin{align}
% \begin{split}
%   \label{eq:factor-definition}
%   factor(φ) =
%   \begin{cases}
%     φ₁,  &\text{if }φ ≡ φ₁ ∨ φ₂ \text{ and } φ₁ ≡ factor(φ₂)\\
%     φ,   &\text{otherwise.}
%   \end{cases}
% \end{split}
% \end{align}

% \begin{lemma}[lem-factor]
% \label{lem:lem-factor}
%   $Γ ⊢ φ$ then $Γ ⊢ factor(φ)$.
% \end{lemma}

% Now, with a right-associative disjunction by applying $rdisj$ function to
% a proposition $φ$, $sbuild_{∨}: \Prop → \Prop → \Prop$ in
% Eq.~(\ref{eq:strong-build-or-definition}) aims to construct the disjunction
% ψ by using each of its disjuncts from the proposition φ. This approach to
% build a disjunction from another is inspired on the description in
% \citeauthor{bohme2010}~\cite{bohme2010} to prove equality between nested
% disjunctions. \change{Make clear this, It's not clear the difference with build-or and sbuild-or.}

% \begin{align}
%   \begin{split}
%   \label{eq:strong-build-or-definition}
%     sbuild_{∨}(φ, ψ) =
%     \begin{cases}
%       factor(build_{∨}(φ₁, ψ) ∨ build_{∨}(φ₂,ψ)),  &\text{if }φ≡ φ₁ ∨ φ₂\\
%       build_{∨}(φ, ψ),  & \text{otherwise.}
%     \end{cases}
%   \end{split}
% \end{align}

% \begin{lemma}[lem-sbuild$_{∨}$]
% \label{lem:lem-sbuild-or}
% $Γ ⊢ φ$, and $ψ \in\Prop$ then $Γ ⊢ sbuild_{∨}(φ, ψ)$.
% \end{lemma}

% Let see the following example of the idea behind $sbuild_{∨}$
% function; from the disjunction $(r ∨ (q ∨ p))$, we build the disjunction
% $((p ∨ q) ∨ r)$.

% \begin{equation*}
%   \begin{bprooftree}
%   \AxiomC{$Γ ⊢ q$}
%   \RightLabel{∨-intro₂}
%   \UnaryInfC{$Γ ⊢ p ∨ q$}
%   \RightLabel{∨-intro₁}
%   \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

%   \AxiomC{$Γ ⊢ p$}
%   \RightLabel{∨-intro₁}
%   \UnaryInfC{$Γ ⊢ p ∨ q$}
%   \RightLabel{∨-intro₁}
%   \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

%   \RightLabel{∨-elim}
%   \BinaryInfC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}
%   \end{bprooftree}
% \end{equation*}

% \begin{equation*}
%   \begin{bprooftree}
%   \AxiomC{$Γ ⊢ r$}
%   \RightLabel{∨-intro₂}
%   \UnaryInfC{$Γ ⊢ (p ∨ q) ∨ r$}

%   \AxiomC{$Γ, q ∨ p ⊢ (p ∨ q) ∨ r$}

%   \RightLabel{∨-elim}
%   \BinaryInfC{$Γ, r ∨ (q ∨ p) ⊢ (p ∨ q) ∨ r$}

%   \RightLabel{⇒-intro}
%   \UnaryInfC{$Γ ⊢ r ∨ (q ∨ p) ⇒ (p ∨ q) ∨ r$}

%   \end{bprooftree}
% \end{equation*}

% \begin{theorem}[thm-reorder$_{∨}$]
%   \label{thm-reorder-or}
%   $Γ ⊢ φ$, and $ψ\in\Prop$ then $Γ ⊢ reorder_{∨}(φ, ψ)$, where,
%   \begin{equation*}
%     \label{eq:reorder-or}
%     reorder_{∨} (φ, ψ) = sbuild_{∨}(rdisj(φ), ψ).
%   \end{equation*}
% \end{theorem}

% \begin{proof} Use Lemma~\ref{lem:lem-rdisj} and Lemma~\ref{lem:lem-sbuild-or}.
% \end{proof}

% To work with nest conjunctions of disjunctions (CNFs), we define similar
% functions and theorems as we previously did for disjunctions.

% \begin{lemma}[lem-reorder$_{∧}$]
%   \label{lem:lem-reorder-and}
%   $Γ ⊢ φ$, and $ψ \in\Prop$ then $Γ ⊢ reorder(φ, ψ)$, where,
%   \begin{align*}
%       \begin{split}
%         reorder_{∧}(φ, ψ) =
%         \begin{cases}
%           φ, &\text{if }φ ≡ ψ\\
%           ψ₁ ∧ ψ₂, &\text{if } ψ ≡ ψ₁ ∧ ψ₂\text{, }reorder_{∧}(φ, ψ₁) ≡ ψ₁\\
%                   &\text{and }reorder_{∧}(φ, ψ₂)≡ ψ₂\\
%           φ,       &\text{if } ψ ≡ ψ₁ ∧ ψ₂\\
%           conjunct(φ, ψ) &\text{otherwise.}
%         \end{cases}
%       \end{split}
%   \end{align*}
% \end{lemma}

% \begin{lemma}[lem-conjunct$_{∨}$]
%   \label{lem:lem-conjunct-or}
%   $Γ ⊢ φ$, and $ψ \in\Prop$ then $Γ ⊢ conjunct_{∨}(φ, ψ)$, where,
%   \improvement{The first case is not implemented in Agda}
%   \begin{align*}
%   \begin{split}
%     \label{eq:conjunct-or-definition}
%     conjunct_{∨}(φ, ψ) =
%     \begin{cases}
%       ψ, &\text{if }φ ≡ ψ\\
%       ψ, &\text{if }reorder_{∨}(φ, ψ) ≡ ψ\\
%       ψ, &\text{if }ψ ≡ ψ₁ ∧ ψ₂, conjunct_{∨}(φ, ψ₁) ≡ ψ₁\\
%         &\text{and } reorder_{∨}(φ, ψ₂) ≡ ψ₂\\
%       ψ, &\text{if }φ ≡ φ₁ ∧ φ₂, conjunct_{∨}(φ₁, ψ) ≡ ψ\\
%       ψ, &\text{if }φ ≡ φ₁ ∧ φ₂, conjunct_{∨}(φ₂, ψ) ≡ ψ\\
%       φ, &\text{otherwise.}
%     \end{cases}
%   \end{split}
%   \end{align*}
% \end{lemma}

% \begin{theorem}[thm-reorder$_{∧∨}$]
%   \label{thm:thm-reorder-and-or}

%   $Γ ⊢ φ$, and $ψ \in\Prop$ then $Γ ⊢ reorder_{∧∨}(φ, ψ)$, where,

%   \begin{align}
%       \begin{split}
%       reorder_{∧∨}(φ, ψ)=
%         \begin{cases}
%           ψ, &\text{if } φ≡ψ\\
%           ψ, &\text{if } ψ ≡ ψ₁ ∧ ψ₂, reorder_{∧∨}(φ,ψ₁) ≡ ψ₁\\
%              &\text{and }reorder_{∧∨}(φ, ψ₂) ≡ ψ₂\\
%           φ, &\text{if }ψ ≡ ψ₁ ∧ ψ₂\\
%           conjunct_{∨}(φ, ψ) &\text{otherwise.}
%         \end{cases}
%       \end{split}
%   \end{align}
% \end{theorem}

% % --------------------------------------------------------------------

% \subsubsection{Resolve.}
% \label{sssec:resolve}

% The \resolve rule is a generalization version for resolution in propositional logic since the formulas are not shaped always as the aforementioned theorem expects (see Fig.~\ref{fig:metis-inferences}).

% Since our approach is mere syntactic, in order to apply such a
% theorem, we perform rearrangements inside the formulas to match with
% the pattern expected by the resolution theorem.

% \begin{lemma}[lem-rsol]
%   \label{lem:lem-rsol}
%   $Γ ⊢ φ$ then $Γ ⊢ rsol(φ)$, where,
%   \begin{align*}
%       \begin{split}
%         rsol(φ) =
%         \begin{cases}
%           φ₂, &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (φ₃ ∨ φ₄), φ₃ ≡ ¬ φ₁, φ₂ ≡ φ₄\\
%           φ₂ ∨ φ₄, &\text{ if }φ ≡ (φ₁ ∨ φ₂) ∨ (φ₃ ∨ φ₄), φ₃ ≡ ¬ φ₁\\
%           φ, &\text{otherwise.}
%         \end{cases}
%       \end{split}
%   \end{align*}
% \end{lemma}

% \begin{theorem}[thm-resolve]
%   \label{thm:thm-resolve}
%   $Γ ⊢ φ₁$, $Γ ⊢ φ₂$, a literal $l$, and $ψ\in\Prop$ then $Γ ⊢ resolve(φ₁, φ₂, l, ψ)$, where,
%   \begin{equation*}
%     resolve(φ₁, φ₂, l, ψ) =
%       rsol(reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨} (φ₂, ¬ l ∨ ψ)).
%   \end{equation*}
% \end{theorem}

% \begin{proof}
% \begin{equation*}
%   \begin{bprooftree}
%     \AxiomC{$Γ ⊢ φ₁$}
%     \RightLabel{thm-reorder$_{∨}$}
%     \UnaryInfC{$Γ ⊢ reorder_{∨}(φ₁, l ∨ ψ)$}

%     \AxiomC{$Γ ⊢ φ₂$}
%     \RightLabel{thm-reorder$_{∨}$}
%     \UnaryInfC{$Γ ⊢ reorder_{∨}(φ₂, ¬ l ∨ ψ)$}

%     \RightLabel{∧-intro}
%     \BinaryInfC{$Γ ⊢ reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨}(φ₂, ¬ l ∨ ψ)$}
%     \RightLabel{lem-rsol}
%     \UnaryInfC{$Γ ⊢ rsol(reorder_{∨}(φ₁, l ∨ ψ) ∧ reorder_{∨}(φ₂, ¬ l ∨ ψ))$}
%   \end{bprooftree}
%   \end{equation*}
% \end{proof}

% % subsubsection resolve (end)
% % --------------------------------------------------------------------


% % --------------------------------------------------------------------

% \subsubsection{Normal Forms.}
% \label{sssec:normal_forms}
% \change{Here lacks of an introduction!}
% A negative normal form for the formula φ is one in which negations
% appear only in the literals and the expression is in terms only of
% the boolean operators (¬, ∧, ∨).

% To transform a formula φ to its equivalent \abbre{NNF} form, we
% apply recursively the following equations. The function type for
% \name{nnf} is $\Prop \to \Prop$.

% \begin{lemma}[lem-nnf]
%   \label{lem:lem-nnf}
%   $Γ ⊢ φ$ then $Γ ⊢ nnf(φ)$, where,
%   \begin{align*}
%     \begin{split}
%     \label{eq:nnf-definition}
%     nnf(φ) =
%       \begin{cases}
%       nnf(φ₁) ∧ nnf(φ₂),
%          &\text{if }φ ≡ φ₁ ∧ φ₂ \\
%       nnf(φ₁) ∨ nnf(φ₂),
%          &\text{if }φ ≡ φ₁ ∨ φ₂ \\
%       nnf(¬ φ₁ ∨ φ₂),
%          &\text{if }φ ≡ φ₁ ⇒ φ₂ \\
%       nnf(φ₁ ⇒ φ₂ ∧ φ₂ ⇒ φ₁),
%          &\text{if }φ ≡ φ₁ ⇔ φ₂ \\
%       nnf(¬ φ₁ ∨ ¬ φ₂),
%          &\text{if }φ ≡ ¬ (φ₁ ∧ φ₂) \\
%       nnf(¬ φ₁ ∧ ¬ φ₂),
%          &\text{if }φ ≡ ¬ (φ₁ ∨ φ₂) \\
%       nnf(φ₁),
%          &\text{if }φ ≡ ¬ ¬ φ₁ \\
%       nnf(¬ (φ₂ ∨ ¬ φ₁)),
%          &\text{if }φ ≡ ¬ (φ₁ ⇒ φ₂) \\
%       nnf(¬ (φ₁ ⇒ φ₂ ∧ φ₂ ⇒ φ₁)),
%          &\text{if }φ ≡ ¬ (φ₁ ⇔ φ₂) \\
%       ⊥,  &\text{if }φ ≡ ¬ ⊤ \\
%       ⊤,  &\text{if }φ ≡ ¬ ⊥ \\
%       φ,  & \text{otherwise}.
%       \end{cases}
%     \end{split}
%   \end{align*}
% \end{lemma}

% \begin{lemma}[lem-dist$_{∨}$]
%   \label{lem:lem-dist-or}
%   $Γ ⊢ φ$ then $Γ ⊢ dist_{∨}(φ)$, where,
%   \begin{align*}
%       \begin{split}
%       dist_{∨}(φ) =
%         \begin{cases}
%           dist_{∨}(φ₁ ∨ φ₂) ∧ dist_{∨}(φ₂ ∨ φ₃),
%             &\text{if }φ ≡ (φ₁ ∧ φ₂) ∨ φ₃\\
%           dist_{∨}(φ₁ ∨ φ₃) ∧ dist_{∨}(φ₁ ∨ φ₃),
%             &\text{if }φ ≡ φ₁ ∨ (φ₂ ∧ φ₃)\\
%           φ, &\text{otherwise.}
%         \end{cases}
%       \end{split}
%   \end{align*}
% \end{lemma}

% \begin{lemma}[lem-dist]
%   \label{lem:lem-dist}
%   $Γ ⊢ φ$ then $Γ ⊢ dist(φ)$, where,
%   \begin{align*}
%       \begin{split}
%       dist(φ) =
%         \begin{cases}
%           dist(φ₁) ∧ dist(φ₂),
%             &\text{if }φ ≡ φ₁ ∧ φ₂\\
%           dist_{∨}(dist(φ₁) ∨ dist(φ₂)),
%             &\text{if }φ ≡ φ₁ ∨ φ₂\\
%           φ, &\text{otherwise.}
%         \end{cases}
%       \end{split}
%   \end{align*}
% \end{lemma}

% \begin{sketchproof}
% Case when $φ ≡ φ₁ ∨ φ₂$.\\
% For $i = 1, 2$,
% \begin{equation}
%   \begin{bprooftree}
%     \RightLabel{assume}
%     \AxiomC{$Γ, φ_{i} ⊢ φ_{i}$}
%     \RightLabel{lem-dist}
%     \UnaryInfC{$Γ ⊢ dist(φ_{i})$}
%     \RightLabel{∨-intro$_{1,2}$}
%     \UnaryInfC{$Γ, φ_{i} ⊢ dist(φ₁) ∨ dist(φ₂)$}
%     \RightLabel{lem-dist$_{∨}$}
%     \UnaryInfC{$Γ, φ_{i} ⊢ dist_{∨}(dist(φ₁) ∨ dist(φ₂))$.}
%     \end{bprooftree}
% \end{equation}
% Then, by using the ∨-elim rule, from the last derivation above we derive
% $Γ, φ₁ ∨ φ₂ ⊢ dist_{∨}(dist(φ₁) ∨ dist(φ₂))$, and the lemma follows.
% \end{sketchproof}

% \begin{theorem}[thm-cnf]
% \label{thm:thm-cnf}
%   $Γ ⊢ φ$ then $Γ ⊢ cnf(φ)$, where,
%   \begin{equation}
%     cnf(φ) = (dist \circ nnf) (\varphi).
%   \end{equation}
% \end{theorem}

% \begin{proof}
%   Composition of the Lemma \ref{lem:lem-dist} and Lemma \ref{lem:lem-nnf}.
% \end{proof}
% % subsubsection normal_forms (end)
% % --------------------------------------------------------------------

% % --------------------------------------------------------------------

% \subsubsection{Clausification.}
% \label{sssec:clausification}

% \begin{theorem}[thm-clausify]
% \label{thm:thm-clausify}
%   $Γ ⊢ φ$ and $ψ \in\Prop$ then $Γ ⊢ clausify(φ, ψ)$, where,
%   \begin{align}
%       clausify(φ,ψ) =
%       \begin{cases}
%         ψ, &\text{ if }φ≡ψ\\
%         reorder_{∧∨}(cnf(φ), ψ), &\text{otherwise.}
%       \end{cases}
%   \end{align}
% \end{theorem}

% \begin{proof} When $φ ≡ ψ$, we use the $subs$ theorem Eq.~(\ref{eq:substitution-theorem}). Otherwise, we use Theorem \ref{thm:thm-reorder-and-or} and Theorem \ref{thm:thm-cnf}.
% \end{proof}

% % subsubsection clausification (end)
% % --------------------------------------------------------------------

% % --------------------------------------------------------------------
% \subsubsection{Normalization.}
% \label{sssec:normalization}

% In a disjunction, $φ = φ₁ ∨ φ₂ ∨ \cdots ∨ φₙ$, we say $ψ ∈_{∨} φ$,
% if there is some $i = 1, \cdots, n$ such that $ψ = φᵢ$.
% Then, we define the $rm_{∨}$ function to remove in a right-associative disjunction φ, those propositions ψ repeated in the formula.

% \begin{equation*}
% \label{eq:rm-or}
%   rm_{∨}(φ) =
%   \begin{cases}
%     rm_{∨}(φ₂), &\text{if }φ ≡ φ₁ ∨ φ₂, φ₁ ∈_{∨} φ₂\\
%     φ₁ ∨ rm_{∨}(φ₂), &\text{if }φ ≡ φ₁ ∨ φ₂\\
%     φ,  &\text{otherwise.}
%   \end{cases}
% \end{equation*}

% Since, our goal consists of normalizing prepositions in \abbre{CNF}, we also need to generalize $rm_{∨}$ to work with conjunctions. We define $rm_{∧∨}$ function for that purpose.

% \begin{equation*}
% \label{eq:rm-and-or}
%   rm_{∧∨}(φ) =
%   \begin{cases}
%     rm_{∧∨}(φ₁) ∧ rm_{∧∨}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂\\
%     rm_{∨}(rdisj(φ)),  &\text{otherwise.}
%   \end{cases}
% \end{equation*}

% Now, we have removed redundancies in the disjunctions, we move forward and we remove redundancies at the level of the conjunction of the CNFs by applying the $rm_{∧}$ function. We define $ψ ∈_{∧} φ$ similar as we described above for disjunction. In a conjunction, $φ = φ₁ ∧ φ₂ ∧ \cdots ∧ φₙ$, we say
% $ψ ∈_{∧} φ$, if there is some $i = 1, \cdots, n$ such that $ψ = φᵢ$.

% \begin{equation*}
% \label{eq:rm-and}
%   rm_{∧}(φ) =
%   \begin{cases}
%     rm_{∧}(φ₁) ∧ rm_{∧}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂, φ₁ ∈_{∧} φ₂\\
%     φ₁ ∧ rm_{∧}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂\\
%     φ,  &\text{otherwise.}
%   \end{cases}
% \end{equation*}

% Finally, we remove redundancies in a proposition assuming that it is given in conjunctive normal form and right-associative, by composing the functions described above in the Eq.~(\ref{eq:redun-ast})
% for the function $redun^{*}$.

% \begin{equation*}
%   \label{eq:redun-ast}
%   redun^{*} = rm_{∧} ∘ rm_{∧∨}.
% \end{equation*}

% Then, performing rearrangements to match with the expected output
% by $redon^{*}$ function.

% \begin{equation*}
%   \label{eq:redun}
%   redun(φ) = reorder_{∧∨}(φ, redun^{*}(φ)).
% \end{equation*}

% \begin{theorem}[thm-redun]
%   \label{thm:thm_redun}
%   $Γ ⊢ φ$ then $Γ ⊢ redun(φ)$.
% \end{theorem}

% \begin{proof}
% Use in Theorem~\ref{thm:thm-reorder-and-or} with $ψ$ equals to
% $redun^{*}(φ)$.
% \end{proof}

% \improvement{We need here a text, or a comment about what
% is going next.}

% % subsection normalization (end)
% % --------------------------------------------------------------------
% \begin{lemma}[lem-rmPEM$_{∨}$]
%   \label{lem:lem-rmPEM-or}
%   \begin{align*}
%   \label{eq:rmPEM-or}
%     \begin{split}
%     rmPEM_{∨}(φ) =
%       \begin{cases}
%         ⊤, &\text{if }φ ≡ ¬ φ₁ ∨ φ₂,\ φ₁ ∈_{∨} φ₂\\
%         ⊤, &\text{if}φ ≡ ¬ φ₁ ∨ φ₂,\ rmPEM_{∨}(φ₂) ≡ ⊤\\
%         ¬ φ₁ ∨ rmPEM_{∨}(φ₂), &\text{if }φ ≡ ¬ φ₁ ∨ φ₂\\
%         ⊤, &\text{if }φ ≡ φ₁ ∨ φ₂,\ ¬φ₁ ∈_{∨} φ₂ \\
%         ⊤, &\text{if }φ ≡ φ₁ ∨ φ₂,\ rmPEM_{∨}(φ₂) ≡ ⊤\\
%         φ₁ ∨ rmPEM_{∨}(φ₂), &\text{if }φ ≡ φ₁ ∨ φ₂\\
%         φ, &\text{otherwise.}
%       \end{cases}
%     \end{split}
%   \end{align*}
% \end{lemma}

% \begin{lemma}[lem-rmPEM$_{∧∨}$]
%   \label{lem:lem-rmPEM-and-or}
%   \begin{equation*}
%     \label{eq:rmPEM-and-or}
%     rmPEM_{∧∨}(φ) =
%     \begin{cases}
%       rmPEM_{∨}(φ₁) ∧ rmPEM_{∨∧}(φ₂), &\text{ if }φ ≡ φ₁ ∧ φ₂\\
%       rmPEM_{∨}(φ), &\text{otherwise.}
%     \end{cases}
%   \end{equation*}
% \end{lemma}

% \begin{lemma}[lem-rmBot$_{∧}$]
%   \label{lem:lem-rmbot-and}
%    $Γ ⊢ φ$ then $Γ ⊢ rmBot_{∧}(φ)$, where,
%   \begin{equation*}
%     \label{eq:rmBot-and}
%     rmBot_{∧}(φ) =
%     \begin{cases}
%       ⊥, &\text{ if }φ ≡ ¬ φ₁ ∧ φ₂,\ φ₁ ∈_{∧} φ₂\\
%       ⊥, &\text{ if }φ ≡ ¬ φ₁ ∧ φ₂,\ rmBot_{∧}(φ₂) ≡ ⊥\\
%       ¬ φ₁ ∧ rmBot_{∧}(φ₂), &\text{if }φ ≡ ¬ φ₁ ∧ φ₂\\
%       ⊥, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ φ₁ ∈_{∧} φ₂\\
%       ⊥, &\text{ if }φ ≡ φ₁ ∧ φ₂,\ rmBot_{∧}(φ₂) ≡ ⊥\\
%       φ₁ ∧ rmBot_{∧}(φ₂), &\text{if }φ ≡ φ₁ ∧ φ₂\\
%       φ, &\text{otherwise.}
%     \end{cases}
%   \end{equation*}
% \end{lemma}

% \begin{lemma}[lem-canon]
%   \label{lem:lem-canon}
%   \begin{align*}
%   \begin{split}
%   &canon(φ) =\\
%   &\hspace{3mm}
%   \begin{cases}
%       canon(φⱼ), &\text{if } φ ≡ φ₁ ∧ φ₂,\ canon(φᵢ) ≡ ⊤,\\
%                  &\text{for same } i,j = 1,2, i≠j\\
%      ⊥, &\text{if } φ ≡ φ₁ ∧ φ₂,\ canon(φᵢ) ≡ ⊥, i = 1,2\\
%      canon(φ₁) ∧ canon(φ₂), &\text{if } φ ≡ φ₁ ∧ φ₂\\
%      ⊤, &\text{if } φ ≡ φ₁ ∨ φ₂,\ canon(φᵢ) ≡ ⊤, i = 1,2\\
%      canon(φⱼ), &\text{if } φ ≡ φ₁ ∨ φ₂,\ canon(φᵢ) ≡ ⊥,\\
%                 &\text{for same } i,j = 1,2, i≠j\\
%      canon(φ₁) ∨ canon(φ₂), &\text{if } φ ≡ φ₁ ∨ φ₂\\
%      φ, &\text{otherwise.}
%     \end{cases}
%   \end{split}
%   \end{align*}
% \end{lemma}

% \begin{theorem}[thm-canonicalize] % (fold)
%   \label{thm:thm-canonicalize}
%   $Γ ⊢ φ$ then $Γ ⊢ canonicalize(φ)$, where,
%   \begin{equation*}
%     canonicalize =
%      canon ∘ rmBot_{∧} ∘ rmPEM_{∧∨} ∘ redun ∘ rconj ∘ cnf.
%   \end{equation*}
% \end{theorem}

% The \canonicalize rule acts in \Metis' \TSTP derivations in three main cases. First, introducing the
% negation of a subgoal. Second, to simplify an intermediate derivation.
% Third, introducing an axiom or a definition of the.
% To justify the two first cases, we use the Theorem~\ref{thm:thm-canonicalize}. For the last case, we use the Lemma~\ref{lem:lem-nnf}.

% % -------------------------------------------------------------------
% \subsubsection{Simplify}
% \label{sssec:simplify}

% The \simplify rule is the application of the the lemma showed above,
% but also the following lemmas that intend to reduce a list of derivations,
% a conjunction of their formulas into a one smaller.

% \improvement{Missing theorems here.}


% % subsubsection simplify (end)
% % -------------------------------------------------------------------

\end{document}
