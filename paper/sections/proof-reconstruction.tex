
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===================================================================

\section{Proof-Reconstruction}
\label{sec:proof-reconstruction}

\subsection{Workflow}
\label{ssec:workflow}

\input{sections/diagram.tex}

The proof-reconstruction approach proposed consists of a series
of steps similar to the workflow presented by \citeauthor{sultana2015} in
\cite{sultana2015}. This process is a translation from a source
system to a target system. In our case, the system of origin, the
automatic theorem prover, is \Metis; the target system is a proof
assistant, \Agda. We choose \Agda, but another proof assistant with the
same support of type theory and inductive types could be used.
%  (see a description of \Agda for its main features in
% Section~\ref{sec:implementation}).
The overview of the proof-reconstruction is presented in
Fig.~\ref{fig:proof-reconstruction-workflow}. The process begin with
a \TPTP file that encodes a problem in \CPL. We use this file as the
input of the \Metis prover and if the problem is a theorem, \Metis can
reply a derivation of the proof in \TSTP format.

With the \TSTP derivation from Step~2, we process the derivation with the
\Athena translator tool.
\Athena parses the \TSTP format, analyzes the
derivation and generates a representation of the natural deduction
proof using a tree data structure (see the properties
of this tree in Section~\ref{ssec:metis-proofs}).
In the \Athena analysis, some unnecessary steps that introduce redundancies
and some unused input is removed from the proof-tree.
As result, we get from \Athena an \Agda file of the proof
with names of functions and theorems from
the \Agda libraries that accompany this article:
\texttt{agda-prop} and \texttt{agda-metis}.

Finally, we type-check the \Agda proof-term. If the type-checking
success, the \TSTP derivation delivered by \Metis is correct
module \Agda and the proposed formalizations for the
propositional logic and the \Metis inferences.
In that case \Agda outputs an interface file.
Otherwise, when type-checking fails, the failure must be
investigated by the user looking at the error in the \TSTP derivation
by \Metis, in the translation by \Athena, in the \Agda formalizations
mentioned above or even in the type-checker~\Agda.

In the remainder part of this section, a formal description using
type theory is presented to build definitions and theorems of
functions necessary to emulate \Metis' inference rules.
As a convention, we write the type judgments as ``$m : M$'' to denote
that $m$ has $\abbre{M}$ type.
Types are written using small caps.
We use \Prop type for propositions and the dependent type, $Γ ⊢ φ$ for
theorems where $Γ$ has $\abbre{List}~\Prop$ type, and $φ$ has type $\Prop$.
$\abbre{List}$ type is the usual inductive type for lists.
For syntactical equivalence, we write the equality as $φ ≡ ψ$
for $φ : \Prop$ and $ψ : \Prop$.

% ...................................................................

% section section_name (end)
\subsection{Structural recursion}
\label{ssec:structural-recursion}

To emulate \Metis' inference rules in type theory, we observed that
transformations performed by some rules are given by \emph{general recursive}
functions. Algorithms based on general recursions can not be translated
directly in type theory since it is not a guarantee they terminate. For that
reason, we follow the technique described in~\cite{Bertot2004} to avoid
termination problems by modifying the recursive functions to be
\emph{structural recursive}.
% (see \cite{Coquand1992,Abel2002,Bove2005} for more details).

This paper adopts the notion of \emph{structurally smaller} from
\citeauthor{Abel2002}~\cite{Abel2002} to say, a recursive function is
structurally recursive if it calls itself with only
structurally smaller arguments.

General recursive calls can be translated into structurally recursive
calls by using for instance, the \emph{Bounded Recursion} technique
presented in~\cite{Bertot2004}. For a yet another method, we refer
the reader to \cite{Coquand1992,Abel2002,Bove2005}.
The former technique defines a new function based on the original
recursive function by adding an argument to the function.
The new argument is the \emph{bound}, a natural number given by the
function complexity. In other words, the added argument will represent
the number of times the function needs to call itself to get the
expected outcome~\cite{Bertot2004}.

The type of natural numbers is called \Nat type, and it is defined as
usual, \ie \zero and \suc are the data constructors. We use names
and symbols of the arithmetic operations as usual.
We include syntax sugar for $\zero$, $\suc$, $\suc(\zero)$,
$\cdots$, with the decimal representation: $0$, $1$, $2$, $\cdots$
as well.

Therefore, for a general recursive function $\rm{f}: \Prop \to \Prop$
with termination problems, we formulate a new function
$\rm{f}^{*} : \Prop \to \Nat \to \Prop$ where all recursive calls must be
done by using induction on the \Nat type structure.

\subsubsection*{An  example.}
Let us consider the following example to exhibit the bounded technique
mentioned above for the \fuh function presented in the proposed version
for the \Metis \strip inference.

\begin{align}
  \label{eq:uh-definition}
    &\fuh_{0} &&: \Prop → \Prop\\
    &\fuh_{0}\ (φ₁ ⇒ (φ₂ ⇒ φ₃)) &&= \fuh_{0}((φ₁ ∧ φ₂) ⇒ φ₃)\\
    &\fuh_{0}\ (φ₁ ⇒ (φ₂ ∧ φ₃)) &&= \fuh_{0}(φ₁ ⇒ φ₂) ∧ \fuh_{0}(φ₁ ⇒ φ₃)\\
    &\fuh_{0}\ φ &&= φ
\end{align}

From the definition above, the size of the argument, $(φ₁ ∧ φ₂) ⇒ φ₃$,
is not structurally smaller than the input formula, $φ₁ ⇒ (φ₂ ⇒ φ₃)$,
since $(φ₁ ∧ φ₂) ⇒ φ₃$ is not a subformula of $φ₁ ⇒ (φ₂ ⇒ φ₃)$.

Therefore, we define the function
$\fuh_{1}$ by structural recursion in its second argument in
Eq.~(\ref{eq:uh-structured}).

\begin{align}
  \label{eq:uh-structured}
  \begin{split}
    &\fuh_{1} : \Prop → \Nat \to \Prop\\
    &\fuh_{1}(φ, \zero)\hspace{3mm}= φ\\%\hspace{10cm}\\
    &\fuh_{1}(φ, \suc(n)) =\\
    &\hspace{3mm}\begin{cases}
    \fuh_{1}((φ₁ ∧ φ₂) ⇒ φ₃, n),
      &\text{ if } φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\[2mm]
    \fuh_{1}(φ₁ ⇒ φ₂, n)\\
    ∧\ \fuh_{1}(φ₁ ⇒ φ₃, n),
       &\text{ if } φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃).
  \end{cases}
  \end{split}
\end{align}

As we mentioned above, the natural number in the second argument of
the function stands for a complexity measure of it.

Recall the \emph{complexity measure} defined in \cite{Agudelo-Agudelo2017}
and presented in \cite{VanDalen1994} as \emph{the rank for a
proposition}, is a function $\Prop \to \Nat$ that assigns a natural
number for a proposition $φ$ like the following $\frank$ function.
The symbols $c_{¬}$ and $c_{\square}$ are non-negative integer
numbers called the complexity of the respective connective.

\begin{align*}
  \begin{split}
  % \label{eq:rank-definition}
    &\frank : \Prop → \Nat\\
    &\frank(φ) =
    \begin{cases}
    \frank(φ₁) + c_{¬},  &\text{ if } φ ≡ \neg φ₁ \\
    \fmax{(\frank(φ₁),\ \frank(φ₂))} + c_{\square},
      &\text{ if } φ ≡ φ₁\,\square\, φ₂.\\
    0, &\text{ otherwise}
    \end{cases}
  \end{split}
\end{align*}

We define the $\fuh_{cm}: \Prop → \Nat$ function as
the complexity measure for the $\fuh_0$ function.

\begin{align*}
  \begin{split}
      &\fuh_{cm} : \Prop → \Nat\\
      &\fuh_{cm}(φ) =\\
      &\hspace{3mm}
        \begin{cases}
        \fuh_{cm}(φ₃) + 2, &\text{ if }φ ≡ φ₁ ⇒ (φ₂ ⇒ φ₃)\\
        \fmax(\fuh_{cm}(φ₂),\ \fuh_{cm}(φ₃)) + 1,
          &\text{ if }  φ ≡ φ₁ ⇒ (φ₂ ∧ φ₃)\\
        0, &\text{ otherwise.}
        \end{cases}
  \end{split}
\end{align*}

Finally, following the technique mentioned, we get a final version of
$\fuh_{0}$ function presented in Eq.~(\ref{eq:uh}).

\begin{definition}[uh]
  \label{def:uh}
    \begin{align}
      \label{eq:uh}
      \begin{split}
      &\fuh : \Prop → \Prop\\
      &\fuh(φ) = \fuh_{1}(φ, \fuh_{cm}(φ)).
      \end{split}
    \end{align}
\end{definition}

For a more complete treatment of general recursion, and how to
define well-founded and well-structural recursive functions, we refer
the reader to \citeauthor{Bove2005}~\cite{Bove2005}.

% % ................................................

\subsection{Emulating \Metis' inference rules}
\label{ssec:emulating-inferences}

In this section, we emulate each \Metis inference rule with a
function and its respective theorem.
The following pattern is used to present the formalization.
The function name written in bold font
is a \Metis inference rule in \TSTP derivations.
The same function name written in roman letters refers to the proposed
version of the rule.
Each rule proposed has a respective theorem also written in roman letters
that proves its soundness.
This theorem is named by using the prefix \emph{thm}
and the name of the rule.

For example, we know the \verb!conjunct! inference rule is a
\Metis inference rule since it appears in \TSTP derivations like
the following excerpt.

\begin{verbatim}
fof(normalize_1_2, plain, (p | r),
    inference(conjunct, [], [normalize_1_1])).
\end{verbatim}

For this inference rule, we proposed the \rm{conjunct} function in
Def.~\ref{def:conjunct} and we proved the theorem \rm{thm-conjunct}
in Thm.~\ref{thm:thm-conjunct}. The pattern is the following for
a binary rule and we extend it for $n$-ary rules in a natural way.

\begin{itemize}
\item \texttt{rule} is a binary \Metis inference rule.
\item $\rm{rule}$ is the proposed function for the \texttt{rule} inference.
\begin{align*}
  \begin{split}
    &\rm{rule} : \Prop → \Prop → \Prop\\
    &\rm{rule}\ φ₁\ φ₂\ ψ\ =
      \begin{cases}
      ψ, &\text{if }\rm{rule}\text{ built }ψ\text{ by applying valid transformations}\\
         &\text{or other rules to }φ₁\text{ and }φ₂\\
      φ, &\text{otherwise.}
      \end{cases}
  \end{split}
\end{align*}

\begin{itemize}
  \item $φᵢ$ are \emph{source} formulas from previous deducted derivations.
  \item $ψ$ is the \emph{target} formula. The expected result of \texttt{rule}.
\end{itemize}
\item \rm{thm-rule} is the theorem that proves the soundness of the
$\rm{rule}$ function.
\begin{equation*}\text{If }Γ ⊢ φ\text{ then }Γ ⊢ \rm{rule}\ φ.\end{equation*}

\end{itemize}

% ------------------------------------------------------------------------------

\subfile{sections/proof-reconstruction/strip.tex}
\subfile{sections/proof-reconstruction/negate.tex}
\subfile{sections/proof-reconstruction/resolve.tex}
\subfile{sections/proof-reconstruction/canonicalize.tex}
\subfile{sections/proof-reconstruction/conjunct.tex}
\subfile{sections/proof-reconstruction/clausify.tex}
\subfile{sections/proof-reconstruction/simplify.tex}

% ------------------------------------------------------------------------------

\end{document}
